import { InterruptControl, interruptSignal, FlowControl } from './enums.js';
import { Do } from './enums.js';
/** internal */
export default class Flow {
    constructor({ name, do: block }) {
        this.type = 'main';
        this.name = name;
        this.block = block;
        // each subflow can set itself as top because they will be copied later by each parent as it loads its subflows
        this.top = this;
    }
    validateNoDuplicate() {
        const name = this.name;
        this.name = undefined;
        if (name && this.getStep(name))
            throw Error(`Duplicate flow name: ${name}`);
        this.name = name;
    }
    flowStepArgs() {
        const args = { ...(this.top.args ?? {}) };
        let flow = this.top;
        while (flow instanceof Flow) {
            Object.assign(args, flow.thisStepArgs());
            flow = flow.step;
        }
        return args;
    }
    thisStepArgs() {
        if (this.position && 'value' in this.position && this.name) {
            return { [this.name]: this.position.value };
        }
    }
    branchJSON(forPlayer = true) {
        let branch = {
            type: this.type,
        };
        if (this.name)
            branch.name = this.name;
        if (this.position !== undefined)
            branch.position = this.toJSON(forPlayer);
        if (this.sequence !== undefined && this.currentBlock() instanceof Array)
            branch.sequence = this.sequence;
        const thisBranch = branch;
        if (this.step instanceof Flow)
            return [thisBranch].concat(this.step.branchJSON(forPlayer));
        return [thisBranch];
    }
    setBranchFromJSON(branch) {
        const node = branch[0];
        if (node === undefined)
            throw Error(`Insufficient position elements sent to flow for ${this.name}`);
        if (node.type !== this.type || node.name !== this.name) {
            throw Error(`Flow mismatch. Trying to set ${node.type}:${node.name} on ${this.type}:${this.name}`);
        }
        this.setPositionFromJSON(node.position, node.sequence);
        if (this.step instanceof Flow) {
            this.step.setBranchFromJSON(branch.slice(1)); // continue down the hierarchy
        }
    }
    setPosition(position, sequence, reset = true) {
        this.position = position;
        const block = this.currentBlock();
        if (!block) {
            this.step = undefined; // awaiting action or unreachable step
        }
        else if (block instanceof Array) {
            if (sequence === undefined)
                sequence = 0;
            this.sequence = sequence;
            if (!block[sequence])
                throw Error(`Invalid sequence for ${this.type}:${this.name} ${sequence}/${block.length}`);
            this.step = block[sequence];
        }
        else {
            this.step = block;
        }
        if (this.step instanceof Flow) {
            this.step.gameManager = this.gameManager;
            this.step.top = this.top;
            this.step.parent = this;
            if (reset)
                this.step.reset();
        }
    }
    setPositionFromJSON(positionJSON, sequence) {
        this.setPosition(this.fromJSON(positionJSON), sequence, false);
    }
    currentLoop(name) {
        if ('interrupt' in this && (!name || name === this.name))
            return this;
        return this.parent?.currentLoop();
    }
    currentProcessor() {
        if (this.step instanceof Flow)
            return this.step.currentProcessor();
        if (this.type === 'action' || this.type === 'parallel')
            return this;
    }
    actionNeeded(player) {
        return this.currentProcessor()?.actionNeeded(player);
    }
    processMove(move) {
        interruptSignal.splice(0);
        const step = this.currentProcessor();
        if (!step)
            throw Error(`Cannot process action currently ${JSON.stringify(this.branchJSON())}`);
        return step.processMove(move);
    }
    getStep(name) {
        if (this.name === name) {
            this.validateNoDuplicate();
            return this;
        }
        const steps = this.allSteps();
        if (!steps)
            return;
        for (const step of steps instanceof Array ? steps : [steps]) {
            if (step instanceof Flow) {
                const found = step.getStep(name);
                if (found)
                    return found;
            }
        }
    }
    /**
     * Advance flow one step and return FlowControl.complete if complete,
     * FlowControl.ok if can continue, Do to interrupt the current loop. Returns
     * ActionStep if now waiting for player input. override for self-contained
     * flows that do not have subflows.
     */
    playOneStep() {
        const step = this.step;
        let result = FlowControl.complete;
        if (step instanceof Function) {
            if (!interruptSignal[0])
                step(this.flowStepArgs());
            result = FlowControl.complete;
            if (interruptSignal[0] && interruptSignal[0].signal !== InterruptControl.subflow)
                result = interruptSignal.splice(0);
        }
        else if (step instanceof Flow) {
            result = step.playOneStep();
        }
        if (result === FlowControl.ok || result instanceof Flow)
            return result;
        if (result !== FlowControl.complete) {
            if ('interrupt' in this && typeof this.interrupt === 'function' && (!result[0].data || result[0].data === this.name))
                return this.interrupt(result[0].signal);
            return result;
        }
        // completed step, advance this block if able
        const block = this.currentBlock();
        if (block instanceof Array) {
            if ((this.sequence ?? 0) + 1 !== block.length) {
                this.setPosition(this.position, (this.sequence ?? 0) + 1);
                return FlowControl.ok;
            }
        }
        // completed block, advance self
        return this.advance();
    }
    // play until action required (returns ActionStep) or flow complete (undefined) or subflow started {name, args}
    play() {
        interruptSignal.splice(0);
        let step;
        do {
            if (this.gameManager.phase !== 'finished')
                step = this.playOneStep();
            if (!(step instanceof Flow))
                console.debug(`Advancing flow:\n ${this.stacktrace()}`);
        } while (step === FlowControl.ok && interruptSignal[0]?.signal !== InterruptControl.subflow && this.gameManager.phase !== 'finished');
        if (interruptSignal[0]?.signal === InterruptControl.subflow)
            return interruptSignal.map(s => s.data);
        if (step instanceof Flow)
            return step;
        if (step instanceof Array) {
            if (step[0].signal === InterruptControl.continue)
                throw Error("Cannot use Do.continue when not in a loop");
            if (step[0].signal === InterruptControl.repeat)
                throw Error("Cannot use Do.repeat when not in a loop");
            throw Error("Cannot use Do.break when not in a loop");
        }
        // flow complete
    }
    // must override. reset runs any logic needed and call setPosition. Must not modify own state.
    reset() {
        this.setPosition(undefined);
    }
    // must override. must rely solely on this.position
    currentBlock() {
        return this.block;
    }
    // override if position contains objects that need serialization
    toJSON(_forPlayer = true) {
        return this.position;
    }
    // override if position contains objects that need deserialization
    fromJSON(json) {
        return json;
    }
    // override for steps that advance through their subflows. call setPosition if needed. return ok/complete
    advance() {
        return FlowControl.complete;
    }
    // override return all subflows
    allSteps() {
        return this.block;
    }
    toString() {
        return `flow${this.name ? ":" + this.name.replace(/__/g, '') : ""}${this.block instanceof Array && this.block.length > 1 ? ' (item #' + this.sequence + ')' : ''}`;
    }
    stacktrace(indent = 0) {
        let string = this.toString();
        if (this.step instanceof Flow)
            string += '\n ' + ' '.repeat(indent) + 'â†³ ' + this.step.stacktrace(indent + 2);
        return string;
    }
    visualize(top) {
        return this.visualizeBlocks({
            type: 'flow',
            top,
            blocks: {
                do: this.block ? (this.block instanceof Array ? this.block : [this.block]) : undefined
            },
            block: 'do'
        });
    }
    visualizeBlocks({ type, blocks, name, top, block, position }) {
        const blockViz = Object.fromEntries(Object.entries(blocks).
            map(([key, block]) => [
            key, block?.map(s => {
                if (s instanceof Flow)
                    return s.visualize(top);
                if (s === Do.break)
                    return 'Do.break';
                if (s === Do.repeat)
                    return 'Do.repeat';
                if (s === Do.continue)
                    return 'Do.continue';
                return s.toString();
            })
        ]));
        return {
            type,
            name: name === undefined ? this.name : name,
            blocks: blockViz,
            current: {
                block,
                position,
                sequence: this.sequence
            }
        };
    }
}
//# sourceMappingURL=flow.js.map