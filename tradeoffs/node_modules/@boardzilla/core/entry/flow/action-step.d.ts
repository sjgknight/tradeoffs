import Flow from './flow.js';
import { FlowControl } from './enums.js';
import type { FlowBranchNode, FlowDefinition, FlowStep } from './flow.js';
import type { Player } from '../player/index.js';
import type { Argument, ActionStub } from '../action/action.js';
import type { InterruptSignal, SubflowSignal } from './enums.js';
export type ActionStepPosition = {
    player: number;
    name: string;
    args: Record<string, Argument>;
} | undefined;
export default class ActionStep extends Flow {
    players?: Player | Player[] | ((args: Record<string, any>) => Player | Player[]);
    position: ActionStepPosition;
    actions: {
        name: string;
        prompt?: string | ((args: Record<string, any>) => string);
        args?: Record<string, Argument> | ((args: Record<string, any>) => Record<string, Argument>);
        do?: FlowDefinition;
    }[];
    type: FlowBranchNode['type'];
    prompt?: string | ((args: Record<string, any>) => string);
    condition?: (args: Record<string, any>) => boolean;
    continueIfImpossible?: boolean;
    repeatUntil?: boolean;
    description?: string;
    skipIf: 'always' | 'never' | 'only-one';
    constructor({ name, player, players, actions, prompt, description, optional, condition, continueIfImpossible, repeatUntil, skipIf }: {
        name?: string;
        players?: Player[] | ((args: Record<string, any>) => Player[]);
        player?: Player | ((args: Record<string, any>) => Player);
        actions: (string | {
            name: string;
            prompt?: string | ((args: Record<string, any>) => string);
            args?: Record<string, Argument> | ((args: Record<string, any>) => Record<string, Argument>);
            do?: FlowDefinition;
        })[];
        prompt?: string | ((args: Record<string, any>) => string);
        condition?: (args: Record<string, any>) => boolean;
        continueIfImpossible?: boolean;
        repeatUntil?: string | ((args: Record<string, any>) => string);
        description?: string;
        optional?: string | ((args: Record<string, any>) => string);
        skipIf?: 'always' | 'never' | 'only-one';
    });
    reset(): void;
    thisStepArgs(): {
        [x: string]: Record<string, Argument>;
    } | undefined;
    setPosition(position: ActionStepPosition, sequence?: number): void;
    getPlayers(): number[] | undefined;
    awaitingAction(): boolean;
    currentBlock(): FlowDefinition | undefined;
    allowedActions(): string[];
    actionNeeded(player?: Player): {
        step?: string;
        prompt?: string;
        description?: string;
        actions: ActionStub[];
        continueIfImpossible?: boolean;
        skipIf: 'always' | 'never' | 'only-one';
    } | undefined;
    processMove(move: {
        player: number;
        name: string;
        args: Record<string, Argument>;
    }): string | SubflowSignal['data'][] | undefined;
    playOneStep(): InterruptSignal[] | FlowControl | Flow;
    advance(): FlowControl;
    toJSON(forPlayer?: boolean): any;
    fromJSON(position: any): any;
    allSteps(): FlowStep[];
    toString(): string;
    visualize(top: Flow): import("./flow.js").FlowVisualization;
}
//# sourceMappingURL=action-step.d.ts.map