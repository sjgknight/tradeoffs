import { FlowControl } from './enums.js';
import type { InterruptSignal, SubflowSignal } from './enums.js';
import type GameManager from '../game-manager.js';
import type { Player } from '../index.js';
import type { WhileLoopPosition } from './while-loop.js';
import type { ForLoopPosition } from './for-loop.js';
import type { ForEachPosition } from './for-each.js';
import type { SwitchCasePostion } from './switch-case.js';
import type { ActionStepPosition } from './action-step.js';
import type { EveryPlayerPosition } from './every-player.js';
import type { ActionStub } from '../action/action.js';
import type WhileLoop from './while-loop.js';
import type { Serializable } from '../action/utils.js';
/**
 * Several flow methods accept an argument of this type. This is an object
 * containing the current values of any loops or actions that the game is in the
 * middle of. Functions that can add these values are {@link forLoop}, {@link
 * forEach}, {@link switchCase} and {@link playerActions}. The `name` given to
 * these functions will be the key used in the FlowArguments and its value will
 * be the value of the current loop for loops, or the test value for switchCase,
 * or the arguments to the action taken for playerActions.
 *
 * @example
 * forLoop({
 *   name: 'x', // x is declared here
 *   initial: 0,
 *   next: x => x + 1,
 *   while: x => x < 3,
 *   do: forLoop({
 *     name: 'y', // y is declared here
 *     initial: 0,
 *     next: y => y + 1,
 *     while: y => y < 2,
 *     do: ({ x, y }) => {
 *       // x is available here as the value of the outer loop
 *       // and y will be the value of the inner loop
 *     }
 *   })
 * })
 * @category Flow
 */
export type FlowArguments = Record<string, any>;
/**
 * FlowStep's are provided to the game and to all flow function to provide
 * further flow logic inside the given flow. Any of the follow qualifies:
 * - a plain function that accepts {@link FlowArguments}
 * - one of the {@link Game#flowCommands}
 * @category Flow
 */
export type FlowStep = Flow | ((args: FlowArguments) => any);
/**
 * FlowDefinition's are provided to the game and to all flow function to provide
 * further flow logic inside the given flow. Any of the follow qualifies:
 * - a plain function that accepts {@link FlowArguments}
 * - one of the {@link Game#flowCommands}
 * - an array of any combination of the above
 * @category Flow
 */
export type FlowDefinition = FlowStep | FlowStep[];
export type FlowBranchNode = ({
    type: 'main';
} | {
    type: 'action';
    position: ActionStepPosition;
} | {
    type: 'parallel';
    position: EveryPlayerPosition;
} | {
    type: 'loop';
    position: WhileLoopPosition | ForLoopPosition<any>;
} | {
    type: 'foreach';
    position: ForEachPosition<any>;
} | {
    type: 'switch-case';
    position: SwitchCasePostion<any>;
}) & {
    name?: string;
    sequence?: number;
};
export type FlowBranchJSON = ({
    type: 'main' | 'action' | 'loop' | 'foreach' | 'switch-case' | 'parallel';
    position?: any;
}) & {
    name?: string;
    sequence?: number;
};
export type Position = (ActionStepPosition | ForLoopPosition<any> | WhileLoopPosition | ForEachPosition<any> | SwitchCasePostion<any> | EveryPlayerPosition);
export type FlowVisualization = {
    type: string;
    name?: string;
    blocks: Record<string, (string | FlowVisualization)[] | undefined>;
    current: {
        block?: string;
        position?: any;
        sequence?: number;
    };
};
/** internal */
export default class Flow {
    name?: string;
    position?: Position;
    sequence?: number;
    type: FlowBranchNode['type'];
    step?: FlowStep;
    block?: FlowDefinition;
    args?: Record<string, Serializable>;
    top: Flow;
    parent?: Flow;
    gameManager: GameManager;
    constructor({ name, do: block }: {
        name?: string;
        do?: FlowDefinition;
    });
    validateNoDuplicate(): void;
    flowStepArgs(): FlowArguments;
    thisStepArgs(): {
        [x: string]: any;
    } | undefined;
    branchJSON(forPlayer?: boolean): FlowBranchJSON[];
    setBranchFromJSON(branch: FlowBranchJSON[]): void;
    setPosition(position: any, sequence?: number, reset?: boolean): void;
    setPositionFromJSON(positionJSON: any, sequence?: number): void;
    currentLoop(name?: string): WhileLoop | undefined;
    currentProcessor(): Flow | undefined;
    actionNeeded(player?: Player): {
        step?: string;
        prompt?: string;
        description?: string;
        actions: ActionStub[];
        continueIfImpossible?: boolean;
        skipIf: 'always' | 'never' | 'only-one';
    } | undefined;
    processMove(move: NonNullable<ActionStepPosition>): string | SubflowSignal['data'][] | undefined;
    getStep(name: string): Flow | undefined;
    /**
     * Advance flow one step and return FlowControl.complete if complete,
     * FlowControl.ok if can continue, Do to interrupt the current loop. Returns
     * ActionStep if now waiting for player input. override for self-contained
     * flows that do not have subflows.
     */
    playOneStep(): InterruptSignal[] | FlowControl | Flow;
    play(): Flow | {
        name: string;
        args: Record<string, any>;
    }[] | undefined;
    reset(): void;
    currentBlock(): FlowDefinition | undefined;
    toJSON(_forPlayer?: boolean): any;
    fromJSON(json: any): typeof this.position;
    advance(): FlowControl;
    allSteps(): FlowDefinition | undefined;
    toString(): string;
    stacktrace(indent?: number): string;
    visualize(top: Flow): FlowVisualization;
    visualizeBlocks({ type, blocks, name, top, block, position }: {
        type: string;
        blocks: Record<string, FlowStep[] | undefined>;
        name?: string;
        top: Flow;
        block?: string;
        position?: any;
    }): FlowVisualization;
}
//# sourceMappingURL=flow.d.ts.map