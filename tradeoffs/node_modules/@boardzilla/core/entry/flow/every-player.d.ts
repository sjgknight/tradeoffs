import Flow from './flow.js';
import { FlowControl } from './enums.js';
import type { FlowDefinition, FlowBranchNode, FlowBranchJSON } from './flow.js';
import type { Player } from '../player/index.js';
import type { Argument } from '../action/action.js';
import type { SubflowSignal, InterruptSignal } from './enums.js';
export type EveryPlayerPosition = {
    positions: FlowBranchJSON[][];
    sequences: number[];
    completed: (boolean | undefined)[];
};
export default class EveryPlayer<P extends Player> extends Flow {
    position: EveryPlayerPosition;
    players?: P[];
    value: number;
    completed: (boolean | undefined)[];
    block: FlowDefinition;
    type: FlowBranchNode['type'];
    constructor({ players, do: block, name }: {
        players?: P[];
        do: FlowDefinition;
        name?: string;
    });
    reset(): void;
    thisStepArgs(): {
        [x: string]: P;
    } | undefined;
    withPlayer<T>(value: number, fn: () => T, mutate?: boolean): T;
    getPlayers(): P[];
    branchJSON(forPlayer?: boolean): FlowBranchJSON[];
    setPosition(positionJSON: any, sequence?: number): void;
    currentBlock(): FlowDefinition | undefined;
    actionNeeded(player?: Player): {
        step?: string | undefined;
        prompt?: string | undefined;
        description?: string | undefined;
        actions: import("../action/action.js").ActionStub[];
        continueIfImpossible?: boolean | undefined;
        skipIf: "always" | "never" | "only-one";
    } | undefined;
    processMove(move: {
        player: number;
        name: string;
        args: Record<string, Argument>;
    }): string | SubflowSignal['data'][] | undefined;
    playOneStep(): InterruptSignal[] | FlowControl | Flow;
    toString(): string;
    visualize(top: Flow): import("./flow.js").FlowVisualization;
}
//# sourceMappingURL=every-player.d.ts.map