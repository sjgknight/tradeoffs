import type PlayerCollection from './collection.js';
import type GameElement from '../board/element.js';
import type { BaseGame } from '../board/game.js';
import type { ElementClass } from '../board/element.js';
import type { ElementFinder, default as ElementCollection } from '../board/element-collection.js';
export interface BasePlayer extends Player<BaseGame, BasePlayer> {
}
/**
 * Base player class. Each game must declare a single player class that extends
 * this to be used for players joining the game. Additional properties and
 * methods on this class will be available in game, when e.g. a player argument
 * is passed to an action for the player taking that action.
 * @category Core
 */
export default class Player<G extends BaseGame = BaseGame, P extends BasePlayer = BasePlayer> {
    /**
     * A player's unique user id
     */
    id: string;
    /**
     * A player's chosen name
     */
    name: string;
    /**
     * String hex code of the player's chosen color
     */
    color: string;
    /**
     * String URL of the avatar image for this player
     */
    avatar: string;
    /**
     * Whether this player is the gane's host
     */
    host: boolean;
    /**
     * A player's seating position at the table. This is distinct from turn order,
     * which is the order of `game.players`. Turn order can be altered during a
     * game, whereas `position` cannot.
     */
    position: number;
    settings?: any;
    game: G;
    _players: PlayerCollection<P>;
    static isPlayer: boolean;
    /**
     * Provide list of attributes that are hidden from other players
     */
    static hide<P extends BasePlayer>(this: {
        new (): P;
        hiddenAttributes: string[];
    }, ...attrs: (keyof P)[]): void;
    static hiddenAttributes: string[];
    isCurrent(): boolean;
    /**
     * Set this player as the current player
     */
    setCurrent(this: P): void;
    /**
     * Returns an array of all other players.
     */
    others(): P[];
    /**
     * Returns the other player. Only allowed in 2 player games
     */
    other(): P;
    /**
     * Finds all elements of a given type that are owned by this player. This is
     * equivalent to calling `game.all(...)` with `{owner: this}` as one of the
     * search terms. Also see {@link GameElement#owner}.
     */
    allMy<F extends GameElement>(className: ElementClass<F>, ...finders: ElementFinder<F>[]): ElementCollection<F>;
    allMy(className?: ElementFinder, ...finders: ElementFinder[]): ElementCollection<GameElement<G, P>>;
    /**
     * Finds the first element of a given type that is owned by this player. This
     * is equivalent to calling `game.first(...)` with `{owner: this}` as one of
     * the search terms. Also see {@link GameElement#owner}.
     */
    my<F extends GameElement>(className: ElementClass<F>, ...finders: ElementFinder<F>[]): F | undefined;
    my(className?: ElementFinder, ...finders: ElementFinder[]): GameElement<G, P> | undefined;
    /**
     * Returns true if any element of a given type is owned by this player. This
     * is equivalent to calling `game.has(...)` with `{owner: this}` as one of
     * the search terms. Also see {@link GameElement#owner}.
     */
    has<F extends GameElement>(className: ElementClass<F>, ...finders: ElementFinder<F>[]): boolean;
    has(className?: ElementFinder, ...finders: ElementFinder[]): boolean;
    toJSON(player?: Player): {
        [x: string]: any;
    };
    toString(): string;
}
//# sourceMappingURL=player.d.ts.map