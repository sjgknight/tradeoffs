import Player from './player.js';
import type { PlayerAttributes } from '../game-manager.js';
import type { Sorter } from '../board/index.js';
/**
 * An Array-like collection of the game's players, mainly used in {@link
 * Game#players}. The array is automatically created when the game begins and
 * can be used to determine or alter play order. The order of the array is the
 * order of play, i.e. `game.players[1]` takes their turn right after
 * `game.players[0]`.
 * @noInheritDoc
 * @category Core
 */
export default class PlayerCollection<P extends Player> extends Array<P> {
    /**
     * An array of table positions that may currently act.
     */
    currentPosition: number[];
    className: {
        new (...a: any[]): P;
    };
    /**
     * A reference to the {@link Game} class
     */
    game: P['game'];
    addPlayer(attrs: PlayerAttributes & Record<string, any>): void;
    /**
     * Returns the player at a given table position.
     */
    atPosition(position: number): P | undefined;
    /**
     * Returns the player that may currently act. It is an error to call current
     * when multiple players can act
     */
    current(): P | undefined;
    /**
     * Returns the array of all players that may currently act.
     */
    allCurrent(): P[];
    /**
     * Returns the host player
     */
    host(): P;
    /**
     * Returns the array of players that may not currently act.
     */
    notCurrent(): P[];
    /**
     * Returns the array of players in the order of table positions. Does not
     * alter the actual player order.
     */
    inPositionOrder(): this;
    /**
     * Set the current player(s).
     *
     * @param players - The {@link Player} or table position of the player to act,
     * or an array of either.
     */
    setCurrent(players: number | P | number[] | P[]): void;
    /**
     * Advance the current player to act to the next player based on player order.
     */
    next(): P;
    /**
     * Return the next player to act based on player order.
     */
    after(player: number | P): P;
    /**
     * Return the player next to this player at the table.
     * @param steps - 1 = one step to the left, -1 = one step to the right, etc
     */
    seatedNext(player: P, steps?: number): P;
    /**
     * Returns the turn order of the given player, starting with 0. This is
     * distinct from {@link Player#position}. Turn order can be altered during a
     * game, whereas table position cannot.
     */
    turnOrderOf(player: number | P): number;
    /**
     * Sorts the players by some means, changing the turn order.
     * @param key - A key of function for sorting, or a list of such. See {@link
     * Sorter}
     * @param direction - `"asc"` to cause players to be sorted from lowest to
     * highest, `"desc"` for highest to lower
     */
    sortBy(key: Sorter<P> | (Sorter<P>)[], direction?: "asc" | "desc"): this;
    /**
     * Returns a copy of this collection sorted by some {@link Sorter}.
     */
    sortedBy(key: Sorter<P> | (Sorter<P>)[], direction?: "asc" | "desc"): this;
    sum(key: ((e: P) => number) | (keyof {
        [K in keyof P]: P[K] extends number ? never : K;
    })): number;
    withHighest(...attributes: Sorter<P>[]): P;
    withLowest(...attributes: Sorter<P>[]): P;
    shuffle(): void;
    max<K extends keyof P>(key: K): P[K];
    min<K extends keyof P>(key: K): P[K];
    fromJSON(players: Record<string, any>[]): void;
    assignAttributesFromJSON(players: PlayerAttributes[]): void;
}
//# sourceMappingURL=collection.d.ts.map