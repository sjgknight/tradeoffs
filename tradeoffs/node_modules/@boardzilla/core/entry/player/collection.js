import { shuffleArray } from '../utils.js';
import { deserializeObject } from '../action/utils.js';
/**
 * An Array-like collection of the game's players, mainly used in {@link
 * Game#players}. The array is automatically created when the game begins and
 * can be used to determine or alter play order. The order of the array is the
 * order of play, i.e. `game.players[1]` takes their turn right after
 * `game.players[0]`.
 * @noInheritDoc
 * @category Core
 */
export default class PlayerCollection extends Array {
    constructor() {
        super(...arguments);
        /**
         * An array of table positions that may currently act.
         */
        this.currentPosition = [];
    }
    addPlayer(attrs) {
        const player = new this.className(attrs);
        Object.assign(player, attrs, { _players: this });
        this.push(player);
        if (this.game) {
            player.game = this.game;
        }
    }
    /**
     * Returns the player at a given table position.
     */
    atPosition(position) {
        return this.find(p => p.position === position);
    }
    /**
     * Returns the player that may currently act. It is an error to call current
     * when multiple players can act
     */
    current() {
        if (this.currentPosition.length > 1)
            throw Error(`Using players.current when ${this.currentPosition.length} players may act`);
        return this.atPosition(this.currentPosition[0] ?? -1);
    }
    /**
     * Returns the array of all players that may currently act.
     */
    allCurrent() {
        return this.currentPosition.map(p => this.atPosition(p));
    }
    /**
     * Returns the host player
     */
    host() {
        return this.find(p => p.host);
    }
    /**
     * Returns the array of players that may not currently act.
     */
    notCurrent() {
        return this.filter(p => !this.currentPosition.includes(p.position));
    }
    /**
     * Returns the array of players in the order of table positions. Does not
     * alter the actual player order.
     */
    inPositionOrder() {
        return this.sort((p1, p2) => (p1.position > p2.position ? 1 : -1));
    }
    /**
     * Set the current player(s).
     *
     * @param players - The {@link Player} or table position of the player to act,
     * or an array of either.
     */
    setCurrent(players) {
        if (!(players instanceof Array))
            players = [players];
        players = players.map(p => typeof p === 'number' ? p : p.position);
        this.currentPosition = players;
    }
    /**
     * Advance the current player to act to the next player based on player order.
     */
    next() {
        if (this.currentPosition.length === 0) {
            this.currentPosition = [this[0].position];
        }
        else if (this.currentPosition.length === 1) {
            this.currentPosition = [this.after(this.currentPosition[0]).position];
        }
        return this.current();
    }
    /**
     * Return the next player to act based on player order.
     */
    after(player) {
        return this[(this.turnOrderOf(player) + 1) % this.length];
    }
    /**
     * Return the player next to this player at the table.
     * @param steps - 1 = one step to the left, -1 = one step to the right, etc
     */
    seatedNext(player, steps = 1) {
        return this.atPosition((player.position + steps - 1) % this.length + 1);
    }
    /**
     * Returns the turn order of the given player, starting with 0. This is
     * distinct from {@link Player#position}. Turn order can be altered during a
     * game, whereas table position cannot.
     */
    turnOrderOf(player) {
        if (typeof player !== 'number')
            player = player.position;
        const index = this.findIndex(p => p.position === player);
        if (index === -1)
            throw Error("No such player");
        return index;
    }
    /**
     * Sorts the players by some means, changing the turn order.
     * @param key - A key of function for sorting, or a list of such. See {@link
     * Sorter}
     * @param direction - `"asc"` to cause players to be sorted from lowest to
     * highest, `"desc"` for highest to lower
     */
    sortBy(key, direction) {
        const rank = (p, k) => typeof k === 'function' ? k(p) : p[k];
        const [up, down] = direction === 'desc' ? [-1, 1] : [1, -1];
        return this.sort((a, b) => {
            const keys = key instanceof Array ? key : [key];
            for (const k of keys) {
                const r1 = rank(a, k);
                const r2 = rank(b, k);
                if (r1 > r2)
                    return up;
                if (r1 < r2)
                    return down;
            }
            return 0;
        });
    }
    /**
     * Returns a copy of this collection sorted by some {@link Sorter}.
     */
    sortedBy(key, direction = "asc") {
        return this.slice(0, this.length).sortBy(key, direction);
    }
    sum(key) {
        return this.reduce((sum, n) => sum + (typeof key === 'function' ? key(n) : n[key]), 0);
    }
    withHighest(...attributes) {
        return this.sortedBy(attributes, 'desc')[0];
    }
    withLowest(...attributes) {
        return this.sortedBy(attributes, 'asc')[0];
    }
    shuffle() {
        shuffleArray(this, this.game?.random || Math.random);
    }
    max(key) {
        return this.sortedBy(key, 'desc')[0][key];
    }
    min(key) {
        return this.sortedBy(key, 'asc')[0][key];
    }
    fromJSON(players) {
        // reset all on self
        this.splice(0);
        for (const p of players) {
            this.addPlayer({ position: p.position });
        }
    }
    assignAttributesFromJSON(players) {
        for (let p = 0; p !== players.length; p++) {
            Object.assign(this[p], deserializeObject(players[p], this.game));
        }
    }
}
//# sourceMappingURL=collection.js.map