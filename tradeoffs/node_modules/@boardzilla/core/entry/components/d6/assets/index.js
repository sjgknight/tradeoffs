var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
  }
});

// node_modules/uuid-random/index.js
var require_uuid_random = __commonJS({
  "node_modules/uuid-random/index.js"(exports, module) {
    "use strict";
    (function() {
      var buf, bufIdx = 0, hexBytes = [], i;
      for (i = 0; i < 256; i++) {
        hexBytes[i] = (i + 256).toString(16).substr(1);
      }
      uuid2.BUFFER_SIZE = 4096;
      uuid2.bin = uuidBin;
      uuid2.clearBuffer = function() {
        buf = null;
        bufIdx = 0;
      };
      uuid2.test = function(uuid3) {
        if (typeof uuid3 === "string") {
          return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(uuid3);
        }
        return false;
      };
      var crypt0;
      if (typeof crypto !== "undefined") {
        crypt0 = crypto;
      } else if (typeof window !== "undefined" && typeof window.msCrypto !== "undefined") {
        crypt0 = window.msCrypto;
      }
      if (typeof module !== "undefined" && typeof __require === "function") {
        crypt0 = crypt0 || require_crypto();
        module.exports = uuid2;
      } else if (typeof window !== "undefined") {
        window.uuid = uuid2;
      }
      uuid2.randomBytes = function() {
        if (crypt0) {
          if (crypt0.randomBytes) {
            return crypt0.randomBytes;
          }
          if (crypt0.getRandomValues) {
            if (typeof Uint8Array.prototype.slice !== "function") {
              return function(n) {
                var bytes = new Uint8Array(n);
                crypt0.getRandomValues(bytes);
                return Array.from(bytes);
              };
            }
            return function(n) {
              var bytes = new Uint8Array(n);
              crypt0.getRandomValues(bytes);
              return bytes;
            };
          }
        }
        return function(n) {
          var i2, r = [];
          for (i2 = 0; i2 < n; i2++) {
            r.push(Math.floor(Math.random() * 256));
          }
          return r;
        };
      }();
      function randomBytesBuffered(n) {
        if (!buf || bufIdx + n > uuid2.BUFFER_SIZE) {
          bufIdx = 0;
          buf = uuid2.randomBytes(uuid2.BUFFER_SIZE);
        }
        return buf.slice(bufIdx, bufIdx += n);
      }
      function uuidBin() {
        var b = randomBytesBuffered(16);
        b[6] = b[6] & 15 | 64;
        b[8] = b[8] & 63 | 128;
        return b;
      }
      function uuid2() {
        var b = uuidBin();
        return hexBytes[b[0]] + hexBytes[b[1]] + hexBytes[b[2]] + hexBytes[b[3]] + "-" + hexBytes[b[4]] + hexBytes[b[5]] + "-" + hexBytes[b[6]] + hexBytes[b[7]] + "-" + hexBytes[b[8]] + hexBytes[b[9]] + "-" + hexBytes[b[10]] + hexBytes[b[11]] + hexBytes[b[12]] + hexBytes[b[13]] + hexBytes[b[14]] + hexBytes[b[15]];
      }
    })();
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports, module) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactVersion = "18.2.0";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: null
        };
        var ReactCurrentActQueue = {
          current: null,
          // Used to reproduce behavior of `batchedUpdates` in legacy mode.
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false
        };
        var ReactCurrentOwner = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
          ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        function warn(format) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
        }
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          /**
           * Checks whether or not this composite component is mounted.
           * @param {ReactClass} publicInstance The instance we want to test.
           * @return {boolean} True if mounted, false otherwise.
           * @protected
           * @final
           */
          isMounted: function(publicInstance) {
            return false;
          },
          /**
           * Forces an update. This should only be invoked when it is known with
           * certainty that we are **not** in a DOM transaction.
           *
           * You may want to call this when you know that some deeper aspect of the
           * component's state has changed but `setState` was not called.
           *
           * This will not invoke `shouldComponentUpdate`, but it will invoke
           * `componentWillUpdate` and `componentDidUpdate`.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          /**
           * Replaces all of the state. Always use this or `setState` to mutate state.
           * You should treat `this.state` as immutable.
           *
           * There is no guarantee that `this.state` will be immediately updated, so
           * accessing `this.state` after calling this method may return the old value.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} completeState Next state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          /**
           * Sets a subset of the state. This only exists because _pendingState is
           * internal. This provides a merging strategy that is not available to deep
           * properties which is confusing. TODO: Expose pendingState or don't use it
           * during the merge.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} partialState Next partial state to be merged with state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} Name of the calling function in the public API.
           * @internal
           */
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var assign = Object.assign;
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
            throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
          return isArrayImpl(a);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement(type, config, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self = null;
          var source = null;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config);
              }
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            self = config.__self === void 0 ? null : config.__self;
            source = config.__source === void 0 ? null : config.__source;
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config, children) {
          if (element === null || element === void 0) {
            throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
          }
          var propName;
          var props = assign({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self, source, owner, props);
        }
        function isValidElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index) {
          if (typeof element === "object" && element !== null && element.key != null) {
            {
              checkKeyStringCoercion(element.key);
            }
            return escape("" + element.key);
          }
          return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (isArray(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                return c;
              });
            } else if (mappedChild != null) {
              if (isValidElement(mappedChild)) {
                {
                  if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                    checkKeyStringCoercion(mappedChild.key);
                  }
                }
                mappedChild = cloneAndReplaceKey(
                  mappedChild,
                  // Keep both the (mapped) and old keys if they differ, just as
                  // traverseAllChildren used to do for objects as children
                  escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                  (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                    // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                    // eslint-disable-next-line react-internal/safe-string-coercion
                    escapeUserProvidedKey("" + mappedChild.key) + "/"
                  ) : "") + childKey
                );
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getElementKey(child, i);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = String(children);
              throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function countChildren(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement(children)) {
            throw new Error("React.Children.only expected to receive a single React element child.");
          }
          return children;
        }
        function createContext(defaultValue) {
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null,
            // Add these to use same hidden class in VM as ServerContext
            _defaultValue: null,
            _globalName: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            thenable.then(function(moduleObject2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = moduleObject2;
              }
            }, function(error2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
            if (payload._status === Uninitialized) {
              var pending = payload;
              pending._status = Pending;
              pending._result = thenable;
            }
          }
          if (payload._status === Resolved) {
            var moduleObject = payload._result;
            {
              if (moduleObject === void 0) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
              }
            }
            {
              if (!("default" in moduleObject)) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
              }
            }
            return moduleObject.default;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            // We use these fields to store the result.
            _status: Uninitialized,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!render.name && !render.displayName) {
                  render.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function memo(type, compare) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare === void 0 ? null : compare
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!type.name && !type.displayName) {
                  type.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          {
            if (dispatcher === null) {
              error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext(Context) {
          var dispatcher = resolveDispatcher();
          {
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context);
        }
        function useState2(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef2(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect2(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useInsertionEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useInsertionEffect(create, deps);
        }
        function useLayoutEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        function useTransition() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useTransition();
        }
        function useDeferredValue(value) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDeferredValue(value);
        }
        function useId() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useId();
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type);
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        function startTransition(scope, options) {
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = {};
          var currentTransition = ReactCurrentBatchConfig.transition;
          {
            ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            scope();
          } finally {
            ReactCurrentBatchConfig.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task) {
          if (enqueueTaskImpl === null) {
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              var nodeRequire = module && module[requireString];
              enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                {
                  if (didWarnAboutMessageChannel === false) {
                    didWarnAboutMessageChannel = true;
                    if (typeof MessageChannel === "undefined") {
                      error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                    }
                  }
                }
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          }
          return enqueueTaskImpl(task);
        }
        var actScopeDepth = 0;
        var didWarnNoAwaitAct = false;
        function act(callback) {
          {
            var prevActScopeDepth = actScopeDepth;
            actScopeDepth++;
            if (ReactCurrentActQueue.current === null) {
              ReactCurrentActQueue.current = [];
            }
            var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
            var result;
            try {
              ReactCurrentActQueue.isBatchingLegacy = true;
              result = callback();
              if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                var queue = ReactCurrentActQueue.current;
                if (queue !== null) {
                  ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                  flushActQueue(queue);
                }
              }
            } catch (error2) {
              popActScope(prevActScopeDepth);
              throw error2;
            } finally {
              ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
            }
            if (result !== null && typeof result === "object" && typeof result.then === "function") {
              var thenableResult = result;
              var wasAwaited = false;
              var thenable = {
                then: function(resolve, reject) {
                  wasAwaited = true;
                  thenableResult.then(function(returnValue2) {
                    popActScope(prevActScopeDepth);
                    if (actScopeDepth === 0) {
                      recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                    } else {
                      resolve(returnValue2);
                    }
                  }, function(error2) {
                    popActScope(prevActScopeDepth);
                    reject(error2);
                  });
                }
              };
              {
                if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                  Promise.resolve().then(function() {
                  }).then(function() {
                    if (!wasAwaited) {
                      didWarnNoAwaitAct = true;
                      error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                    }
                  });
                }
              }
              return thenable;
            } else {
              var returnValue = result;
              popActScope(prevActScopeDepth);
              if (actScopeDepth === 0) {
                var _queue = ReactCurrentActQueue.current;
                if (_queue !== null) {
                  flushActQueue(_queue);
                  ReactCurrentActQueue.current = null;
                }
                var _thenable = {
                  then: function(resolve, reject) {
                    if (ReactCurrentActQueue.current === null) {
                      ReactCurrentActQueue.current = [];
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    } else {
                      resolve(returnValue);
                    }
                  }
                };
                return _thenable;
              } else {
                var _thenable2 = {
                  then: function(resolve, reject) {
                    resolve(returnValue);
                  }
                };
                return _thenable2;
              }
            }
          }
        }
        function popActScope(prevActScopeDepth) {
          {
            if (prevActScopeDepth !== actScopeDepth - 1) {
              error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
            }
            actScopeDepth = prevActScopeDepth;
          }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          {
            var queue = ReactCurrentActQueue.current;
            if (queue !== null) {
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  if (queue.length === 0) {
                    ReactCurrentActQueue.current = null;
                    resolve(returnValue);
                  } else {
                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  }
                });
              } catch (error2) {
                reject(error2);
              }
            } else {
              resolve(returnValue);
            }
          }
        }
        var isFlushing = false;
        function flushActQueue(queue) {
          {
            if (!isFlushing) {
              isFlushing = true;
              var i = 0;
              try {
                for (; i < queue.length; i++) {
                  var callback = queue[i];
                  do {
                    callback = callback(true);
                  } while (callback !== null);
                }
                queue.length = 0;
              } catch (error2) {
                queue = queue.slice(i + 1);
                throw error2;
              } finally {
                isFlushing = false;
              }
            }
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.startTransition = startTransition;
        exports.unstable_act = act;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useDeferredValue = useDeferredValue;
        exports.useEffect = useEffect2;
        exports.useId = useId;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useInsertionEffect = useInsertionEffect;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo;
        exports.useReducer = useReducer;
        exports.useRef = useRef2;
        exports.useState = useState2;
        exports.useSyncExternalStore = useSyncExternalStore;
        exports.useTransition = useTransition;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_development();
    }
  }
});

// src/board/element-collection.ts
var ElementCollection = class _ElementCollection extends Array {
  slice(...a) {
    return super.slice(...a);
  }
  filter(...a) {
    return super.filter(...a);
  }
  all(className, ...finders) {
    if (typeof className !== "function" || !("isGameElement" in className)) {
      if (className)
        finders = [className, ...finders];
      return this._finder(void 0, {}, ...finders);
    }
    return this._finder(className, {}, ...finders);
  }
  _finder(className, options, ...finders) {
    const coll = new _ElementCollection();
    if (options.limit !== void 0 && options.limit <= 0)
      return coll;
    const fns = finders.map((finder) => {
      if (typeof finder === "object") {
        const attrs = finder;
        return (el) => Object.entries(attrs).every(([k1, v1]) => (k1 === "empty" ? el.isEmpty() : el[k1]) === v1);
      }
      if (typeof finder === "string") {
        const name = finder;
        return (el) => el.name === name;
      }
      return finder;
    });
    const finderFn = (el, order) => {
      if ((!className || el instanceof className) && fns.every((fn) => fn(el))) {
        if (order === "asc") {
          coll.push(el);
        } else {
          coll.unshift(el);
        }
      }
      if (!options.noRecursive) {
        if (options.limit !== void 0) {
          coll.push(...el._t.children._finder(className, { limit: options.limit - coll.length, order: options.order }, ...finders));
        } else {
          coll.push(...el._t.children._finder(className, {}, ...finders));
        }
      }
    };
    if (options.order === "desc") {
      for (let e = this.length - 1; e >= 0; e--) {
        const el = this[e];
        if (options.limit !== void 0 && coll.length >= options.limit)
          break;
        finderFn(el, "desc");
      }
    } else {
      for (const el of this) {
        if (options.limit !== void 0 && coll.length >= options.limit)
          break;
        finderFn(el, "asc");
      }
    }
    return coll;
  }
  first(className, ...finders) {
    if (typeof className !== "function" || !("isGameElement" in className)) {
      if (className)
        finders = [className, ...finders];
      return this._finder(void 0, { limit: 1 }, ...finders)[0];
    }
    return this._finder(className, { limit: 1 }, ...finders)[0];
  }
  firstN(n, className, ...finders) {
    if (typeof n !== "number")
      throw Error("first argument must be number of matches");
    if (typeof className !== "function" || !("isGameElement" in className)) {
      if (className)
        finders = [className, ...finders];
      return this._finder(void 0, { limit: n }, ...finders);
    }
    return this._finder(className, { limit: n }, ...finders);
  }
  last(className, ...finders) {
    if (typeof className !== "function" || !("isGameElement" in className)) {
      if (className)
        finders = [className, ...finders];
      return this._finder(void 0, { limit: 1, order: "desc" }, ...finders)[0];
    }
    return this._finder(className, { limit: 1, order: "desc" }, ...finders)[0];
  }
  lastN(n, className, ...finders) {
    if (typeof n !== "number")
      throw Error("first argument must be number of matches");
    if (typeof className !== "function" || !("isGameElement" in className)) {
      if (className)
        finders = [className, ...finders];
      return this._finder(void 0, { limit: n, order: "desc" }, ...finders);
    }
    return this._finder(className, { limit: n, order: "desc" }, ...finders);
  }
  top(className, ...finders) {
    if (typeof className !== "function" || !("isGameElement" in className)) {
      if (className)
        finders = [className, ...finders];
      return this._finder(void 0, { limit: 1 }, ...finders)[0];
    }
    return this._finder(className, { limit: 1 }, ...finders)[0];
  }
  topN(n, className, ...finders) {
    if (typeof n !== "number")
      throw Error("first argument must be number of matches");
    if (typeof className !== "function" || !("isGameElement" in className)) {
      if (className)
        finders = [className, ...finders];
      return this._finder(void 0, { limit: n }, ...finders);
    }
    return this._finder(className, { limit: n }, ...finders);
  }
  bottom(className, ...finders) {
    if (typeof className !== "function" || !("isGameElement" in className)) {
      if (className)
        finders = [className, ...finders];
      return this._finder(void 0, { limit: 1, order: "desc" }, ...finders)[0];
    }
    return this._finder(className, { limit: 1, order: "desc" }, ...finders)[0];
  }
  bottomN(n, className, ...finders) {
    if (typeof n !== "number")
      throw Error("first argument must be number of matches");
    if (typeof className !== "function" || !("isGameElement" in className)) {
      if (className)
        finders = [className, ...finders];
      return this._finder(void 0, { limit: n, order: "desc" }, ...finders);
    }
    return this._finder(className, { limit: n, order: "desc" }, ...finders);
  }
  /**
   * Show these elements to all players
   * @category Visibility
   */
  showToAll() {
    for (const el of this) {
      delete el._visible;
    }
  }
  /**
   * Show these elements only to the given player
   * @category Visibility
   */
  showOnlyTo(player) {
    if (typeof player !== "number")
      player = player.position;
    for (const el of this) {
      el._visible = {
        default: false,
        except: [player]
      };
    }
  }
  /**
   * Show these elements to the given players without changing it's visibility to
   * any other players.
   * @category Visibility
   */
  showTo(...player) {
    if (typeof player[0] !== "number")
      player = player.map((p) => p.position);
    for (const el of this) {
      if (el._visible === void 0)
        continue;
      if (el._visible.default) {
        if (!el._visible.except)
          continue;
        el._visible.except = el._visible.except.filter((i) => !player.includes(i));
      } else {
        el._visible.except = Array.from(/* @__PURE__ */ new Set([...el._visible.except instanceof Array ? el._visible.except : [], ...player]));
      }
    }
  }
  /**
   * Hide this element from all players
   * @category Visibility
   */
  hideFromAll() {
    for (const el of this) {
      el._visible = { default: false };
    }
  }
  /**
   * Hide these elements from the given players without changing it's visibility to
   * any other players.
   * @category Visibility
   */
  hideFrom(...player) {
    if (typeof player[0] !== "number")
      player = player.map((p) => p.position);
    for (const el of this) {
      if (el._visible?.default === false && !el._visible.except)
        continue;
      if (el._visible === void 0 || el._visible.default === true) {
        el._visible = {
          default: true,
          except: Array.from(/* @__PURE__ */ new Set([...el._visible?.except instanceof Array ? el._visible.except : [], ...player]))
        };
      } else {
        if (!el._visible.except)
          continue;
        el._visible.except = el._visible.except.filter((i) => !player.includes(i));
      }
    }
  }
  /**
   * Sorts this collection by some {@link Sorter}.
   * @category Structure
   */
  sortBy(key, direction) {
    const rank = (e, k) => typeof k === "function" ? k(e) : e[k];
    const [up, down] = direction === "desc" ? [-1, 1] : [1, -1];
    return this.sort((a, b) => {
      const keys = key instanceof Array ? key : [key];
      for (const k of keys) {
        const r1 = rank(a, k);
        const r2 = rank(b, k);
        if (r1 > r2)
          return up;
        if (r1 < r2)
          return down;
      }
      return 0;
    });
  }
  /**
   * Returns a copy of this collection sorted by some {@link Sorter}.
   * @category Structure
   */
  sortedBy(key, direction = "asc") {
    return this.slice(0, this.length).sortBy(key, direction);
  }
  /**
   * Returns the sum of all elements in this collection measured by a provided key
   * @category Queries
   *
   * @example
   * deck.create(Card, '2', { pips: 2 });
   * deck.create(Card, '3', { pips: 3 });
   * deck.all(Card).sum('pips'); // => 5
   */
  sum(key) {
    return this.reduce((sum, n) => sum + (typeof key === "function" ? key(n) : n[key]), 0);
  }
  /**
   * Returns the element in this collection with the highest value of the
   * provided key(s).
   * @category Queries
   *
   * @param attributes - any number of {@link Sorter | Sorter's} used for
   * comparing. If multiple are provided, subsequent ones are used to break ties
   * on earlier ones.
   *
   * @example
   * army.create(Soldier, 'a', { strength: 2, initiative: 3 });
   * army.create(Soldier, 'b', { strength: 3, initiative: 1 });
   * army.create(Soldier, 'c', { strength: 3, initiative: 2 });
   * army.all(Solider).withHighest('strength', 'initiative'); // => Soldier 'c'
   */
  withHighest(...attributes) {
    return this.sortedBy(attributes, "desc")[0];
  }
  /**
   * Returns the element in this collection with the lowest value of the
   * provided key(s).
   * @category Queries
   *
   * @param attributes - any number of {@link Sorter | Sorter's} used for
   * comparing. If multiple are provided, subsequent ones are used to break ties
   * on earlier ones.
   *
   * @example
   * army.create(Soldier, 'a', { strength: 2, initiative: 3 });
   * army.create(Soldier, 'b', { strength: 3, initiative: 1 });
   * army.create(Soldier, 'c', { strength: 2, initiative: 2 });
   * army.all(Solider).withLowest('strength', 'initiative'); // => Soldier 'c'
   */
  withLowest(...attributes) {
    return this.sortedBy(attributes, "asc")[0];
  }
  /**
   * Returns the highest value of the provided key(s) found on any element in
   * this collection.
   * @category Queries
   *
   * @param key - a {@link Sorter | Sorter's} used for comparing and extracting
   * the max.
   *
   * @example
   * army.create(Soldier, 'a', { strength: 2, initiative: 3 });
   * army.create(Soldier, 'b', { strength: 3, initiative: 1 });
   * army.create(Soldier, 'c', { strength: 2, initiative: 2 });
   * army.all(Solider).max('strength'); // => 3
   */
  max(key) {
    const el = this.sortedBy(key, "desc")[0];
    if (!el)
      return;
    return typeof key === "function" ? key(el) : el[key];
  }
  /**
   * Returns the lowest value of the provided key(s) found on any element in
   * this collection.
   * @category Queries
   *
   * @param key - a {@link Sorter | Sorter's} used for comparing and extracting
   * the minimum.
   *
   * @example
   * army.create(Soldier, 'a', { strength: 2, initiative: 3 });
   * army.create(Soldier, 'b', { strength: 3, initiative: 1 });
   * army.create(Soldier, 'c', { strength: 2, initiative: 2 });
   * army.all(Solider).min('initiative'); // => 1
   */
  min(key) {
    const el = this.sortedBy(key, "asc")[0];
    if (!el)
      return;
    return typeof key === "function" ? key(el) : el[key];
  }
  /**
   * Returns whether all elements in this collection have the same value for key.
   * @category Queries
   */
  areAllEqual(key) {
    if (this.length === 0)
      return true;
    return this.every((el) => el[key] === this[0][key]);
  }
  /**
   * Remove all elements in this collection from the playing area and place them
   * into {@link Game#pile}
   * @category Structure
   */
  remove() {
    for (const el of this) {
      if ("isSpace" in el)
        throw Error("cannot move Space");
      el.remove();
    }
  }
  /**
   * Move all pieces in this collection into another element. See {@link Piece#putInto}.
   * @category Structure
   */
  putInto(to, options) {
    if (this.some((el) => el.hasMoved()) || to.hasMoved())
      to.game.addDelay();
    for (const el of this) {
      if ("isSpace" in el)
        throw Error("cannot move Space");
      el.putInto(to, options);
    }
  }
  // UI
  /**
   * Apply a layout to some of the elements directly contained within the elements
   * in this collection. See {@link GameElement#layout}
   * @category UI
   */
  layout(applyTo, attributes) {
    for (const el of this)
      el.layout(applyTo, attributes);
  }
  /**
   * Configure the layout for all elements contained within this collection. See
   * {@link GameElement#configureLayout}
   * @category UI
   */
  configureLayout(attributes) {
    for (const el of this)
      el.configureLayout(attributes);
  }
  /**
   * Define the appearance of the elements in this collection. Any values
   * provided override previous ones. See {@link GameElement#appearance}.
   * @category UI
   */
  appearance(appearance) {
    for (const el of this)
      el.appearance(appearance);
  }
};

// src/action/utils.ts
var serialize = (arg, forPlayer = true, name) => {
  if (arg === void 0)
    return void 0;
  if (arg === null)
    return null;
  if (arg instanceof Array)
    return arg.map((a) => serialize(a, forPlayer));
  if (typeof arg === "object" && "constructor" in arg && ("isPlayer" in arg.constructor || "isGameElement" in arg.constructor)) {
    return serializeSingleArg(arg, forPlayer);
  }
  if (typeof arg === "object")
    return serializeObject(arg, forPlayer);
  if (typeof arg === "number" || typeof arg === "string" || typeof arg === "boolean")
    return serializeSingleArg(arg, forPlayer);
  throw Error(`Unable to serialize the property ${name ? '"' + name + '": ' : ""} ${arg}. Only primitives, Player's, GameElement's or arrays/objects containing such can be used.`);
};
var serializeSingleArg = (arg, forPlayer = true) => {
  if (typeof arg === "object" && "constructor" in arg) {
    if ("isPlayer" in arg.constructor)
      return `$p[${arg.position}]`;
    if ("isGameElement" in arg.constructor)
      return forPlayer ? `$el[${arg.branch()}]` : `$eid[${arg._t.id}]`;
  }
  return arg;
};
var serializeObject = (obj, forPlayer = true) => {
  return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, serialize(v, forPlayer, k)]));
};
var deserializeSingleArg = (arg, game) => {
  if (typeof arg === "number" || typeof arg === "boolean")
    return arg;
  let deser;
  if (arg.slice(0, 3) === "$p[") {
    deser = game.players.atPosition(parseInt(arg.slice(3, -1)));
  } else if (arg.slice(0, 4) === "$el[") {
    deser = game.atBranch(arg.slice(4, -1));
  } else if (arg.slice(0, 5) === "$eid[") {
    deser = game.atID(parseInt(arg.slice(5, -1)));
  } else {
    return arg;
  }
  if (!deser)
    throw Error(`Unable to find arg: ${arg}`);
  return deser;
};
var deserializeObject = (obj, game) => {
  return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, deserialize(v, game)]));
};
var deserialize = (arg, game) => {
  if (arg === void 0)
    return void 0;
  if (arg === null)
    return null;
  if (arg instanceof Array)
    return arg.map((a) => deserialize(a, game));
  if (typeof arg === "object")
    return deserializeObject(arg, game);
  if (typeof arg === "number" || typeof arg === "string" || typeof arg === "boolean")
    return deserializeSingleArg(arg, game);
  throw Error(`unable to deserialize ${arg}`);
};

// src/utils.ts
var shuffleArray = (array, random) => {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
};
var times = (n, fn) => Array.from(Array(n)).map((_, i) => fn(i + 1));

// src/board/element.ts
var import_uuid_random = __toESM(require_uuid_random(), 1);
var GameElement = class _GameElement {
  /**
   * Do not use the constructor directly. Instead Call {@link
   * GameElement#create} or {@link GameElement#createMany} on the element in
   * which you want to create a new element.
   * @category Structure
   */
  constructor(ctx) {
    /**
     * tree info
     * @internal
     */
    this._t = {
      children: new ElementCollection(),
      id: 0,
      ref: 0,
      setId: () => {
      }
    };
    /**
     * UI
     * @internal
     */
    this._ui = {
      layouts: [],
      appearance: {},
      getBaseLayout: () => ({
        alignment: "center",
        direction: "square"
      })
    };
    this._ctx = ctx;
    this._ctx.classRegistry ??= [];
    if (!ctx.top) {
      this._ctx.top = this;
      this._ctx.sequence = 0;
    }
    if (!this._ctx.namedSpaces) {
      this._ctx.uniqueNames = {};
      this._ctx.namedSpaces = {};
    }
    this._t = {
      children: new ElementCollection(),
      id: this._ctx.sequence,
      ref: this._ctx.sequence,
      setId: (id) => {
        if (id !== void 0) {
          this._t.id = id;
          if (this._ctx.sequence < id)
            this._ctx.sequence = id;
        }
      }
    };
    this._ctx.sequence += 1;
  }
  static {
    this.isGameElement = true;
  }
  static {
    this.unserializableAttributes = ["_ctx", "_t", "_ui", "game"];
  }
  /**
   * String used for representng this element in game messages when the object
   * is passed directly, e.g. when taking the choice directly from a
   * chooseOnBoard choice.
   * @category Structure
   */
  toString() {
    return this.name || this.constructor.name.replace(/([a-z0-9])([A-Z])/g, "$1 $2");
  }
  isVisibleTo(_player) {
    return true;
  }
  isVisible() {
    return true;
  }
  all(className, ...finders) {
    return this._t.children.all(className, ...finders);
  }
  first(className, ...finders) {
    return this._t.children.first(className, ...finders);
  }
  firstN(n, className, ...finders) {
    return this._t.children.firstN(n, className, ...finders);
  }
  last(className, ...finders) {
    return this._t.children.last(className, ...finders);
  }
  lastN(n, className, ...finders) {
    return this._t.children.lastN(n, className, ...finders);
  }
  top(className, ...finders) {
    return this._t.children.top(className, ...finders);
  }
  topN(n, className, ...finders) {
    return this._t.children.topN(n, className, ...finders);
  }
  bottom(className, ...finders) {
    return this._t.children.bottom(className, ...finders);
  }
  bottomN(n, className, ...finders) {
    return this._t.children.bottomN(n, className, ...finders);
  }
  others(className, ...finders) {
    if (!this._t.parent)
      new ElementCollection();
    return this._t.parent._t.children.all(className, (el) => el !== this, ...finders);
  }
  has(className, ...finders) {
    if (typeof className !== "function" || !("isGameElement" in className)) {
      if (className)
        finders = [className, ...finders];
      return !!this.first(_GameElement, ...finders);
    }
    return !!this.first(className, ...finders);
  }
  /**
   * If this element is adjacent to some other element, using the nearest
   * containing space that has an adjacency map.
   * @category Adjacency
   */
  isAdjacentTo(element) {
    const graph = this.containerWithProperty("isAdjacent");
    if (!graph)
      return false;
    return graph.isAdjacent(this, element);
  }
  /**
   * Finds the shortest distance between two spaces
   * @category Adjacency
   *
   * @param element - {@link element} to measure distance to
   */
  distanceTo(element) {
    const graph = this.containerWithProperty("distanceBetween");
    if (!graph)
      return Infinity;
    return graph.distanceBetween(this, element);
  }
  adjacencies(className, ...finders) {
    const graph = this.containerWithProperty("isAdjacent");
    if (!graph)
      return false;
    return graph.allAdjacentTo(this, className, ...finders);
  }
  withinDistance(distance, className, ...finders) {
    const graph = this.containerWithProperty("allWithinDistanceOf");
    if (!graph)
      return new ElementCollection();
    return graph.allWithinDistanceOf(this, distance, className, ...finders);
  }
  /**
   * Set this class to use a different ordering style.
   * @category Structure
   * @param order - ordering style
   * - "normal": Elements placed into this element are put at the end of the
   *   list (default)
   * - "stacking": Used primarily for stacks of cards. Elements placed into this
   *   element are put at the beginning of the list. E.g. if a stack of cards
   *   has `order` set to `stacking` the {@link first} method will return the
   *   last card placed in the stack, rather than the first one placed in the
   *   stack. Hidden items in the stack are not tracked or animated while
   *   reordered to prevent their identity from being exposed as they move
   */
  setOrder(order) {
    this._t.order = order;
  }
  /**
   * Returns this elements parent.
   * @category Queries
   * @param className - If provided, searches up the parent tree to find the first
   * matching element. E.g. if a Token is placed on a Card in a players
   * Tableau. calling `token.container(Tableau)` can be used to find the
   * grandparent.
   */
  container(className) {
    if (!className)
      return this._t.parent;
    if (this._t.parent)
      return this._t.parent instanceof className ? this._t.parent : this._t.parent.container(className);
  }
  /**
   * Returns this elements containing element that also has a given property.
   * @category Queries
   */
  containerWithProperty(property, value) {
    const parent = this._t.parent;
    if (parent)
      return property in parent && (value === void 0 || parent[property] === value) ? parent : parent.containerWithProperty(property, value);
  }
  /**
   * Returns whether this element has no elements placed within it.
   * @category Structure
   */
  isEmpty() {
    return !this._t.children.length;
  }
  /**
   * Sorts the elements directly contained within this element by some {@link Sorter}.
   * @category Structure
   */
  sortBy(key, direction) {
    return this._t.children.sortBy(key, direction);
  }
  /**
   * re-orders the elements directly contained within this element randomly.
   * @category Structure
   */
  shuffle() {
    const refs = this.childRefsIfObscured();
    shuffleArray(this._t.children, this._ctx.gameManager?.random || Math.random);
    if (refs)
      this.assignChildRefs(refs);
  }
  /**
   * The player that owns this element, or the first element that contains this
   * element searching up through the parent hierarchy. This is related to, but
   * different than {@link player}. E.g. if a standard playing card is in a
   * player's hand, typically the `hand.player` will be assigned to that player
   * but the card itself would not have a `player`. In this case the
   * card.owner() will equal the player in whose hand the card is placed.
   * @category Structure
   */
  get owner() {
    return this.player !== void 0 ? this.player : this._t.parent?.owner;
  }
  /**
   * Whether this element belongs to the player viewing the game. A player is
   * considered to be currently viewing the game if this is called in the
   * context of an action taken by a given player (during an action taken by a
   * player or while the game is viewed by a given player.) It is an error to
   * call this method when not in the context of a player action. When querying
   * for elements using {@link ElementFinder} such as {@link all} and {@link
   * first}, {@link mine} is available as a search key that accepts a value of
   * true/false
   @category Queries
   */
  get mine() {
    if (!this._ctx.player)
      return false;
    return this.owner === this._ctx.player;
  }
  /**
   * Create an element inside this element. This can only be called during the
   * game setup (see {@link createGame}. Any game elements that are required
   * must be created before the game starts. Elements that only appear later in
   * the game can be created inside the {@link Game#pile} or made invisible.
   * @category Structure
   *
   * @param className - Class to create. This class must be included in the `elementClasses` in {@link createGame}.
   * @param name - Sets {@link GameElement#name | name}
   * @param attributes - Sets any attributes of the class that are defined in
   * your own class that extend {@link Space}, {@link Piece}, or {@link
   * Game}. Can also include {@link player}.
   *
   * @example
   * deck.create(Card, 'ace-of-hearts', { suit: 'H', value: '1' });
   */
  create(className, name, attributes) {
    if (this._ctx.gameManager?.phase === "started")
      throw Error("Game elements cannot be created once game has started.");
    const el = this.createElement(className, name, attributes);
    el._t.parent = this;
    const firstPiece = this._t.children.findIndex((c) => !("isSpace" in c));
    if (this._t.order === "stacking" && !("isSpace" in el)) {
      if (firstPiece > 0) {
        this._t.children.splice(firstPiece, 0, el);
      } else {
        this._t.children.unshift(el);
      }
    } else {
      if ("isSpace" in el && firstPiece !== -1) {
        this._t.children.splice(firstPiece, 0, el);
      } else {
        this._t.children.push(el);
      }
    }
    if ("isSpace" in el && name) {
      if (name in this._ctx.uniqueNames) {
        delete this._ctx.namedSpaces[name];
        this._ctx.uniqueNames[name] = false;
      } else {
        this._ctx.namedSpaces[name] = el;
        this._ctx.uniqueNames[name] = true;
      }
    }
    return el;
  }
  /**
   * Create n elements inside this element of the same class. This can only be
   * called during the game setup (see {@link createGame}. Any game elements
   * that are required must be created before the game starts. Elements that
   * only appear later in the game can be created inside the {@link Game#pile}
   * or made invisible.
   * @category Structure
   *
   * @param n - Number to create
   * @param className - Class to create. This class must be included in the `elementClasses` in {@link createGame}.
   * @param name - Sets {@link GameElement#name | name}
   * @param attributes - Sets any attributes of the class that are defined in
   * your own class that extend {@link Space}, {@link Piece}, or {@link
   * Game}. Can also include {@link player}. If a function is supplied here, a
   * single number argument will be passed with the number of the added element,
   * starting with 1.
   */
  createMany(n, className, name, attributes) {
    return new ElementCollection(...times(n, (i) => this.create(className, name, typeof attributes === "function" ? attributes(i) : attributes)));
  }
  /**
   * Base element creation method
   * @internal
   */
  createElement(className, name, attrs) {
    if (!this._ctx.classRegistry.includes(className)) {
      this._ctx.classRegistry.push(className);
    }
    const el = new className(this._ctx);
    el.game = this.game;
    el.name = name;
    Object.assign(el, attrs);
    if ("afterCreation" in el)
      el.afterCreation.bind(el)();
    return el;
  }
  /**
   * Permanently remove an element. This can only be done while defining the
   * game, and is usually only useful when creating groups of elements, such as
   * {@link createMany} or {@link createGrid} where some of the created elements
   * are not needed.
   * @category Structure
   */
  destroy() {
    if (this._ctx.gameManager?.phase === "started")
      throw Error("Game elements cannot be destroy once game has started.");
    const position = this.position();
    this._t.parent?._t.children.splice(position, 1);
  }
  /**
   * Rotation of element if set, normalized to 0-359 degrees
   * @category Structure
   */
  get rotation() {
    if (this._rotation === void 0)
      return 0;
    return (this._rotation % 360 + 360) % 360;
  }
  set rotation(r) {
    this._rotation = r;
  }
  /**
   * Returns the index of this element within its parent, starting at zero
   * @category Structure
   */
  position() {
    return this._t.parent?._t.children.indexOf(this) ?? -1;
  }
  /**
   * Returns a string identifying the tree position of the element suitable for
   * anonymous reference
   * @internal
   */
  branch() {
    const branches = [];
    let node = this;
    while (node._t.parent) {
      const index = node.position();
      if (index === -1)
        throw Error(`Reference to element ${this.constructor.name}${this.name ? ":" + this.name : ""} is no longer current`);
      branches.unshift(index);
      node = node._t.parent;
    }
    branches.unshift(this._ctx.removed === node ? 1 : 0);
    return branches.join("/");
  }
  /**
   * Returns the element at the given position returned by {@link branch}
   * @internal
   */
  atBranch(b) {
    let branch = b.split("/");
    let index = parseInt(branch[0]);
    let node = index === 0 ? this._ctx.top : this._ctx.removed._t.children[index - 1];
    branch.shift();
    while (branch[0] !== void 0) {
      node = node._t.children[parseInt(branch[0])];
      branch.shift();
    }
    return node;
  }
  /**
   * Returns the element for the given id
   * @internal
   */
  atID(id) {
    let el = this._t.children.find((c) => c._t.id === id);
    if (el)
      return el;
    for (const child of this._t.children) {
      el = child.atID(id);
      if (el)
        return el;
    }
  }
  /**
   * Returns the element for the given ref
   * @internal
   */
  atRef(ref) {
    let el = this._t.children.find((c) => c._t.ref === ref);
    if (el)
      return el;
    for (const child of this._t.children) {
      el = child.atRef(ref);
      if (el)
        return el;
    }
  }
  _cellAt(pos) {
    if (!this._size)
      return pos.x === 0 && pos.y === 0 ? "." : void 0;
    if (this.rotation === 0)
      return this._size.shape[pos.y]?.[pos.x];
    if (this.rotation === 90)
      return this._size.shape[this._size.height - 1 - pos.x]?.[pos.y];
    if (this.rotation === 180)
      return this._size.shape[this._size.height - 1 - pos.y]?.[this._size.width - 1 - pos.x];
    if (this.rotation === 270)
      return this._size.shape[pos.x]?.[this._size.width - 1 - pos.y];
  }
  _sizeNeededFor(_element) {
    return { width: 1, height: 1 };
  }
  /**
     * Set an irregular shape for this element. This is only meaningful for the
     * purposes of finding specifically adjacent cells when placed into a
     * PieceGrid. See {@link PieceGrid#adjacenciesByCell}. When rendered in a
     * PieceGrid, the element will have a size large enough to fill the
     * appropriate number of spaces in the grid, but it's appearance is otherwise
     * unaffected and will be based on {@link appearance}. When not rendered in a
     * PieceGrid, the element will take up a single cell but will be scaled
     * relatively to other elements with a shape in the same layout.
     *
     * @param shape - A set of single characters used as labels for each cell. The
     * cell label characters are provided as an array of strings, with each string
     * being one row of cell labels, with spaces used to indicate empty "holes" in
     * the shape. Each row must be the same length. The specific non-space
     * characters used are used for labelling the adjacencies in {@link
     * PieceGrid#adjacenciesByCell} but are otherwise unimportant.
     * @category Adjacency
     *
     * @example
     *
     * domino12.setShape(
     *   '12'
     * );
  
     * tetrisPiece.setShape(
     *   'XX ',
     *   ' XX'
     * );
     */
  setShape(...shape) {
    if (this._ctx.gameManager?.phase === "started")
      throw Error("Cannot change shape once game has started.");
    if (shape.some((s) => s.length !== shape[0].length))
      throw Error("Each row in shape must be same size. Invalid shape:\n" + shape);
    this._size = {
      shape,
      width: shape[0].length,
      height: shape.length
    };
  }
  /**
   * Set the edge labels for this element. These are only meaningful for the
   * purposes of finding specifically adjacent edges when placed into a
   * PieceGrid. See {@link PieceGrid#adjacenciesByEdge}.
   * @category Adjacency
   *
   * @param edges - A set of edge labels for each cell label provided by {@link
   * setShape}. For simple 1-celled shapes, the edges can be provided without
   * cell labels.
   *
   * @example
   *
   * // a bridge tile with a road leading from left to right and a river leading
   * // from top to bottom.
   * simpleTile.setEdge(
   *   up: 'river',
   *   down: 'river',
   *   left: 'road'
   *   right: 'road'
   * });
   *
   * // A tetris-shaped tile with sockets coming out either "end"
   * tetrisPiece.setShape(
   *   'AX ',
   *   ' XB'
   * );
   * tetrisPiece.setEdge({
   *   A: {
   *     left: 'socket'
   *   },
   *   B: {
   *     right: 'socket'
   *   }
   * });
   */
  setEdges(edges) {
    if (this._ctx.gameManager?.phase === "started")
      throw Error("Cannot change shape once game has started.");
    if (Object.keys(edges)[0].length === 1) {
      const missingCell = Object.keys(edges).find((c) => this._size?.shape.every((s) => !s.includes(c)));
      if (missingCell)
        throw Error(`No cell '${missingCell}' defined in shape`);
      this._size.edges = edges;
    } else {
      if (this._size)
        throw Error("setEdges must use the cell characters from setShape as keys");
      this._size = { shape: ["."], width: 1, height: 1, edges: { ".": edges } };
    }
  }
  /**
   * Whether this element has the given element in its parent hierarchy
   * @category Structure
   */
  isDescendantOf(el) {
    return this._t.parent === el || !!this._t.parent?.isDescendantOf(el);
  }
  attributeList() {
    let attrs;
    ({ ...attrs } = this);
    for (const attr of this.constructor.unserializableAttributes)
      delete attrs[attr];
    return Object.fromEntries(Object.entries(attrs).filter(
      ([, value]) => typeof value !== "function"
    ));
  }
  /**
   * JSON representation
   * @param seenBy - optional player position viewing the game
   * @internal
   */
  toJSON(seenBy) {
    let attrs = this.attributeList();
    if (seenBy !== void 0 && !this.isVisibleTo(seenBy)) {
      attrs = Object.fromEntries(Object.entries(attrs).filter(
        ([attr]) => ["_visible", "row", "column", "_rotation", "_size"].includes(attr) || attr !== "name" && this.constructor.visibleAttributes?.includes(attr)
      ));
    }
    const json = Object.assign(serializeObject(attrs, seenBy !== void 0), { className: this.constructor.name });
    if (this._t.order)
      json.order = this._t.order;
    if (seenBy === void 0)
      json._id = this._t.id;
    if (json._id !== this._t.ref)
      json._ref = this._t.ref;
    if (seenBy !== void 0 && this._t.wasRef !== void 0 && this.isVisibleTo(seenBy))
      json._wasRef = this._t.wasRef;
    if (this._t.children.length && (!seenBy || !("_screen" in this) || this._screen === void 0 || this._screen === "all-but-owner" && this.owner?.position === seenBy || this._screen instanceof Array && this._screen.includes(this.owner?.position))) {
      json.children = Array.from(this._t.children.map((c) => c.toJSON(seenBy)));
    }
    if (globalThis.window) {
      try {
        structuredClone(json);
      } catch (e) {
        console.error(`invalid properties on ${this}:
${JSON.stringify(json, void 0, 2)}`);
        throw e;
      }
    }
    return json;
  }
  createChildrenFromJSON(childrenJSON, branch) {
    const childrenRefs = [...this._t.children];
    this._t.children = new ElementCollection();
    for (let i = 0; i !== childrenJSON.length; i++) {
      const json = childrenJSON[i];
      const childBranch = branch + "/" + i;
      let { className, children, _id, _ref, _wasRef, name, order } = json;
      let child = childrenRefs.find((c) => _id !== void 0 ? c._t.id === _id : c._t.ref === (_wasRef ?? _ref));
      if (!child) {
        const elementClass = this._ctx.classRegistry.find((c) => c.name === className);
        if (!elementClass)
          throw Error(`No class found ${className}. Declare any classes in \`game.registerClasses\``);
        child = this.createElement(elementClass, name);
        child._t.setId(_id);
        child._t.parent = this;
        child._t.order = order;
        child._t.ref = _ref ?? _id;
      } else {
        const emptyAttrs = Object.keys(child).filter((k) => !(k in json) && !["_rotation", "column", "row"].includes(k) && !child.constructor.unserializableAttributes.includes(k));
        if (emptyAttrs.length) {
          const blank = Reflect.construct(child.constructor, [{}]);
          for (const attr of emptyAttrs)
            Object.assign(child, { [attr]: blank[attr] });
        }
      }
      if (_id !== void 0)
        child._t.ref = _ref ?? _id;
      if (_wasRef !== void 0 && !this._ctx.trackMovement)
        child._t.wasRef = _wasRef;
      this._t.children.push(child);
      child.createChildrenFromJSON(children || [], childBranch);
    }
  }
  assignAttributesFromJSON(childrenJSON, branch) {
    for (let i = 0; i !== childrenJSON.length; i++) {
      const json = childrenJSON[i];
      let { className: _cn, children, _ref, _wasRef, _id, order: _o, ...rest } = json;
      rest = deserializeObject({ ...rest }, this.game);
      let child = this._t.children[i];
      Object.assign(child, rest);
      child.assignAttributesFromJSON(children || [], branch + "/" + i);
    }
  }
  resetUI() {
    this._ui.layouts = [{
      applyTo: _GameElement,
      attributes: this._ui.getBaseLayout()
    }];
    this._ui.appearance = {};
    for (const child of this._t.children)
      child.resetUI();
  }
  /**
   * Apply a layout to some of the elements directly contained within this
   * element. See also {@link ElementCollection#layout}
   * @category UI
   *
   * @param applyTo - Which elements this layout applies to. Provided value can be:
   * - A specific {@link GameElement}
   * - The name of an element
   * - A specific set of elements ({@link ElementCollection})
   * - A class of elements
   *
   * If multiple layout declarations would apply to the same element, only one
   * will be used. The order of specificity is as above. If a class is used and
   * mutiple apply, the more specific class will be used.
   *
   * @param {Object} attributes - A list of attributes describing the
   * layout. All units of measurement are percentages of this elements width and
   * height from 0-100, unless otherwise noted (See `margin` and `gap`)
   */
  layout(applyTo, attributes) {
    let { slots, area, size, aspectRatio, scaling, gap, margin, offsetColumn, offsetRow } = attributes;
    if (slots && (area || margin || scaling || gap || margin || offsetColumn || offsetRow)) {
      console.warn("Layout has `slots` which overrides supplied grid parameters");
      delete attributes.area;
      delete attributes.margin;
      delete attributes.gap;
      delete attributes.scaling;
      delete attributes.offsetRow;
      delete attributes.offsetColumn;
    }
    if (area && margin) {
      console.warn("Both `area` and `margin` supplied in layout. `margin` is ignored");
      delete attributes.margin;
    }
    if (size && aspectRatio) {
      console.warn("Both `size` and `aspectRatio` supplied in layout. `aspectRatio` is ignored");
      delete attributes.aspectRatio;
    }
    if (size && scaling) {
      console.warn("Both `size` and `scaling` supplied in layout. `scaling` is ignored");
      delete attributes.scaling;
    }
    if (gap && (offsetColumn || offsetRow)) {
      console.warn("Both `gap` and `offset` supplied in layout. `gap` is ignored");
      delete attributes.gap;
    }
    this._ui.layouts.push({ applyTo, attributes: { alignment: "center", direction: "square", ...attributes } });
  }
  /**
   * Creates a collapsible drawer layout for a Space within this Element. This
   * is like {@link GameElement#layout} except for one specific Space, with
   * additional parameters that set the behaviour/appearance of the drawer. A
   * tab will be attached the drawer that will allow it be opened/closed.
   *
   * @param applyTo - The Space for the drawer. Either the Space itself or its
   * name.
   * @param area - The area for the drawer when opened expressed in percentage
   * sizes of this element.
   * @param openDirection - the direction the drawer will open
   * @param tab - JSX for the appearance of the tab
   * @param closedTab - JSX for the appearance of the tab when closed if
   * different
   * @param openIf - A function that will be checked at each game state. If it
   * returns true, the drawer will automatically open.
   * @param closeIf - A function that will be checked at each game state. If it
   * returns true, the drawer will automatically close.
   */
  layoutAsDrawer(applyTo, attributes) {
    const { area, ...container } = attributes;
    this.layout(applyTo, { area, __container__: { type: "drawer", attributes: container } });
  }
  /**
   * Creates a tabbed layout for a set of Space's within this Element. This is
   * like {@link GameElement#layout} except for a set of Spaces, with additional
   * parameters that set the behaviour/appearance of the tabs. Each Space will
   * be laid out into the same area, with a set of tabs attached to allow the
   * Player or the game rules to select which tab is shown.
   *
   * @param applyTo - The Spaces for the drawer as a set of key-value
   * pairs. Each value is a Space or a name of a Space.
   * @param area - The area for the tabs expressed in percentage sizes of this
   * element.
   * @param tabDirection - the side on which the tabs will be placed
   * @param tabs - JSX for the appearance of the tabs as a set of key-value pairs
   * @param setTabTo - A function that will be checked at each game state. If it
   * returns a string, the tab with the matching key will be shown.
   */
  layoutAsTabs(tabs, attributes) {
    const { area, ...container } = attributes;
    const id = (0, import_uuid_random.default)();
    for (const [key, tab] of Object.entries(tabs)) {
      this.layout(tab, { area, __container__: { type: "tabs", id, key, attributes: container } });
    }
  }
  /**
   * Hides a Space within this element and replaces it with popout
   * button. Clicking on the button opens this Space in a full-board modal. This
   * is like {@link GameElement#layout} except for one Space, with additional
   * parameters that set the behaviour/appearance of the popout modal.
   *
   * @param applyTo - The Space for the popout. Either a Space or the name of a
   * Space.
   * @param area - The area for the tabs expressed in percentage sizes of this
   * element.
   * @param button - JSX for the appearance of the popout button
   * @param popoutMargin - Alter the default margin around the opened
   * popout. Takes a percentage or an object with percentages for top, bottom,
   * left and right.
   */
  layoutAsPopout(applyTo, attributes) {
    const { area, ...container } = attributes;
    this.layout(applyTo, { area, __container__: { type: "popout", attributes: container } });
  }
  /**
   * Change the layout attributes for this space's layout.
   * @category UI
   */
  configureLayout(layoutConfiguration) {
    this._ui.layouts[0] = {
      applyTo: _GameElement,
      attributes: {
        ...this._ui.getBaseLayout(),
        ...layoutConfiguration
      }
    };
  }
  /**
   * Define the appearance of this element. Any values provided override
   * previous ones. See also {@link ElementCollection#appearance}
   * @category UI
   *
   * @param appearance - Possible values are:
   * @param appearance.className - A class name to add to the dom element
   *
   * @param appearance.render - A function that takes this element as its only
   * argument and returns JSX for the element. See {@link ../ui/appearance} for
   * more on usage.
   *
   * @param appearance.aspectRatio - The aspect ratio for this element. This
   * value is a ratio of width over height. All layouts defined in {@link
   * layout} will respect this aspect ratio.
   *
   * @param appearance.info - Return JSX for more info on this element. If
   * returning true, an info modal will be available for this element but with
   * only the rendered element and no text
   *
   * @param appearance.connections - If the elements immediately within this
   * element are connected using {@link Space#connectTo}, this makes those
   * connections visible as connecting lines. Providing a `label` will place a
   * label over top of this line by calling the provided function with the
   * distance of the connection specified in {@link Space#connectTo} and using
   * the retured JSX. If `labelScale` is provided, the label is scaled by this
   * amount.
   *
   * @param appearance.effects - Provides a CSS class that will be applied to
   * this element if its attributes change to match the provided ones.
   */
  appearance(appearance) {
    Object.assign(this._ui.appearance, appearance);
  }
  childRefsIfObscured() {
    if (this._t.order !== "stacking")
      return;
    const refs = [];
    for (const child of this._t.children) {
      if (this._ctx.trackMovement)
        child._t.wasRef ??= child._t.ref;
      refs.push(child._t.ref);
    }
    return refs;
  }
  assignChildRefs(refs) {
    for (let i = 0; i != refs.length; i++) {
      this._t.children[i]._t.ref = refs[i];
    }
  }
  hasMoved() {
    return this._t.moved || !!this._t.parent?.hasMoved();
  }
  resetMovementTracking() {
    this._t.moved = false;
    for (const child of this._t.children)
      child.resetMovementTracking();
  }
  resetRefTracking() {
    delete this._t.wasRef;
    for (const child of this._t.children)
      child.resetRefTracking();
  }
};

// src/board/space.ts
var Space = class extends GameElement {
  constructor() {
    super(...arguments);
    this._eventHandlers = { enter: [], exit: [] };
  }
  static {
    this.unserializableAttributes = [...GameElement.unserializableAttributes, "_eventHandlers", "_visOnEnter", "_screen"];
  }
  /**
   * Show pieces to all players when they enter this space
   * @category Visibility
   */
  contentsWillBeShown() {
    this._visOnEnter = { default: true };
  }
  /**
   * Show pieces when they enter this space to its owner
   * @category Visibility
   */
  contentsWillBeShownToOwner() {
    this._visOnEnter = { default: false, except: "owner" };
  }
  /**
   * Show piece to these players when they enter this space
   * @category Visibility
   */
  contentsWillBeShownTo(...players) {
    this._visOnEnter = { default: false, except: players.map((p) => p.position) };
  }
  /**
   * Hide pieces to all players when they enter this space
   * @category Visibility
   */
  contentsWillBeHidden() {
    this._visOnEnter = { default: false };
  }
  /**
   * Hide piece to these players when they enter this space
   * @category Visibility
   */
  contentsWillBeHiddenFrom(...players) {
    this._visOnEnter = { default: true, except: players.map((p) => p.position) };
  }
  /**
   * Call this to screen view completely from players. Blocked spaces completely
   * hide their contents, like a physical screen. No information about the
   * number, type or movement of contents inside this Space will be revealed to
   * the specified players
   *
   * @param players = Players for whom the view is blocked
   * @category Visibility
   */
  blockViewFor(players) {
    this._screen = players === "none" ? void 0 : players instanceof Array ? players.map((p) => p.position) : players;
  }
  isSpace() {
    return true;
  }
  create(className, name, attributes) {
    const el = super.create(className, name, attributes);
    if ("showTo" in el)
      this.triggerEvent("enter", el);
    return el;
  }
  addEventHandler(type, handler) {
    if (this._ctx.gameManager?.phase === "started")
      throw Error("Event handlers cannot be added once game has started.");
    this._eventHandlers[type].push(handler);
  }
  /**
   * Attach a callback to this space for every element that enters or is created
   * within.
   * @category Structure
   *
   * @param type - the class of element that will trigger this callback
   * @param callback - Callback will be called each time an element enters, with
   * the entering element as the only argument.
   *
   * @example
   * deck.onEnter(Card, card => card.hideFromAll()) // card placed in the deck are automatically turned face down
   */
  onEnter(type, callback) {
    this.addEventHandler("enter", { callback, type });
  }
  /**
   * Attach a callback to this space for every element that is moved out of this
   * space.
   * @category Structure
   *
   * @param type - the class of element that will trigger this callback
   * @param callback - Callback will be called each time an element exits, with
   * the exiting element as the only argument.
   *
   * @example
   * deck.onExit(Card, card => card.showToAll()) // cards drawn from the deck are automatically turned face up
   */
  onExit(type, callback) {
    this.addEventHandler("exit", { callback, type });
  }
  triggerEvent(event, element) {
    if (this._visOnEnter) {
      element._visible = {
        default: this._visOnEnter.default,
        except: this._visOnEnter.except === "owner" ? this.owner ? [this.owner.position] : void 0 : this._visOnEnter.except
      };
    }
    for (const handler of this._eventHandlers[event]) {
      if (event === "enter" && !(element instanceof handler.type))
        continue;
      if (event === "exit" && !(element instanceof handler.type))
        continue;
      handler.callback(element);
    }
  }
};

// src/board/piece.ts
var Piece = class _Piece extends GameElement {
  createElement(className, name, attrs) {
    if (className === Space || Object.prototype.isPrototypeOf.call(Space, className)) {
      throw Error(`May not create Space "${name}" in Piece "${this.name}"`);
    }
    return super.createElement(className, name, attrs);
  }
  /**
   * Show this piece to all players
   * @category Visibility
   */
  showToAll() {
    delete this._visible;
  }
  /**
   * Show this piece only to the given player
   * @category Visibility
   */
  showOnlyTo(player) {
    if (typeof player !== "number")
      player = player.position;
    this._visible = {
      default: false,
      except: [player]
    };
  }
  /**
   * Show this piece to the given players without changing it's visibility to
   * any other players.
   * @category Visibility
   */
  showTo(...player) {
    if (typeof player[0] !== "number")
      player = player.map((p) => p.position);
    if (this._visible === void 0)
      return;
    if (this._visible.default) {
      if (!this._visible.except)
        return;
      this._visible.except = this._visible.except.filter((i) => !player.includes(i));
    } else {
      this._visible.except = Array.from(/* @__PURE__ */ new Set([...this._visible.except instanceof Array ? this._visible.except : [], ...player]));
    }
  }
  /**
   * Hide this piece from all players
   * @category Visibility
   */
  hideFromAll() {
    this._visible = { default: false };
  }
  /**
   * Hide this piece from the given players without changing it's visibility to
   * any other players.
   * @category Visibility
   */
  hideFrom(...player) {
    if (typeof player[0] !== "number")
      player = player.map((p) => p.position);
    if (this._visible?.default === false && !this._visible.except)
      return;
    if (this._visible === void 0 || this._visible.default === true) {
      this._visible = {
        default: true,
        except: Array.from(/* @__PURE__ */ new Set([...this._visible?.except instanceof Array ? this._visible.except : [], ...player]))
      };
    } else {
      if (!this._visible.except)
        return;
      this._visible.except = this._visible.except.filter((i) => !player.includes(i));
    }
  }
  /**
   * Returns whether this piece is visible to the given player
   * @category Visibility
   */
  isVisibleTo(player) {
    if (typeof player !== "number")
      player = player.position;
    if (this._visible === void 0)
      return true;
    if (this._visible.default) {
      return !this._visible.except || !this._visible.except.includes(player);
    } else {
      return this._visible.except?.includes(player) || false;
    }
  }
  /**
   * Returns whether this piece is visible to all players, or to the current
   * player if called when in a player context (during an action taken by a
   * player or while the game is viewed by a given player.)
   * @category Visibility
   */
  isVisible() {
    if (this._ctx.player)
      return this.isVisibleTo(this._ctx.player.position);
    return this._visible?.default !== false && (this._visible?.except ?? []).length === 0;
  }
  /**
   * Provide list of attributes that remain visible even when these pieces are
   * not visible to players. E.g. In a game with multiple card decks with
   * different backs, identified by Card#deck, the identity of the card when
   * face-down is hidden, but the deck it belongs to is not, since the card art
   * on the back would identify the deck. In this case calling
   * `Card.revealWhenHidden('deck')` will cause all attributes other than 'deck'
   * to be hidden when the card is face down, while still revealing which deck
   * it is.
   * @category Visibility
   */
  static revealWhenHidden(...attrs) {
    this.visibleAttributes = attrs;
  }
  /**
   * Move this piece into another element. This triggers any {@link
   * Space#onEnter | onEnter} callbacks in the destination.
   * @category Structure
   *
   * @param to - Destination element
   * @param options.position - Place the piece into a specific numbered position
   * relative to the other elements in this space. Positive numbers count from
   * the beginning. Negative numbers count from the end.
   * @param options.fromTop - Place the piece into a specific numbered position counting
   * from the first element
   * @param options.fromBottom - Place the piece into a specific numbered position
   * counting from the last element
   */
  putInto(to, options) {
    if (to.isDescendantOf(this))
      throw Error(`Cannot put ${this} into itself`);
    let pos = to._t.order === "stacking" ? 0 : to._t.children.length;
    if (options?.position !== void 0)
      pos = options.position >= 0 ? options.position : to._t.children.length + options.position + 1;
    if (options?.fromTop !== void 0)
      pos = options.fromTop;
    if (options?.fromBottom !== void 0)
      pos = to._t.children.length - options.fromBottom;
    const previousParent = this._t.parent;
    const position = this.position();
    if (this.hasMoved() || to.hasMoved())
      this.game.addDelay();
    const refs = previousParent === to && options?.row === void 0 && options?.column === void 0 && to.childRefsIfObscured();
    this._t.parent._t.children.splice(position, 1);
    this._t.parent = to;
    to._t.children.splice(pos, 0, this);
    if (refs)
      to.assignChildRefs(refs);
    if (previousParent !== to && previousParent instanceof Space)
      previousParent.triggerEvent("exit", this);
    if (previousParent !== to && this._ctx.trackMovement)
      this._t.moved = true;
    delete this.column;
    delete this.row;
    if (options?.row !== void 0)
      this.row = options.row;
    if (options?.column !== void 0)
      this.column = options.column;
    if (previousParent !== to && to instanceof Space)
      to.triggerEvent("enter", this);
  }
  cloneInto(into) {
    let attrs = this.attributeList();
    delete attrs.column;
    delete attrs.row;
    const clone = into.createElement(this.constructor, this.name, attrs);
    if (into._t.order === "stacking") {
      into._t.children.unshift(clone);
    } else {
      into._t.children.push(clone);
    }
    clone._t.parent = into;
    clone._t.order = this._t.order;
    for (const child of this._t.children)
      if (child instanceof _Piece)
        child.cloneInto(clone);
    return clone;
  }
  /**
   * Remove this piece from the playing area and place it into {@link
   * Game#pile}
   * @category Structure
   */
  remove() {
    return this.putInto(this._ctx.removed);
  }
};

// src/components/d6/d6.ts
var D6 = class extends Piece {
  constructor() {
    super(...arguments);
    this.sides = 6;
    /**
     * Currently shown face
     * @category D6
     */
    this.current = 1;
    this.rollSequence = 0;
  }
  /**
   * Randomly choose a new face, causing the roll animation
   * @category D6
   */
  roll() {
    this.current = Math.ceil((this.game.random || Math.random)() * this.sides);
    this.rollSequence = this._ctx.gameManager.sequence;
  }
};

// src/components/d6/useD6.tsx
var import_react = __toESM(require_react(), 1);
import dice from "./dice.ogg";
var D6Component = ({ die }) => {
  const diceAudio = (0, import_react.useRef)(null);
  const lastRollSequence = (0, import_react.useRef)();
  const [flip, setFlip] = (0, import_react.useState)(false);
  (0, import_react.useEffect)(() => {
    if (die.rollSequence === Math.ceil(die._ctx.gameManager.sequence - 1) && lastRollSequence.current !== void 0 && lastRollSequence.current !== die.rollSequence) {
      diceAudio.current?.play();
      setFlip(!flip);
    }
    lastRollSequence.current = die.rollSequence;
  }, [die, die.rollSequence, flip, setFlip]);
  return /* @__PURE__ */ import_react.default.createElement(import_react.default.Fragment, null, /* @__PURE__ */ import_react.default.createElement("audio", { ref: diceAudio, src: dice, id: "dice" }), /* @__PURE__ */ import_react.default.createElement("ol", { "data-spin": flip ? "up" : "down" }, [1, 2, 3, 4, 5, 6].map((dots) => /* @__PURE__ */ import_react.default.createElement("li", { key: dots, className: "die-face", "data-face": dots }, times(dots, (d) => /* @__PURE__ */ import_react.default.createElement("span", { key: d, className: "dot" }))))));
};
var useD6_default = (game) => {
  game.all(D6).appearance({
    render: (die) => /* @__PURE__ */ import_react.default.createElement(D6Component, { die }),
    aspectRatio: 1
  });
};
export {
  D6,
  useD6_default as useD6
};
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3V1aWQtcmFuZG9tL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL3NyYy9ib2FyZC9lbGVtZW50LWNvbGxlY3Rpb24udHMiLCAiLi4vLi4vLi4vLi4vc3JjL2FjdGlvbi91dGlscy50cyIsICIuLi8uLi8uLi8uLi9zcmMvdXRpbHMudHMiLCAiLi4vLi4vLi4vLi4vc3JjL2JvYXJkL2VsZW1lbnQudHMiLCAiLi4vLi4vLi4vLi4vc3JjL2JvYXJkL3NwYWNlLnRzIiwgIi4uLy4uLy4uLy4uL3NyYy9ib2FyZC9waWVjZS50cyIsICIuLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9kNi9kNi50cyIsICIuLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9kNi91c2VENi50c3giXSwKICAic291cmNlc0NvbnRlbnQiOiBbIlwidXNlIHN0cmljdFwiO1xuXG4oZnVuY3Rpb24oKXtcblxuICB2YXJcbiAgICBidWYsXG4gICAgYnVmSWR4ID0gMCxcbiAgICBoZXhCeXRlcyA9IFtdLFxuICAgIGlcbiAgO1xuXG4gIC8vIFByZS1jYWxjdWxhdGUgdG9TdHJpbmcoMTYpIGZvciBzcGVlZFxuICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICBoZXhCeXRlc1tpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG4gIH1cblxuICAvLyBCdWZmZXIgcmFuZG9tIG51bWJlcnMgZm9yIHNwZWVkXG4gIC8vIFJlZHVjZSBtZW1vcnkgdXNhZ2UgYnkgZGVjcmVhc2luZyB0aGlzIG51bWJlciAobWluIDE2KVxuICAvLyBvciBpbXByb3ZlIHNwZWVkIGJ5IGluY3JlYXNpbmcgdGhpcyBudW1iZXIgKHRyeSAxNjM4NClcbiAgdXVpZC5CVUZGRVJfU0laRSA9IDQwOTY7XG5cbiAgLy8gQmluYXJ5IHV1aWRzXG4gIHV1aWQuYmluID0gdXVpZEJpbjtcblxuICAvLyBDbGVhciBidWZmZXJcbiAgdXVpZC5jbGVhckJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIGJ1ZiA9IG51bGw7XG4gICAgYnVmSWR4ID0gMDtcbiAgfTtcblxuICAvLyBUZXN0IGZvciB1dWlkXG4gIHV1aWQudGVzdCA9IGZ1bmN0aW9uKHV1aWQpIHtcbiAgICBpZiAodHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gL15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS00WzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9JC9pLnRlc3QodXVpZCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBOb2RlICYgQnJvd3NlciBzdXBwb3J0XG4gIHZhciBjcnlwdDA7XG4gIGlmICh0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNyeXB0MCA9IGNyeXB0bztcbiAgfSBlbHNlIGlmKCAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2Ygd2luZG93Lm1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJykpIHtcbiAgICBjcnlwdDAgPSB3aW5kb3cubXNDcnlwdG87IC8vIElFMTFcbiAgfVxuXG4gIGlmICgodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBjcnlwdDAgPSBjcnlwdDAgfHwgcmVxdWlyZSgnY3J5cHRvJyk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB1dWlkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LnV1aWQgPSB1dWlkO1xuICB9XG5cbiAgLy8gVXNlIGJlc3QgYXZhaWxhYmxlIFBSTkdcbiAgLy8gQWxzbyBleHBvc2UgdGhpcyBzbyB5b3UgY2FuIG92ZXJyaWRlIGl0LlxuICB1dWlkLnJhbmRvbUJ5dGVzID0gKGZ1bmN0aW9uKCl7XG4gICAgaWYgKGNyeXB0MCkge1xuICAgICAgaWYgKGNyeXB0MC5yYW5kb21CeXRlcykge1xuICAgICAgICByZXR1cm4gY3J5cHQwLnJhbmRvbUJ5dGVzO1xuICAgICAgfVxuICAgICAgaWYgKGNyeXB0MC5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgICAgICAgIGNyeXB0MC5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oYnl0ZXMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgICAgICBjcnlwdDAuZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihuKSB7XG4gICAgICB2YXIgaSwgciA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICByLnB1c2goTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8vIEJ1ZmZlciBzb21lIHJhbmRvbSBieXRlcyBmb3Igc3BlZWRcbiAgZnVuY3Rpb24gcmFuZG9tQnl0ZXNCdWZmZXJlZChuKSB7XG4gICAgaWYgKCFidWYgfHwgKChidWZJZHggKyBuKSA+IHV1aWQuQlVGRkVSX1NJWkUpKSB7XG4gICAgICBidWZJZHggPSAwO1xuICAgICAgYnVmID0gdXVpZC5yYW5kb21CeXRlcyh1dWlkLkJVRkZFUl9TSVpFKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zi5zbGljZShidWZJZHgsIGJ1ZklkeCArPSBuKTtcbiAgfVxuXG4gIC8vIHV1aWQuYmluXG4gIGZ1bmN0aW9uIHV1aWRCaW4oKSB7XG4gICAgdmFyIGIgPSByYW5kb21CeXRlc0J1ZmZlcmVkKDE2KTtcbiAgICBiWzZdID0gKGJbNl0gJiAweDBmKSB8IDB4NDA7XG4gICAgYls4XSA9IChiWzhdICYgMHgzZikgfCAweDgwO1xuICAgIHJldHVybiBiO1xuICB9XG5cbiAgLy8gU3RyaW5nIFVVSUR2NCAoUmFuZG9tKVxuICBmdW5jdGlvbiB1dWlkKCkge1xuICAgIHZhciBiID0gdXVpZEJpbigpO1xuICAgIHJldHVybiBoZXhCeXRlc1tiWzBdXSArIGhleEJ5dGVzW2JbMV1dICtcbiAgICAgIGhleEJ5dGVzW2JbMl1dICsgaGV4Qnl0ZXNbYlszXV0gKyAnLScgK1xuICAgICAgaGV4Qnl0ZXNbYls0XV0gKyBoZXhCeXRlc1tiWzVdXSArICctJyArXG4gICAgICBoZXhCeXRlc1tiWzZdXSArIGhleEJ5dGVzW2JbN11dICsgJy0nICtcbiAgICAgIGhleEJ5dGVzW2JbOF1dICsgaGV4Qnl0ZXNbYls5XV0gKyAnLScgK1xuICAgICAgaGV4Qnl0ZXNbYlsxMF1dICsgaGV4Qnl0ZXNbYlsxMV1dICtcbiAgICAgIGhleEJ5dGVzW2JbMTJdXSArIGhleEJ5dGVzW2JbMTNdXSArXG4gICAgICBoZXhCeXRlc1tiWzE0XV0gKyBoZXhCeXRlc1tiWzE1XV1cbiAgICA7XG4gIH1cblxufSkoKTtcbiIsICIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBSZWFjdFZlcnNpb24gPSAnMTguMi4wJztcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBkaXNwYXRjaGVyLlxuICovXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGJhdGNoJ3MgY29uZmlndXJhdGlvbiBzdWNoIGFzIGhvdyBsb25nIGFuIHVwZGF0ZVxuICogc2hvdWxkIHN1c3BlbmQgZm9yIGlmIGl0IG5lZWRzIHRvLlxuICovXG52YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSB7XG4gIHRyYW5zaXRpb246IG51bGxcbn07XG5cbnZhciBSZWFjdEN1cnJlbnRBY3RRdWV1ZSA9IHtcbiAgY3VycmVudDogbnVsbCxcbiAgLy8gVXNlZCB0byByZXByb2R1Y2UgYmVoYXZpb3Igb2YgYGJhdGNoZWRVcGRhdGVzYCBpbiBsZWdhY3kgbW9kZS5cbiAgaXNCYXRjaGluZ0xlZ2FjeTogZmFsc2UsXG4gIGRpZFNjaGVkdWxlTGVnYWN5VXBkYXRlOiBmYWxzZVxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xudmFyIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBudWxsO1xuZnVuY3Rpb24gc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKSB7XG4gIHtcbiAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gIH1cbn1cblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZSA9IGZ1bmN0aW9uIChzdGFjaykge1xuICAgIHtcbiAgICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgICB9XG4gIH07IC8vIFN0YWNrIGltcGxlbWVudGF0aW9uIGluamVjdGVkIGJ5IHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuXG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJzsgLy8gQWRkIGFuIGV4dHJhIHRvcCBmcmFtZSB3aGlsZSBhbiBlbGVtZW50IGlzIGJlaW5nIHZhbGlkYXRlZFxuXG4gICAgaWYgKGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUpIHtcbiAgICAgIHN0YWNrICs9IGN1cnJlbnRFeHRyYVN0YWNrRnJhbWU7XG4gICAgfSAvLyBEZWxlZ2F0ZSB0byB0aGUgaW5qZWN0ZWQgcmVuZGVyZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cblxuXG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcblxuICAgIGlmIChpbXBsKSB7XG4gICAgICBzdGFjayArPSBpbXBsKCkgfHwgJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0ge1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsXG4gIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lclxufTtcblxue1xuICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QWN0UXVldWUgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZTtcbn1cblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIChfY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgX2NvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyBcIi5cIiArIGNhbGxlck5hbWU7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXJyb3IoXCJDYW4ndCBjYWxsICVzIG9uIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHlldCBtb3VudGVkLiBcIiArICdUaGlzIGlzIGEgbm8tb3AsIGJ1dCBpdCBtaWdodCBpbmRpY2F0ZSBhIGJ1ZyBpbiB5b3VyIGFwcGxpY2F0aW9uLiAnICsgJ0luc3RlYWQsIGFzc2lnbiB0byBgdGhpcy5zdGF0ZWAgZGlyZWN0bHkgb3IgZGVmaW5lIGEgYHN0YXRlID0ge307YCAnICsgJ2NsYXNzIHByb3BlcnR5IHdpdGggdGhlIGRlc2lyZWQgc3RhdGUgaW4gdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cblxuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0OyAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cblxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHBhcnRpYWxTdGF0ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHBhcnRpYWxTdGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiBwYXJ0aWFsU3RhdGUgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSAnICsgJ2Z1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKTtcbiAgfVxuXG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5cblxue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG5cbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4vKipcbiAqIENvbnZlbmllbmNlIGNvbXBvbmVudCB3aXRoIGRlZmF1bHQgc2hhbGxvdyBlcXVhbGl0eSBjaGVjayBmb3Igc0NVLlxuICovXG5cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7IC8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuXG5hc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuLy8gYW4gaW1tdXRhYmxlIG9iamVjdCB3aXRoIGEgc2luZ2xlIG11dGFibGUgdmFsdWVcbmZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcbiAgdmFyIHJlZk9iamVjdCA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG5cbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cblxuICByZXR1cm4gcmVmT2JqZWN0O1xufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JztcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24sIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZykge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIGNvbmZpZy5fX3NlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IGNvbmZpZy5fX3NlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBjb21wb25lbnROYW1lLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuXG4gICAgICB7XG4gICAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlOyAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgKyBlbGVtZW50ICsgXCIuXCIpO1xuICB9XG5cbiAgdmFyIHByb3BOYW1lOyAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG5cbiAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmOyAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjsgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTsgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcblxuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcblxuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9IGtleS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGVsZW1lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gZWxlbWVudCBBIGVsZW1lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRLZXkoZWxlbWVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudCAhPT0gbnVsbCAmJiBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAge1xuICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihlbGVtZW50LmtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVzY2FwZSgnJyArIGVsZW1lbnQua2V5KTtcbiAgfSAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuXG5cbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gbWFwSW50b0FycmF5KGNoaWxkcmVuLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmFtZVNvRmFyLCBjYWxsYmFjaykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICB2YXIgX2NoaWxkID0gY2hpbGRyZW47XG4gICAgdmFyIG1hcHBlZENoaWxkID0gY2FsbGJhY2soX2NoaWxkKTsgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzOlxuXG4gICAgdmFyIGNoaWxkS2V5ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldEVsZW1lbnRLZXkoX2NoaWxkLCAwKSA6IG5hbWVTb0ZhcjtcblxuICAgIGlmIChpc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgICAgdmFyIGVzY2FwZWRDaGlsZEtleSA9ICcnO1xuXG4gICAgICBpZiAoY2hpbGRLZXkgIT0gbnVsbCkge1xuICAgICAgICBlc2NhcGVkQ2hpbGRLZXkgPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoY2hpbGRLZXkpICsgJy8nO1xuICAgICAgfVxuXG4gICAgICBtYXBJbnRvQXJyYXkobWFwcGVkQ2hpbGQsIGFycmF5LCBlc2NhcGVkQ2hpbGRLZXksICcnLCBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgICB7XG4gICAgICAgICAgLy8gVGhlIGBpZmAgc3RhdGVtZW50IGhlcmUgcHJldmVudHMgYXV0by1kaXNhYmxpbmcgb2YgdGhlIHNhZmVcbiAgICAgICAgICAvLyBjb2VyY2lvbiBFU0xpbnQgcnVsZSwgc28gd2UgbXVzdCBtYW51YWxseSBkaXNhYmxlIGl0IGJlbG93LlxuICAgICAgICAgIC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgUmVhY3QuUG9ydGFsIGRvZXNuJ3QgaGF2ZSBhIGtleVxuICAgICAgICAgIGlmIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFfY2hpbGQgfHwgX2NoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSkge1xuICAgICAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXBwZWRDaGlsZC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1hcHBlZENoaWxkID0gY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLCAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgICAgZXNjYXBlZFByZWZpeCArICggLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgIG1hcHBlZENoaWxkLmtleSAmJiAoIV9jaGlsZCB8fCBfY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBleGlzdGluZyBlbGVtZW50J3Mga2V5IGNhbiBiZSBhIG51bWJlclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICAgICAgZXNjYXBlVXNlclByb3ZpZGVkS2V5KCcnICsgbWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICAgIH1cblxuICAgICAgYXJyYXkucHVzaChtYXBwZWRDaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBpdGVyYWJsZUNoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBpdGVyYWJsZUNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1hcHMpIHtcbiAgICAgICAgICAgIHdhcm4oJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gJyArICdVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChpdGVyYWJsZUNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcblxuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcpICsgXCIpLiBcIiArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGNvdW50ID0gMDtcbiAgbWFwSW50b0FycmF5KGNoaWxkcmVuLCByZXN1bHQsICcnLCAnJywgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgY291bnQrKyk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIG4gPSAwO1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIG4rKzsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nXG4gIH0pO1xuICByZXR1cm4gbjtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIGZvckVhY2hGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIERvbid0IHJldHVybiBhbnl0aGluZy5cbiAgfSwgZm9yRWFjaENvbnRleHQpO1xufVxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW50b2FycmF5XG4gKi9cblxuXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHJldHVybiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9KSB8fCBbXTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cblxuXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSkge1xuICAvLyBUT0RPOiBTZWNvbmQgYXJndW1lbnQgdXNlZCB0byBiZSBhbiBvcHRpb25hbCBgY2FsY3VsYXRlQ2hhbmdlZEJpdHNgXG4gIC8vIGZ1bmN0aW9uLiBXYXJuIHRvIHJlc2VydmUgZm9yIGZ1dHVyZSB1c2U/XG4gIHZhciBjb250ZXh0ID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgLy8gQXMgYSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgbXVsdGlwbGUgY29uY3VycmVudCByZW5kZXJlcnMsIHdlIGNhdGVnb3JpemVcbiAgICAvLyBzb21lIHJlbmRlcmVycyBhcyBwcmltYXJ5IGFuZCBvdGhlcnMgYXMgc2Vjb25kYXJ5LiBXZSBvbmx5IGV4cGVjdFxuICAgIC8vIHRoZXJlIHRvIGJlIHR3byBjb25jdXJyZW50IHJlbmRlcmVycyBhdCBtb3N0OiBSZWFjdCBOYXRpdmUgKHByaW1hcnkpIGFuZFxuICAgIC8vIEZhYnJpYyAoc2Vjb25kYXJ5KTsgUmVhY3QgRE9NIChwcmltYXJ5KSBhbmQgUmVhY3QgQVJUIChzZWNvbmRhcnkpLlxuICAgIC8vIFNlY29uZGFyeSByZW5kZXJlcnMgc3RvcmUgdGhlaXIgY29udGV4dCB2YWx1ZXMgb24gc2VwYXJhdGUgZmllbGRzLlxuICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgIC8vIFVzZWQgdG8gdHJhY2sgaG93IG1hbnkgY29uY3VycmVudCByZW5kZXJlcnMgdGhpcyBjb250ZXh0IGN1cnJlbnRseVxuICAgIC8vIHN1cHBvcnRzIHdpdGhpbiBpbiBhIHNpbmdsZSByZW5kZXJlci4gU3VjaCBhcyBwYXJhbGxlbCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbCxcbiAgICAvLyBBZGQgdGhlc2UgdG8gdXNlIHNhbWUgaGlkZGVuIGNsYXNzIGluIFZNIGFzIFNlcnZlckNvbnRleHRcbiAgICBfZGVmYXVsdFZhbHVlOiBudWxsLFxuICAgIF9nbG9iYWxOYW1lOiBudWxsXG4gIH07XG4gIGNvbnRleHQuUHJvdmlkZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BST1ZJREVSX1RZUEUsXG4gICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSBmYWxzZTtcblxuICB7XG4gICAgLy8gQSBzZXBhcmF0ZSBvYmplY3QsIGJ1dCBwcm94aWVzIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGNvbnRleHQgb2JqZWN0IGZvclxuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBJdCBoYXMgYSBkaWZmZXJlbnQgJCR0eXBlb2YsIHNvIHdlIGNhbiBwcm9wZXJseVxuICAgIC8vIHdhcm4gZm9yIHRoZSBpbmNvcnJlY3QgdXNhZ2Ugb2YgQ29udGV4dCBhcyBhIENvbnN1bWVyLlxuICAgIHZhciBDb25zdW1lciA9IHtcbiAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICBfY29udGV4dDogY29udGV4dFxuICAgIH07IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG5vdCBzZXR0aW5nIGEgdmFsdWUsIHdoaWNoIGlzIGludGVudGlvbmFsIGhlcmVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbnN1bWVyLCB7XG4gICAgICBQcm92aWRlcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuUHJvdmlkZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuUHJvdmlkZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuUHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9Qcm92aWRlcikge1xuICAgICAgICAgIGNvbnRleHQuUHJvdmlkZXIgPSBfUHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBfY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZTI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUyKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IF9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3RocmVhZENvdW50OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll90aHJlYWRDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX3RocmVhZENvdW50KSB7XG4gICAgICAgICAgY29udGV4dC5fdGhyZWFkQ291bnQgPSBfdGhyZWFkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDb25zdW1lcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuQ29uc3VtZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuQ29uc3VtZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkaXNwbGF5TmFtZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXNwbGF5TmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyKSB7XG4gICAgICAgICAgICB3YXJuKCdTZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gQ29udGV4dC5Db25zdW1lciBoYXMgbm8gZWZmZWN0LiAnICsgXCJZb3Ugc2hvdWxkIHNldCBpdCBkaXJlY3RseSBvbiB0aGUgY29udGV4dCB3aXRoIENvbnRleHQuZGlzcGxheU5hbWUgPSAnJXMnLlwiLCBkaXNwbGF5TmFtZSk7XG5cbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbWlzc2luZyBwcm9wZXJ0aWVzIGJlY2F1c2UgaXQgZG9lc24ndCB1bmRlcnN0YW5kIGRlZmluZVByb3BlcnR5XG5cbiAgICBjb250ZXh0LkNvbnN1bWVyID0gQ29uc3VtZXI7XG4gIH1cblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG52YXIgVW5pbml0aWFsaXplZCA9IC0xO1xudmFyIFBlbmRpbmcgPSAwO1xudmFyIFJlc29sdmVkID0gMTtcbnZhciBSZWplY3RlZCA9IDI7XG5cbmZ1bmN0aW9uIGxhenlJbml0aWFsaXplcihwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICB2YXIgY3RvciA9IHBheWxvYWQuX3Jlc3VsdDtcbiAgICB2YXIgdGhlbmFibGUgPSBjdG9yKCk7IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgLy8gVGhpcyBtaWdodCB0aHJvdyBlaXRoZXIgYmVjYXVzZSBpdCdzIG1pc3Npbmcgb3IgdGhyb3dzLiBJZiBzbywgd2UgdHJlYXQgaXRcbiAgICAvLyBhcyBzdGlsbCB1bmluaXRpYWxpemVkIGFuZCB0cnkgYWdhaW4gbmV4dCB0aW1lLiBXaGljaCBpcyB0aGUgc2FtZSBhcyB3aGF0XG4gICAgLy8gaGFwcGVucyBpZiB0aGUgY3RvciBvciBhbnkgd3JhcHBlcnMgcHJvY2Vzc2luZyB0aGUgY3RvciB0aHJvd3MuIFRoaXMgbWlnaHRcbiAgICAvLyBlbmQgdXAgZml4aW5nIGl0IGlmIHRoZSByZXNvbHV0aW9uIHdhcyBhIGNvbmN1cnJlbmN5IGJ1Zy5cblxuICAgIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKG1vZHVsZU9iamVjdCkge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZyB8fCBwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgICAgdmFyIHJlc29sdmVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVzb2x2ZWQuX3N0YXR1cyA9IFJlc29sdmVkO1xuICAgICAgICByZXNvbHZlZC5fcmVzdWx0ID0gbW9kdWxlT2JqZWN0O1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZyB8fCBwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgICAgdmFyIHJlamVjdGVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVqZWN0ZWQuX3N0YXR1cyA9IFJlamVjdGVkO1xuICAgICAgICByZWplY3RlZC5fcmVzdWx0ID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgICAvLyBJbiBjYXNlLCB3ZSdyZSBzdGlsbCB1bmluaXRpYWxpemVkLCB0aGVuIHdlJ3JlIHdhaXRpbmcgZm9yIHRoZSB0aGVuYWJsZVxuICAgICAgLy8gdG8gcmVzb2x2ZS4gU2V0IGl0IGFzIHBlbmRpbmcgaW4gdGhlIG1lYW50aW1lLlxuICAgICAgdmFyIHBlbmRpbmcgPSBwYXlsb2FkO1xuICAgICAgcGVuZGluZy5fc3RhdHVzID0gUGVuZGluZztcbiAgICAgIHBlbmRpbmcuX3Jlc3VsdCA9IHRoZW5hYmxlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFJlc29sdmVkKSB7XG4gICAgdmFyIG1vZHVsZU9iamVjdCA9IHBheWxvYWQuX3Jlc3VsdDtcblxuICAgIHtcbiAgICAgIGlmIChtb2R1bGVPYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcnJvcignbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wJyArICdvcnQoKSBjYWxsLiAnICsgJ0luc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgJyArIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICdjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wJyArIFwib3J0KCcuL015Q29tcG9uZW50JykpXFxuXFxuXCIgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcHV0IGN1cmx5IGJyYWNlcyBhcm91bmQgdGhlIGltcG9ydD8nLCBtb2R1bGVPYmplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICghKCdkZWZhdWx0JyBpbiBtb2R1bGVPYmplY3QpKSB7XG4gICAgICAgIGVycm9yKCdsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXAnICsgJ29ydCgpIGNhbGwuICcgKyAnSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICAnICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgJ2NvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXAnICsgXCJvcnQoJy4vTXlDb21wb25lbnQnKSlcIiwgbW9kdWxlT2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbW9kdWxlT2JqZWN0LmRlZmF1bHQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgcGF5bG9hZC5fcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGxhenkoY3Rvcikge1xuICB2YXIgcGF5bG9hZCA9IHtcbiAgICAvLyBXZSB1c2UgdGhlc2UgZmllbGRzIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgX3N0YXR1czogVW5pbml0aWFsaXplZCxcbiAgICBfcmVzdWx0OiBjdG9yXG4gIH07XG4gIHZhciBsYXp5VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgIF9wYXlsb2FkOiBwYXlsb2FkLFxuICAgIF9pbml0OiBsYXp5SW5pdGlhbGl6ZXJcbiAgfTtcblxuICB7XG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCBqdXN0IHNldCBpdCBvbiB0aGUgb2JqZWN0LlxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgdmFyIHByb3BUeXBlczsgLy8gJEZsb3dGaXhNZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobGF6eVR5cGUsIHtcbiAgICAgIGRlZmF1bHRQcm9wczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0UHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0RlZmF1bHRQcm9wcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBkZWZhdWx0UHJvcHNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBkZWZhdWx0UHJvcHMgPSBuZXdEZWZhdWx0UHJvcHM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ2RlZmF1bHRQcm9wcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3BUeXBlczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wVHlwZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1Byb3BUeXBlcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBwcm9wVHlwZXNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBwcm9wVHlwZXMgPSBuZXdQcm9wVHlwZXM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ3Byb3BUeXBlcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGxhenlUeXBlO1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICB7XG4gICAgaWYgKHJlbmRlciAhPSBudWxsICYmIHJlbmRlci4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgJyArICdjb21wb25lbnQuIEluc3RlYWQgb2YgZm9yd2FyZFJlZihtZW1vKC4uLikpLCB1c2UgJyArICdtZW1vKGZvcndhcmRSZWYoLi4uKSkuJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVuZGVyLmxlbmd0aCAhPT0gMCAmJiByZW5kZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgYWNjZXB0IGV4YWN0bHkgdHdvIHBhcmFtZXRlcnM6IHByb3BzIGFuZCByZWYuICVzJywgcmVuZGVyLmxlbmd0aCA9PT0gMSA/ICdEaWQgeW91IGZvcmdldCB0byB1c2UgdGhlIHJlZiBwYXJhbWV0ZXI/JyA6ICdBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICBpZiAocmVuZGVyLmRlZmF1bHRQcm9wcyAhPSBudWxsIHx8IHJlbmRlci5wcm9wVHlwZXMgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGRvIG5vdCBzdXBwb3J0IHByb3BUeXBlcyBvciBkZWZhdWx0UHJvcHMuICcgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIFJlYWN0IGNvbXBvbmVudD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gICAgcmVuZGVyOiByZW5kZXJcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lOyAvLyBUaGUgaW5uZXIgY29tcG9uZW50IHNob3VsZG4ndCBpbmhlcml0IHRoaXMgZGlzcGxheSBuYW1lIGluIG1vc3QgY2FzZXMsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGNvbXBvbmVudCBtYXkgYmUgdXNlZCBlbHNld2hlcmUuXG4gICAgICAgIC8vIEJ1dCBpdCdzIG5pY2UgZm9yIGFub255bW91cyBmdW5jdGlvbnMgdG8gaW5oZXJpdCB0aGUgbmFtZSxcbiAgICAgICAgLy8gc28gdGhhdCBvdXIgY29tcG9uZW50LXN0YWNrIGdlbmVyYXRpb24gbG9naWMgd2lsbCBkaXNwbGF5IHRoZWlyIGZyYW1lcy5cbiAgICAgICAgLy8gQW4gYW5vbnltb3VzIGZ1bmN0aW9uIGdlbmVyYWxseSBzdWdnZXN0cyBhIHBhdHRlcm4gbGlrZTpcbiAgICAgICAgLy8gICBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7Li4ufSk7XG4gICAgICAgIC8vIFRoaXMga2luZCBvZiBpbm5lciBmdW5jdGlvbiBpcyBub3QgdXNlZCBlbHNld2hlcmUgc28gdGhlIHNpZGUgZWZmZWN0IGlzIG9rYXkuXG5cbiAgICAgICAgaWYgKCFyZW5kZXIubmFtZSAmJiAhcmVuZGVyLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgcmVuZGVyLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG52YXIgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRTtcblxue1xuICBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QubW9kdWxlLnJlZmVyZW5jZScpO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtZW1vKHR5cGUsIGNvbXBhcmUpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICBlcnJvcignbWVtbzogVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjb21wb25lbnQuIEluc3RlYWQgJyArICdyZWNlaXZlZDogJXMnLCB0eXBlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29tcGFyZTogY29tcGFyZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbXBhcmVcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lOyAvLyBUaGUgaW5uZXIgY29tcG9uZW50IHNob3VsZG4ndCBpbmhlcml0IHRoaXMgZGlzcGxheSBuYW1lIGluIG1vc3QgY2FzZXMsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGNvbXBvbmVudCBtYXkgYmUgdXNlZCBlbHNld2hlcmUuXG4gICAgICAgIC8vIEJ1dCBpdCdzIG5pY2UgZm9yIGFub255bW91cyBmdW5jdGlvbnMgdG8gaW5oZXJpdCB0aGUgbmFtZSxcbiAgICAgICAgLy8gc28gdGhhdCBvdXIgY29tcG9uZW50LXN0YWNrIGdlbmVyYXRpb24gbG9naWMgd2lsbCBkaXNwbGF5IHRoZWlyIGZyYW1lcy5cbiAgICAgICAgLy8gQW4gYW5vbnltb3VzIGZ1bmN0aW9uIGdlbmVyYWxseSBzdWdnZXN0cyBhIHBhdHRlcm4gbGlrZTpcbiAgICAgICAgLy8gICBSZWFjdC5tZW1vKChwcm9wcykgPT4gey4uLn0pO1xuICAgICAgICAvLyBUaGlzIGtpbmQgb2YgaW5uZXIgZnVuY3Rpb24gaXMgbm90IHVzZWQgZWxzZXdoZXJlIHNvIHRoZSBzaWRlIGVmZmVjdCBpcyBva2F5LlxuXG4gICAgICAgIGlmICghdHlwZS5uYW1lICYmICF0eXBlLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZURpc3BhdGNoZXIoKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuXG4gIHtcbiAgICBpZiAoZGlzcGF0Y2hlciA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3InICsgJyBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbicgKyAnMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuJyArICcyLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuJyArICczLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS4nKTtcbiAgICB9XG4gIH0gLy8gV2lsbCByZXN1bHQgaW4gYSBudWxsIGFjY2VzcyBlcnJvciBpZiBhY2Nlc3NlZCBvdXRzaWRlIHJlbmRlciBwaGFzZS4gV2VcbiAgLy8gaW50ZW50aW9uYWxseSBkb24ndCB0aHJvdyBvdXIgb3duIGVycm9yIGJlY2F1c2UgdGhpcyBpcyBpbiBhIGhvdCBwYXRoLlxuICAvLyBBbHNvIGhlbHBzIGVuc3VyZSB0aGlzIGlzIGlubGluZWQuXG5cblxuICByZXR1cm4gZGlzcGF0Y2hlcjtcbn1cbmZ1bmN0aW9uIHVzZUNvbnRleHQoQ29udGV4dCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cbiAge1xuICAgIC8vIFRPRE86IGFkZCBhIG1vcmUgZ2VuZXJpYyB3YXJuaW5nIGZvciBpbnZhbGlkIHZhbHVlcy5cbiAgICBpZiAoQ29udGV4dC5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmVhbENvbnRleHQgPSBDb250ZXh0Ll9jb250ZXh0OyAvLyBEb24ndCBkZWR1cGxpY2F0ZSBiZWNhdXNlIHRoaXMgbGVnaXRpbWF0ZWx5IGNhdXNlcyBidWdzXG4gICAgICAvLyBhbmQgbm9ib2R5IHNob3VsZCBiZSB1c2luZyB0aGlzIGluIGV4aXN0aW5nIGNvZGUuXG5cbiAgICAgIGlmIChyZWFsQ29udGV4dC5Db25zdW1lciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuQ29uc3VtZXIpIGlzIG5vdCBzdXBwb3J0ZWQsIG1heSBjYXVzZSBidWdzLCBhbmQgd2lsbCBiZSAnICsgJ3JlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfSBlbHNlIGlmIChyZWFsQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuUHJvdmlkZXIpIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNvbnRleHQoQ29udGV4dCk7XG59XG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbn1cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWYoaW5pdGlhbFZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVzZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTWVtbyhjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VNZW1vKGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgfVxufVxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbigpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VUcmFuc2l0aW9uKCk7XG59XG5mdW5jdGlvbiB1c2VEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB1c2VJZCgpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJZCgpO1xufVxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICggIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcy5fX3NvdXJjZSk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmZvO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gIH1cblxuICB7XG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcblxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhwcm9wcyk7XG5cbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSkge1xuICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSB0cnVlO1xuXG4gICAgICB3YXJuKCdSZWFjdC5jcmVhdGVGYWN0b3J5KCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gQ29uc2lkZXIgdXNpbmcgSlNYICcgKyAnb3IgdXNlIFJlYWN0LmNyZWF0ZUVsZW1lbnQoKSBkaXJlY3RseSBpbnN0ZWFkLicpO1xuICAgIH0gLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cblxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihzY29wZSwgb3B0aW9ucykge1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uO1xuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uID0ge307XG4gIHZhciBjdXJyZW50VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb247XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHNjb3BlKCk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuXG4gICAge1xuICAgICAgaWYgKHByZXZUcmFuc2l0aW9uID09PSBudWxsICYmIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzKSB7XG4gICAgICAgIHZhciB1cGRhdGVkRmliZXJzQ291bnQgPSBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5zaXplO1xuXG4gICAgICAgIGlmICh1cGRhdGVkRmliZXJzQ291bnQgPiAxMCkge1xuICAgICAgICAgIHdhcm4oJ0RldGVjdGVkIGEgbGFyZ2UgbnVtYmVyIG9mIHVwZGF0ZXMgaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbi4gJyArICdJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiAnICsgJ090aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9IGZhbHNlO1xudmFyIGVucXVldWVUYXNrSW1wbCA9IG51bGw7XG5mdW5jdGlvbiBlbnF1ZXVlVGFzayh0YXNrKSB7XG4gIGlmIChlbnF1ZXVlVGFza0ltcGwgPT09IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgLy8gcmVhZCByZXF1aXJlIG9mZiB0aGUgbW9kdWxlIG9iamVjdCB0byBnZXQgYXJvdW5kIHRoZSBidW5kbGVycy5cbiAgICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlbSB0byBkZXRlY3QgYSByZXF1aXJlIGFuZCBidW5kbGUgYSBOb2RlIHBvbHlmaWxsLlxuICAgICAgdmFyIHJlcXVpcmVTdHJpbmcgPSAoJ3JlcXVpcmUnICsgTWF0aC5yYW5kb20oKSkuc2xpY2UoMCwgNyk7XG4gICAgICB2YXIgbm9kZVJlcXVpcmUgPSBtb2R1bGUgJiYgbW9kdWxlW3JlcXVpcmVTdHJpbmddOyAvLyBhc3N1bWluZyB3ZSdyZSBpbiBub2RlLCBsZXQncyB0cnkgdG8gZ2V0IG5vZGUnc1xuICAgICAgLy8gdmVyc2lvbiBvZiBzZXRJbW1lZGlhdGUsIGJ5cGFzc2luZyBmYWtlIHRpbWVycyBpZiBhbnkuXG5cbiAgICAgIGVucXVldWVUYXNrSW1wbCA9IG5vZGVSZXF1aXJlLmNhbGwobW9kdWxlLCAndGltZXJzJykuc2V0SW1tZWRpYXRlO1xuICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgIC8vIHdlJ3JlIGluIGEgYnJvd3NlclxuICAgICAgLy8gd2UgY2FuJ3QgdXNlIHJlZ3VsYXIgdGltZXJzIGJlY2F1c2UgdGhleSBtYXkgc3RpbGwgYmUgZmFrZWRcbiAgICAgIC8vIHNvIHdlIHRyeSBNZXNzYWdlQ2hhbm5lbCtwb3N0TWVzc2FnZSBpbnN0ZWFkXG4gICAgICBlbnF1ZXVlVGFza0ltcGwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmIChkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dE1lc3NhZ2VDaGFubmVsID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBoYXZlIGEgTWVzc2FnZUNoYW5uZWwgaW1wbGVtZW50YXRpb24sICcgKyAnc28gZW5xdWV1aW5nIHRhc2tzIHZpYSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKSB3aWxsIGZhaWwuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3VlcyAnICsgJ2lmIHlvdSBlbmNvdW50ZXIgdGhpcyB3YXJuaW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gY2FsbGJhY2s7XG4gICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UodW5kZWZpbmVkKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVucXVldWVUYXNrSW1wbCh0YXNrKTtcbn1cblxudmFyIGFjdFNjb3BlRGVwdGggPSAwO1xudmFyIGRpZFdhcm5Ob0F3YWl0QWN0ID0gZmFsc2U7XG5mdW5jdGlvbiBhY3QoY2FsbGJhY2spIHtcbiAge1xuICAgIC8vIGBhY3RgIGNhbGxzIGNhbiBiZSBuZXN0ZWQsIHNvIHdlIHRyYWNrIHRoZSBkZXB0aC4gVGhpcyByZXByZXNlbnRzIHRoZVxuICAgIC8vIG51bWJlciBvZiBgYWN0YCBzY29wZXMgb24gdGhlIHN0YWNrLlxuICAgIHZhciBwcmV2QWN0U2NvcGVEZXB0aCA9IGFjdFNjb3BlRGVwdGg7XG4gICAgYWN0U2NvcGVEZXB0aCsrO1xuXG4gICAgaWYgKFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIG91dGVybW9zdCBgYWN0YCBzY29wZS4gSW5pdGlhbGl6ZSB0aGUgcXVldWUuIFRoZSByZWNvbmNpbGVyXG4gICAgICAvLyB3aWxsIGRldGVjdCB0aGUgcXVldWUgYW5kIHVzZSBpdCBpbnN0ZWFkIG9mIFNjaGVkdWxlci5cbiAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgcHJldklzQmF0Y2hpbmdMZWdhY3kgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5pc0JhdGNoaW5nTGVnYWN5O1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICB0cnkge1xuICAgICAgLy8gVXNlZCB0byByZXByb2R1Y2UgYmVoYXZpb3Igb2YgYGJhdGNoZWRVcGRhdGVzYCBpbiBsZWdhY3kgbW9kZS4gT25seVxuICAgICAgLy8gc2V0IHRvIGB0cnVlYCB3aGlsZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgaXMgZXhlY3V0ZWQsIG5vdCBmb3IgdXBkYXRlc1xuICAgICAgLy8gdHJpZ2dlcmVkIGR1cmluZyBhbiBhc3luYyBldmVudCwgYmVjYXVzZSB0aGlzIGlzIGhvdyB0aGUgbGVnYWN5XG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbiBvZiBgYWN0YCBiZWhhdmVkLlxuICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuaXNCYXRjaGluZ0xlZ2FjeSA9IHRydWU7XG4gICAgICByZXN1bHQgPSBjYWxsYmFjaygpOyAvLyBSZXBsaWNhdGUgYmVoYXZpb3Igb2Ygb3JpZ2luYWwgYGFjdGAgaW1wbGVtZW50YXRpb24gaW4gbGVnYWN5IG1vZGUsXG4gICAgICAvLyB3aGljaCBmbHVzaGVkIHVwZGF0ZXMgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHNjb3BlIGZ1bmN0aW9uIGV4aXRzLCBldmVuXG4gICAgICAvLyBpZiBpdCdzIGFuIGFzeW5jIGZ1bmN0aW9uLlxuXG4gICAgICBpZiAoIXByZXZJc0JhdGNoaW5nTGVnYWN5ICYmIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmRpZFNjaGVkdWxlTGVnYWN5VXBkYXRlKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKHF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICBmbHVzaEFjdFF1ZXVlKHF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBwb3BBY3RTY29wZShwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuaXNCYXRjaGluZ0xlZ2FjeSA9IHByZXZJc0JhdGNoaW5nTGVnYWN5O1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQgIT09IG51bGwgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdGhlbmFibGVSZXN1bHQgPSByZXN1bHQ7IC8vIFRoZSBjYWxsYmFjayBpcyBhbiBhc3luYyBmdW5jdGlvbiAoaS5lLiByZXR1cm5lZCBhIHByb21pc2UpLiBXYWl0XG4gICAgICAvLyBmb3IgaXQgdG8gcmVzb2x2ZSBiZWZvcmUgZXhpdGluZyB0aGUgY3VycmVudCBzY29wZS5cblxuICAgICAgdmFyIHdhc0F3YWl0ZWQgPSBmYWxzZTtcbiAgICAgIHZhciB0aGVuYWJsZSA9IHtcbiAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHdhc0F3YWl0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoZW5hYmxlUmVzdWx0LnRoZW4oZnVuY3Rpb24gKHJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICBwb3BBY3RTY29wZShwcmV2QWN0U2NvcGVEZXB0aCk7XG5cbiAgICAgICAgICAgIGlmIChhY3RTY29wZURlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIFdlJ3ZlIGV4aXRlZCB0aGUgb3V0ZXJtb3N0IGFjdCBzY29wZS4gUmVjdXJzaXZlbHkgZmx1c2ggdGhlXG4gICAgICAgICAgICAgIC8vIHF1ZXVlIHVudGlsIHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmsuXG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayB0aHJldyBhbiBlcnJvci5cbiAgICAgICAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKTtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKCFkaWRXYXJuTm9Bd2FpdEFjdCAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHt9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghd2FzQXdhaXRlZCkge1xuICAgICAgICAgICAgICBkaWRXYXJuTm9Bd2FpdEFjdCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgZXJyb3IoJ1lvdSBjYWxsZWQgYWN0KGFzeW5jICgpID0+IC4uLikgd2l0aG91dCBhd2FpdC4gJyArICdUaGlzIGNvdWxkIGxlYWQgdG8gdW5leHBlY3RlZCB0ZXN0aW5nIGJlaGF2aW91ciwgJyArICdpbnRlcmxlYXZpbmcgbXVsdGlwbGUgYWN0IGNhbGxzIGFuZCBtaXhpbmcgdGhlaXIgJyArICdzY29wZXMuICcgKyAnWW91IHNob3VsZCAtIGF3YWl0IGFjdChhc3luYyAoKSA9PiAuLi4pOycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJldHVyblZhbHVlID0gcmVzdWx0OyAvLyBUaGUgY2FsbGJhY2sgaXMgbm90IGFuIGFzeW5jIGZ1bmN0aW9uLiBFeGl0IHRoZSBjdXJyZW50IHNjb3BlXG4gICAgICAvLyBpbW1lZGlhdGVseSwgd2l0aG91dCBhd2FpdGluZy5cblxuICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFNjb3BlRGVwdGgpO1xuXG4gICAgICBpZiAoYWN0U2NvcGVEZXB0aCA9PT0gMCkge1xuICAgICAgICAvLyBFeGl0aW5nIHRoZSBvdXRlcm1vc3QgYWN0IHNjb3BlLiBGbHVzaCB0aGUgcXVldWUuXG4gICAgICAgIHZhciBfcXVldWUgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50O1xuXG4gICAgICAgIGlmIChfcXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICBmbHVzaEFjdFF1ZXVlKF9xdWV1ZSk7XG4gICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH0gLy8gUmV0dXJuIGEgdGhlbmFibGUuIElmIHRoZSB1c2VyIGF3YWl0cyBpdCwgd2UnbGwgZmx1c2ggYWdhaW4gaW5cbiAgICAgICAgLy8gY2FzZSBhZGRpdGlvbmFsIHdvcmsgd2FzIHNjaGVkdWxlZCBieSBhIG1pY3JvdGFzay5cblxuXG4gICAgICAgIHZhciBfdGhlbmFibGUgPSB7XG4gICAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLy8gQ29uZmlybSB3ZSBoYXZlbid0IHJlLWVudGVyZWQgYW5vdGhlciBgYWN0YCBzY29wZSwgaW4gY2FzZVxuICAgICAgICAgICAgLy8gdGhlIHVzZXIgZG9lcyBzb21ldGhpbmcgd2VpcmQgbGlrZSBhd2FpdCB0aGUgdGhlbmFibGVcbiAgICAgICAgICAgIC8vIG11bHRpcGxlIHRpbWVzLlxuICAgICAgICAgICAgaWYgKFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmx1c2ggdGhlIHF1ZXVlIHVudGlsIHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmsuXG4gICAgICAgICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGVuYWJsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNpbmNlIHdlJ3JlIGluc2lkZSBhIG5lc3RlZCBgYWN0YCBzY29wZSwgdGhlIHJldHVybmVkIHRoZW5hYmxlXG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IHJlc29sdmVzLiBUaGUgb3V0ZXIgc2NvcGUgd2lsbCBmbHVzaCB0aGUgcXVldWUuXG4gICAgICAgIHZhciBfdGhlbmFibGUyID0ge1xuICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGVuYWJsZTI7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKSB7XG4gIHtcbiAgICBpZiAocHJldkFjdFNjb3BlRGVwdGggIT09IGFjdFNjb3BlRGVwdGggLSAxKSB7XG4gICAgICBlcnJvcignWW91IHNlZW0gdG8gaGF2ZSBvdmVybGFwcGluZyBhY3QoKSBjYWxscywgdGhpcyBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0JlIHN1cmUgdG8gYXdhaXQgcHJldmlvdXMgYWN0KCkgY2FsbHMgYmVmb3JlIG1ha2luZyBhIG5ldyBvbmUuICcpO1xuICAgIH1cblxuICAgIGFjdFNjb3BlRGVwdGggPSBwcmV2QWN0U2NvcGVEZXB0aDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKHJldHVyblZhbHVlLCByZXNvbHZlLCByZWplY3QpIHtcbiAge1xuICAgIHZhciBxdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG5cbiAgICBpZiAocXVldWUgIT09IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZsdXNoQWN0UXVldWUocXVldWUpO1xuICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTm8gYWRkaXRpb25hbCB3b3JrIHdhcyBzY2hlZHVsZWQuIEZpbmlzaC5cbiAgICAgICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEtlZXAgZmx1c2hpbmcgd29yayB1bnRpbCB0aGVyZSdzIG5vbmUgbGVmdC5cbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgaXNGbHVzaGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaEFjdFF1ZXVlKHF1ZXVlKSB7XG4gIHtcbiAgICBpZiAoIWlzRmx1c2hpbmcpIHtcbiAgICAgIC8vIFByZXZlbnQgcmUtZW50cmFuY2UuXG4gICAgICBpc0ZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICg7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICB9IHdoaWxlIChjYWxsYmFjayAhPT0gbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgc29tZXRoaW5nIHRocm93cywgbGVhdmUgdGhlIHJlbWFpbmluZyBjYWxsYmFja3Mgb24gdGhlIHF1ZXVlLlxuICAgICAgICBxdWV1ZSA9IHF1ZXVlLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBjcmVhdGVFbGVtZW50JDEgPSAgY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjbG9uZUVsZW1lbnQkMSA9ICBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY3JlYXRlRmFjdG9yeSA9ICBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24gO1xudmFyIENoaWxkcmVuID0ge1xuICBtYXA6IG1hcENoaWxkcmVuLFxuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5LFxuICBvbmx5OiBvbmx5Q2hpbGRcbn07XG5cbmV4cG9ydHMuQ2hpbGRyZW4gPSBDaGlsZHJlbjtcbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5leHBvcnRzLlByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbmV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IFB1cmVDb21wb25lbnQ7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5leHBvcnRzLmNsb25lRWxlbWVudCA9IGNsb25lRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDtcbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlRmFjdG9yeSA9IGNyZWF0ZUZhY3Rvcnk7XG5leHBvcnRzLmNyZWF0ZVJlZiA9IGNyZWF0ZVJlZjtcbmV4cG9ydHMuZm9yd2FyZFJlZiA9IGZvcndhcmRSZWY7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50ID0gaXNWYWxpZEVsZW1lbnQ7XG5leHBvcnRzLmxhenkgPSBsYXp5O1xuZXhwb3J0cy5tZW1vID0gbWVtbztcbmV4cG9ydHMuc3RhcnRUcmFuc2l0aW9uID0gc3RhcnRUcmFuc2l0aW9uO1xuZXhwb3J0cy51bnN0YWJsZV9hY3QgPSBhY3Q7XG5leHBvcnRzLnVzZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s7XG5leHBvcnRzLnVzZUNvbnRleHQgPSB1c2VDb250ZXh0O1xuZXhwb3J0cy51c2VEZWJ1Z1ZhbHVlID0gdXNlRGVidWdWYWx1ZTtcbmV4cG9ydHMudXNlRGVmZXJyZWRWYWx1ZSA9IHVzZURlZmVycmVkVmFsdWU7XG5leHBvcnRzLnVzZUVmZmVjdCA9IHVzZUVmZmVjdDtcbmV4cG9ydHMudXNlSWQgPSB1c2VJZDtcbmV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IHVzZUltcGVyYXRpdmVIYW5kbGU7XG5leHBvcnRzLnVzZUluc2VydGlvbkVmZmVjdCA9IHVzZUluc2VydGlvbkVmZmVjdDtcbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0O1xuZXhwb3J0cy51c2VNZW1vID0gdXNlTWVtbztcbmV4cG9ydHMudXNlUmVkdWNlciA9IHVzZVJlZHVjZXI7XG5leHBvcnRzLnVzZVJlZiA9IHVzZVJlZjtcbmV4cG9ydHMudXNlU3RhdGUgPSB1c2VTdGF0ZTtcbmV4cG9ydHMudXNlU3luY0V4dGVybmFsU3RvcmUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTtcbmV4cG9ydHMudXNlVHJhbnNpdGlvbiA9IHVzZVRyYW5zaXRpb247XG5leHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gICAgICAgICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xufVxuICAgICAgICBcbiAgfSkoKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7XG4gIEVsZW1lbnRDbGFzcyxcbiAgRWxlbWVudFVJLFxuICBFbGVtZW50QXR0cmlidXRlcyxcbn0gZnJvbSAnLi9lbGVtZW50LmpzJztcbmltcG9ydCB0eXBlIFBpZWNlIGZyb20gJy4vcGllY2UuanMnO1xuaW1wb3J0IHR5cGUgR2FtZSBmcm9tICcuL2dhbWUuanMnO1xuaW1wb3J0IHR5cGUgeyBHYW1lRWxlbWVudCB9IGZyb20gJy4vaW5kZXguanMnXG5cbi8qKlxuICogRWl0aGVyIHRoZSBuYW1lIG9mIGEgcHJvcGVydHkgb2YgdGhlIG9iamVjdCB0aGF0IGNhbiBiZSBsZXhpY2FsbHkgc29ydGVkLCBvclxuICogYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIG9iamVjdCB0byBzb3J0IGFuZCBtdXN0IHJldHVybiBhXG4gKiBsZXhpY2FsbHkgc29ydGFibGUgdmFsdWUuXG4gKiBAY2F0ZWdvcnkgQm9hcmRcbiAqL1xuZXhwb3J0IHR5cGUgU29ydGVyPFQ+ID0ga2V5b2YgVCB8ICgoZTogVCkgPT4gbnVtYmVyIHwgc3RyaW5nKVxuXG5pbXBvcnQgdHlwZSB7IFBsYXllciB9IGZyb20gJy4uL3BsYXllci9pbmRleC5qcyc7XG5pbXBvcnQgeyBCYXNlR2FtZSB9IGZyb20gJy4vZ2FtZS5qcyc7XG5cbi8qKlxuICogQSBxdWVyeSBmaWx0ZXIgY2FuIGJlIG9uZSBvZiAzIGRpZmZlcmVudCBmb3JtczpcbiAqIC0gKnN0cmluZyo6IHdpbGwgbWF0Y2ggZWxlbWVudHMgd2l0aCB0aGlzIG5hbWVcbiAqIC0gKmZ1bmN0aW9uKjogQSBmdW5jdGlvbiB0aGF0IGFjY2VwdCBhbiBlbGVtZW50IGFzIGl0cyBhcmd1bWVudCBhbmQgcmV0dXJucyBhXG4gKiAgICAgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaXQgaXMgYSBtYXRjaCwgc2ltaWxhciB0byBgQXJyYXkjZmlsdGVyYC5cbiAqIC0gKm9iamVjdCo6IHdpbGwgbWF0Y2ggZWxlbWVudHMgd2hvc2UgcHJvcGVydGllcyBtYXRjaCB0aGUgcHJvdmlkZWRcbiAqICAgICBwcm9wZXJ0aWVzLiBGb3IgZXhhbXBsZSwgYGRlY2suYWxsKENhcmQsIHtzdWl0OiAnSCd9KWAgd291bGQgbWF0Y2ggYWxsXG4gKiAgICAgYENhcmRgIGVsZW1lbnRzIGluIGBkZWNrYCB3aXRoIGEgYHN1aXRgIHByb3BlcnR5IGVxdWFsIHRvIGBcIkhcImAuIFRoZXJlIGFyZVxuICogICAgIHNvbWUgc3BlY2lhbCBwcm9wZXJ0eSBuYW1lcyBhbGxvd2VkIGhlcmU6XG4gKiAgIC0gKm1pbmUqOiB0cnVlL2ZhbHNlIHdoZXRoZXIgdGhpcyBlbGVtZW50IGJlbG9uZ3MgdG8gdGhlIHBsYXllciBpbiB3aG9zZSBjb250ZXh0IHRoZSBxdWVyeSBpcyBtYWRlXG4gKiAgIC0gKmVtcHR5KiB0cnVlL2ZhbHNlIHdoZXRoZXIgdGhpcyBlbGVtZW50IGlzIGVtcHR5XG4gKiAgIC0gKmFkamFjZW50KiB0cnVlL2ZhbHNlIHdoZXRoZXIgdGhpcyBlbGVtZW50IGlzIGFkamFjZW50IGJ5IGEgY29ubmVjdGlvbiB0byB0aGVcbiAqICAgICAgIGVsZW1lbnQgb24gd2hpY2ggdGhlIHF1ZXJ5IG1ldGhvZCB3YXNcbiAqICAgICAgIGNhbGxlZC4gRS5nLiBgZnJhbmNlLm90aGVyKENvdW50cnksIHthZGphY2VudDogdHJ1ZX0pYCB3aWxsIG1hdGNoXG4gKiAgICAgICBgQ291bnRyeWAgZWxlbWVudHMgdGhhdCBhcmUgY29ubmVjdGVkIHRvIGBmcmFuY2VgIGJ5IHtAbGlua1xuICogICAgICAgU3BhY2UjY29ubmVjdFRvfVxuICogICAtICp3aXRoaW5EaXN0YW5jZSogU2ltaWxhciB0byBhZGphY2VudCBidXQgdXNlcyB0aGUgcHJvdmlkZWQgbnVtYmVyIHRvXG4gKiAgICAgICBkZXRlcm1pbmUgaWYgYSBjb25uZWN0aW9uIGlzIHBvc3NpYmxlIGJldHdlZW4gZWxlbWVudHMgd2hvc2UgY29zdCBpc1xuICogICAgICAgbm90IGdyZWF0ZXIgdGhhbiB0aGUgcHJvdmlkZWQgdmFsdWVcbiAqIEBjYXRlZ29yeSBCb2FyZFxuICovXG5leHBvcnQgdHlwZSBFbGVtZW50RmluZGVyPFQgZXh0ZW5kcyBHYW1lRWxlbWVudCA9IEdhbWVFbGVtZW50PiA9IChcbiAgKChlOiBUKSA9PiBib29sZWFuKSB8XG4gICAgKEVsZW1lbnRBdHRyaWJ1dGVzPFQ+ICYge21pbmU/OiBib29sZWFuLCBvd25lcj86IFRbJ3BsYXllciddLCBlbXB0eT86IGJvb2xlYW59KSB8XG4gICAgc3RyaW5nXG4pO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgdGhhdCByZXR1cm4gZ3JvdXBzIG9mIHtAbGluayBHYW1lRWxlbWVudH0ncyByZXR1cm5cbiAqIHRoaXMgQXJyYXktbGlrZSBjbGFzcy5cbiAqIEBub0luaGVyaXREb2NcbiAqIEBjYXRlZ29yeSBCb2FyZFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50Q29sbGVjdGlvbjxUIGV4dGVuZHMgR2FtZUVsZW1lbnQgPSBHYW1lRWxlbWVudD4gZXh0ZW5kcyBBcnJheTxUPiB7XG5cbiAgc2xpY2UoLi4uYTogUGFyYW1ldGVyczxBcnJheTxUPlsnc2xpY2UnXT4pOkVsZW1lbnRDb2xsZWN0aW9uPFQ+IHtyZXR1cm4gc3VwZXIuc2xpY2UoLi4uYSkgYXMgRWxlbWVudENvbGxlY3Rpb248VD59XG4gIGZpbHRlciguLi5hOiBQYXJhbWV0ZXJzPEFycmF5PFQ+WydmaWx0ZXInXT4pOkVsZW1lbnRDb2xsZWN0aW9uPFQ+IHtyZXR1cm4gc3VwZXIuZmlsdGVyKC4uLmEpIGFzIEVsZW1lbnRDb2xsZWN0aW9uPFQ+fVxuXG4gIC8qKlxuICAgKiBBcyB7QGxpbmsgR2FtZUVsZW1lbnQjYWxsfSwgYnV0IGZpbmRzIGFsbCBlbGVtZW50cyB3aXRoaW4gdGhpcyBjb2xsZWN0aW9uXG4gICAqIGFuZCBpdHMgY29udGFpbmVkIGVsZW1lbnRzIHJlY3Vyc2l2ZWx5LlxuICAgKiBAY2F0ZWdvcnkgUXVlcmllc1xuICAgKlxuICAgKiBAcGFyYW0ge2NsYXNzfSBjbGFzc05hbWUgLSBPcHRpb25hbGx5IHByb3ZpZGUgYSBjbGFzcyBhcyB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICogYXMgYSBjbGFzcyBmaWx0ZXIuIFRoaXMgd2lsbCBvbmx5IG1hdGNoIGVsZW1lbnRzIHdoaWNoIGFyZSBpbnN0YW5jZXMgb2YgdGhlXG4gICAqIHByb3ZpZGVkIGNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSBmaW5kZXJzIC0gQWxsIG90aGVyIHBhcmFtZXRlcnMgYXJlIGZpbHRlcnMuIFNlZSB7QGxpbmtcbiAgICogRWxlbWVudEZpbmRlcn0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIHtAbGluayBFbGVtZW50Q29sbGVjdGlvbn0gb2YgYXMgbWFueSBtYXRjaGluZyBlbGVtZW50cyBhcyBjYW4gYmVcbiAgICogZm91bmQuIFRoZSBjb2xsZWN0aW9uIGlzIHR5cGVkIHRvIGBFbGVtZW50Q29sbGVjdGlvbjxjbGFzc05hbWU+YCBpZiBvbmUgd2FzXG4gICAqIHByb3ZpZGVkLlxuICAgKi9cbiAgYWxsPEYgZXh0ZW5kcyBHYW1lRWxlbWVudD4oY2xhc3NOYW1lOiBFbGVtZW50Q2xhc3M8Rj4sIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXI8Rj5bXSk6IEVsZW1lbnRDb2xsZWN0aW9uPEY+O1xuICBhbGwoY2xhc3NOYW1lPzogRWxlbWVudEZpbmRlciwgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcltdKTogRWxlbWVudENvbGxlY3Rpb248VD47XG4gIGFsbChjbGFzc05hbWU/OiBFbGVtZW50RmluZGVyIHwgRWxlbWVudENsYXNzLCAuLi5maW5kZXJzOiBFbGVtZW50RmluZGVyW10pOiBFbGVtZW50Q29sbGVjdGlvbjxhbnk+IHtcbiAgICBpZiAoKHR5cGVvZiBjbGFzc05hbWUgIT09ICdmdW5jdGlvbicpIHx8ICEoJ2lzR2FtZUVsZW1lbnQnIGluIGNsYXNzTmFtZSkpIHtcbiAgICAgIGlmIChjbGFzc05hbWUpIGZpbmRlcnMgPSBbY2xhc3NOYW1lLCAuLi5maW5kZXJzXTtcbiAgICAgIHJldHVybiB0aGlzLl9maW5kZXIodW5kZWZpbmVkLCB7fSwgLi4uZmluZGVycyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9maW5kZXIoY2xhc3NOYW1lLCB7fSwgLi4uZmluZGVycyk7XG4gIH1cblxuICBfZmluZGVyPEYgZXh0ZW5kcyBHYW1lRWxlbWVudD4oXG4gICAgY2xhc3NOYW1lOiBFbGVtZW50Q2xhc3M8Rj4gfCB1bmRlZmluZWQsXG4gICAgb3B0aW9uczoge2xpbWl0PzogbnVtYmVyLCBvcmRlcj86ICdhc2MnIHwgJ2Rlc2MnLCBub1JlY3Vyc2l2ZT86IGJvb2xlYW59LFxuICAgIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXI8Rj5bXVxuICApOiBFbGVtZW50Q29sbGVjdGlvbjxGPiB7XG4gICAgY29uc3QgY29sbCA9IG5ldyBFbGVtZW50Q29sbGVjdGlvbjxGPigpO1xuICAgIGlmIChvcHRpb25zLmxpbWl0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5saW1pdCA8PSAwKSByZXR1cm4gY29sbDtcblxuICAgIGNvbnN0IGZuczogKChlOiBGKSA9PiBib29sZWFuKVtdID0gZmluZGVycy5tYXAoZmluZGVyID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZmluZGVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBhdHRycyA9IGZpbmRlcjtcbiAgICAgICAgcmV0dXJuIGVsID0+IE9iamVjdC5lbnRyaWVzKGF0dHJzKS5ldmVyeSgoW2sxLCB2MV0pID0+IChcbiAgICAgICAgICAoazEgPT09ICdlbXB0eScgPyBlbC5pc0VtcHR5KCkgOiBlbFtrMSBhcyBrZXlvZiB0eXBlb2YgZWxdKSA9PT0gdjFcbiAgICAgICAgKSlcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZmluZGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBuYW1lID0gZmluZGVyO1xuICAgICAgICByZXR1cm4gZWwgPT4gZWwubmFtZSA9PT0gbmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaW5kZXI7XG4gICAgfSlcblxuICAgIGNvbnN0IGZpbmRlckZuID0gKGVsOiBULCBvcmRlcjogJ2FzYycgfCAnZGVzYycpID0+IHtcbiAgICAgIGlmICgoIWNsYXNzTmFtZSB8fCBlbCBpbnN0YW5jZW9mIGNsYXNzTmFtZSkgJiYgZm5zLmV2ZXJ5KGZuID0+IGZuKGVsIGFzIHVua25vd24gYXMgRikpKSB7XG4gICAgICAgIGlmIChvcmRlciA9PT0gJ2FzYycpIHtcbiAgICAgICAgICBjb2xsLnB1c2goZWwgYXMgdW5rbm93biBhcyBGKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xsLnVuc2hpZnQoZWwgYXMgdW5rbm93biBhcyBGKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFvcHRpb25zLm5vUmVjdXJzaXZlKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb2xsLnB1c2goLi4uZWwuX3QuY2hpbGRyZW4uX2ZpbmRlcihjbGFzc05hbWUsIHtsaW1pdDogb3B0aW9ucy5saW1pdCAtIGNvbGwubGVuZ3RoLCBvcmRlcjogb3B0aW9ucy5vcmRlcn0sIC4uLmZpbmRlcnMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xsLnB1c2goLi4uZWwuX3QuY2hpbGRyZW4uX2ZpbmRlcihjbGFzc05hbWUsIHt9LCAuLi5maW5kZXJzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMub3JkZXIgPT09ICdkZXNjJykge1xuICAgICAgZm9yIChsZXQgZSA9IHRoaXMubGVuZ3RoIC0gMTsgZSA+PSAwOyBlLS0pIHtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzW2VdO1xuICAgICAgICBpZiAob3B0aW9ucy5saW1pdCAhPT0gdW5kZWZpbmVkICYmIGNvbGwubGVuZ3RoID49IG9wdGlvbnMubGltaXQpIGJyZWFrO1xuICAgICAgICBmaW5kZXJGbihlbCwgJ2Rlc2MnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBlbCBvZiB0aGlzKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmxpbWl0ICE9PSB1bmRlZmluZWQgJiYgY29sbC5sZW5ndGggPj0gb3B0aW9ucy5saW1pdCkgYnJlYWs7XG4gICAgICAgIGZpbmRlckZuKGVsLCAnYXNjJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbGw7XG4gIH1cblxuICAvKipcbiAgICogQXMge0BsaW5rIEdhbWVFbGVtZW50I2ZpcnN0fSwgZXhjZXB0IGZpbmRzIHRoZSBmaXJzdCBlbGVtZW50IHdpdGhpbiB0aGlzXG4gICAqIGNvbGxlY3Rpb24gYW5kIGl0cyBjb250YWluZWQgZWxlbWVudHMgcmVjdXJzaXZlbHkgdGhhdCBtYXRjaGVzIHRoZVxuICAgKiBhcmd1bWVudHMgcHJvdmlkZWQuIFNlZSB7QGxpbmsgR2FtZUVsZW1lbnQjYWxsfSBmb3IgcGFyYW1ldGVyIGRldGFpbHMuXG4gICAqIEBjYXRlZ29yeSBRdWVyaWVzXG4gICAqIEByZXR1cm5zIEEgbWF0Y2hpbmcgZWxlbWVudCwgaWYgZm91bmRcbiAgICovXG4gIGZpcnN0PEYgZXh0ZW5kcyBHYW1lRWxlbWVudD4oY2xhc3NOYW1lOiBFbGVtZW50Q2xhc3M8Rj4sIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXI8Rj5bXSk6IEYgfCB1bmRlZmluZWQ7XG4gIGZpcnN0KGNsYXNzTmFtZT86IEVsZW1lbnRGaW5kZXIsIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXJbXSk6IFQgfCB1bmRlZmluZWQ7XG4gIGZpcnN0KGNsYXNzTmFtZT86IEVsZW1lbnRGaW5kZXIgfCBFbGVtZW50Q2xhc3MsIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXJbXSk6IEdhbWVFbGVtZW50IHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoKHR5cGVvZiBjbGFzc05hbWUgIT09ICdmdW5jdGlvbicpIHx8ICEoJ2lzR2FtZUVsZW1lbnQnIGluIGNsYXNzTmFtZSkpIHtcbiAgICAgIGlmIChjbGFzc05hbWUpIGZpbmRlcnMgPSBbY2xhc3NOYW1lLCAuLi5maW5kZXJzXTtcbiAgICAgIHJldHVybiB0aGlzLl9maW5kZXIodW5kZWZpbmVkLCB7bGltaXQ6IDF9LCAuLi5maW5kZXJzKVswXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRlcihjbGFzc05hbWUsIHtsaW1pdDogMX0sIC4uLmZpbmRlcnMpWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzIHtAbGluayBHYW1lRWxlbWVudCNmaXJzdG59LCBleGNlcHQgZmluZHMgdGhlIGZpcnN0IGBuYCBlbGVtZW50cyB3aXRoaW5cbiAgICogdGhpcyBjb2xsZWN0aW9uIGFuZCBpdHMgY29udGFpbmVkIGVsZW1lbnRzIHJlY3Vyc2l2ZWx5IHRoYXQgbWF0Y2ggdGhlXG4gICAqIGFyZ3VtZW50cyBwcm92aWRlZC4gU2VlIHtAbGluayBhbGx9IGZvciBwYXJhbWV0ZXIgZGV0YWlscy5cbiAgICogQGNhdGVnb3J5IFF1ZXJpZXNcbiAgICogQHBhcmFtIG4gLSBudW1iZXIgb2YgbWF0Y2hlc1xuICAgKlxuICAgKiBAcmV0dXJucyBBbiB7QGxpbmsgRWxlbWVudENvbGxlY3Rpb259IG9mIGFzIG1hbnkgbWF0Y2hpbmcgZWxlbWVudHMgYXMgY2FuIGJlXG4gICAqIGZvdW5kLCB1cCB0byBgbmAuIFRoZSBjb2xsZWN0aW9uIGlzIHR5cGVkIHRvIGBFbGVtZW50Q29sbGVjdGlvbjxjbGFzc05hbWU+YFxuICAgKiBpZiBvbmUgd2FzIHByb3ZpZGVkLlxuICAgKi9cbiAgZmlyc3ROPEYgZXh0ZW5kcyBHYW1lRWxlbWVudD4objogbnVtYmVyLCBjbGFzc05hbWU6IEVsZW1lbnRDbGFzczxGPiwgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcjxGPltdKTogRWxlbWVudENvbGxlY3Rpb248Rj47XG4gIGZpcnN0TihuOiBudW1iZXIsIGNsYXNzTmFtZT86IEVsZW1lbnRGaW5kZXIsIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXJbXSk6IEVsZW1lbnRDb2xsZWN0aW9uPFQ+O1xuICBmaXJzdE4objogbnVtYmVyLCBjbGFzc05hbWU/OiBFbGVtZW50RmluZGVyIHwgRWxlbWVudENsYXNzLCAuLi5maW5kZXJzOiBFbGVtZW50RmluZGVyW10pOiBFbGVtZW50Q29sbGVjdGlvbjxhbnk+IHtcbiAgICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInKSB0aHJvdyBFcnJvcignZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBudW1iZXIgb2YgbWF0Y2hlcycpO1xuICAgIGlmICgodHlwZW9mIGNsYXNzTmFtZSAhPT0gJ2Z1bmN0aW9uJykgfHwgISgnaXNHYW1lRWxlbWVudCcgaW4gY2xhc3NOYW1lKSkge1xuICAgICAgaWYgKGNsYXNzTmFtZSkgZmluZGVycyA9IFtjbGFzc05hbWUsIC4uLmZpbmRlcnNdO1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRlcjxHYW1lRWxlbWVudD4odW5kZWZpbmVkLCB7bGltaXQ6IG59LCAuLi5maW5kZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRlcihjbGFzc05hbWUsIHtsaW1pdDogbn0sIC4uLmZpbmRlcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzIHtAbGluayBHYW1lRWxlbWVudCNsYXN0fSwgZXhwZWN0IGZpbmRzIHRoZSBsYXN0IGVsZW1lbnQgd2l0aGluIHRoaXNcbiAgICogY29sbGVjdGlvbiBhbmQgaXRzIGNvbnRhaW5lZCBlbGVtZW50cyByZWN1cnNpdmVseSB0aGF0IG1hdGNoZXMgdGhlXG4gICAqIGFyZ3VtZW50cyBwcm92aWRlZC4gU2VlIHtAbGluayBhbGx9IGZvciBwYXJhbWV0ZXIgZGV0YWlscy5cbiAgICogQGNhdGVnb3J5IFF1ZXJpZXNcbiAgICogQHJldHVybnMgQSBtYXRjaGluZyBlbGVtZW50LCBpZiBmb3VuZFxuICAgKi9cbiAgbGFzdDxGIGV4dGVuZHMgR2FtZUVsZW1lbnQ+KGNsYXNzTmFtZTogRWxlbWVudENsYXNzPEY+LCAuLi5maW5kZXJzOiBFbGVtZW50RmluZGVyPEY+W10pOiBGIHwgdW5kZWZpbmVkO1xuICBsYXN0KGNsYXNzTmFtZT86IEVsZW1lbnRGaW5kZXIsIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXJbXSk6IFQgfCB1bmRlZmluZWQ7XG4gIGxhc3QoY2xhc3NOYW1lPzogRWxlbWVudEZpbmRlciB8IEVsZW1lbnRDbGFzcywgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcltdKTogR2FtZUVsZW1lbnQgfCB1bmRlZmluZWQge1xuICAgIGlmICgodHlwZW9mIGNsYXNzTmFtZSAhPT0gJ2Z1bmN0aW9uJykgfHwgISgnaXNHYW1lRWxlbWVudCcgaW4gY2xhc3NOYW1lKSkge1xuICAgICAgaWYgKGNsYXNzTmFtZSkgZmluZGVycyA9IFtjbGFzc05hbWUsIC4uLmZpbmRlcnNdO1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRlcjxHYW1lRWxlbWVudD4odW5kZWZpbmVkLCB7bGltaXQ6IDEsIG9yZGVyOiAnZGVzYyd9LCAuLi5maW5kZXJzKVswXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRlcihjbGFzc05hbWUsIHtsaW1pdDogMSwgb3JkZXI6ICdkZXNjJ30sIC4uLmZpbmRlcnMpWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzIHtAbGluayBHYW1lRWxlbWVudCNsYXN0bn0sIGV4cGVjdCBmaW5kcyB0aGUgbGFzdCBuIGVsZW1lbnRzIHdpdGhpbiB0aGlzXG4gICAqIGNvbGxlY3Rpb24gYW5kIGl0cyBjb250YWluZWQgZWxlbWVudHMgcmVjdXJzaXZlbHkgdGhhdCBtYXRjaCB0aGUgYXJndW1lbnRzXG4gICAqIHByb3ZpZGVkLiBTZWUge0BsaW5rIGFsbH0gZm9yIHBhcmFtZXRlciBkZXRhaWxzLlxuICAgKiBAY2F0ZWdvcnkgUXVlcmllc1xuICAgKiBAcGFyYW0gbiAtIG51bWJlciBvZiBtYXRjaGVzXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIHtAbGluayBFbGVtZW50Q29sbGVjdGlvbn0gb2YgYXMgbWFueSBtYXRjaGluZyBlbGVtZW50cyBhcyBjYW4gYmVcbiAgICogZm91bmQsIHVwIHRvIGBuYC4gVGhlIGNvbGxlY3Rpb24gaXMgdHlwZWQgdG8gYEVsZW1lbnRDb2xsZWN0aW9uPGNsYXNzTmFtZT5gXG4gICAqIGlmIG9uZSB3YXMgcHJvdmlkZWQuXG4gICAqL1xuICBsYXN0TjxGIGV4dGVuZHMgR2FtZUVsZW1lbnQ+KG46IG51bWJlciwgY2xhc3NOYW1lOiBFbGVtZW50Q2xhc3M8Rj4sIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXI8Rj5bXSk6IEVsZW1lbnRDb2xsZWN0aW9uPEY+O1xuICBsYXN0TihuOiBudW1iZXIsIGNsYXNzTmFtZT86IEVsZW1lbnRGaW5kZXIsIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXJbXSk6IEVsZW1lbnRDb2xsZWN0aW9uPFQ+O1xuICBsYXN0TihuOiBudW1iZXIsIGNsYXNzTmFtZT86IEVsZW1lbnRGaW5kZXIgfCBFbGVtZW50Q2xhc3MsIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXJbXSk6IEVsZW1lbnRDb2xsZWN0aW9uPGFueT4ge1xuICAgIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicpIHRocm93IEVycm9yKCdmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG51bWJlciBvZiBtYXRjaGVzJyk7XG4gICAgaWYgKCh0eXBlb2YgY2xhc3NOYW1lICE9PSAnZnVuY3Rpb24nKSB8fCAhKCdpc0dhbWVFbGVtZW50JyBpbiBjbGFzc05hbWUpKSB7XG4gICAgICBpZiAoY2xhc3NOYW1lKSBmaW5kZXJzID0gW2NsYXNzTmFtZSwgLi4uZmluZGVyc107XG4gICAgICByZXR1cm4gdGhpcy5fZmluZGVyPEdhbWVFbGVtZW50Pih1bmRlZmluZWQsIHtsaW1pdDogbiwgb3JkZXI6ICdkZXNjJ30sIC4uLmZpbmRlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZmluZGVyKGNsYXNzTmFtZSwge2xpbWl0OiBuLCBvcmRlcjogJ2Rlc2MnfSwgLi4uZmluZGVycyk7XG4gIH1cblxuICAvKipcbiAgICogQWxpYXMgZm9yIHtAbGluayBmaXJzdH1cbiAgICogQGNhdGVnb3J5IFF1ZXJpZXNcbiAgICovXG4gIHRvcDxGIGV4dGVuZHMgR2FtZUVsZW1lbnQ+KGNsYXNzTmFtZTogRWxlbWVudENsYXNzPEY+LCAuLi5maW5kZXJzOiBFbGVtZW50RmluZGVyPEY+W10pOiBGIHwgdW5kZWZpbmVkO1xuICB0b3AoY2xhc3NOYW1lPzogRWxlbWVudEZpbmRlciwgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcltdKTogVCB8IHVuZGVmaW5lZDtcbiAgdG9wKGNsYXNzTmFtZT86IEVsZW1lbnRGaW5kZXIgfCBFbGVtZW50Q2xhc3MsIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXJbXSk6IEdhbWVFbGVtZW50IHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoKHR5cGVvZiBjbGFzc05hbWUgIT09ICdmdW5jdGlvbicpIHx8ICEoJ2lzR2FtZUVsZW1lbnQnIGluIGNsYXNzTmFtZSkpIHtcbiAgICAgIGlmIChjbGFzc05hbWUpIGZpbmRlcnMgPSBbY2xhc3NOYW1lLCAuLi5maW5kZXJzXTtcbiAgICAgIHJldHVybiB0aGlzLl9maW5kZXI8R2FtZUVsZW1lbnQ+KHVuZGVmaW5lZCwge2xpbWl0OiAxfSwgLi4uZmluZGVycylbMF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9maW5kZXIoY2xhc3NOYW1lLCB7bGltaXQ6IDF9LCAuLi5maW5kZXJzKVswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3Ige0BsaW5rIGZpcnN0Tn1cbiAgICogQGNhdGVnb3J5IFF1ZXJpZXNcbiAgICovXG4gIHRvcE48RiBleHRlbmRzIEdhbWVFbGVtZW50PihuOiBudW1iZXIsIGNsYXNzTmFtZTogRWxlbWVudENsYXNzPEY+LCAuLi5maW5kZXJzOiBFbGVtZW50RmluZGVyPEY+W10pOiBFbGVtZW50Q29sbGVjdGlvbjxGPjtcbiAgdG9wTihuOiBudW1iZXIsIGNsYXNzTmFtZT86IEVsZW1lbnRGaW5kZXIsIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXJbXSk6IEVsZW1lbnRDb2xsZWN0aW9uPFQ+O1xuICB0b3BOKG46IG51bWJlciwgY2xhc3NOYW1lPzogRWxlbWVudEZpbmRlciB8IEVsZW1lbnRDbGFzcywgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcltdKTogRWxlbWVudENvbGxlY3Rpb248YW55PiB7XG4gICAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJykgdGhyb3cgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgbnVtYmVyIG9mIG1hdGNoZXMnKTtcbiAgICBpZiAoKHR5cGVvZiBjbGFzc05hbWUgIT09ICdmdW5jdGlvbicpIHx8ICEoJ2lzR2FtZUVsZW1lbnQnIGluIGNsYXNzTmFtZSkpIHtcbiAgICAgIGlmIChjbGFzc05hbWUpIGZpbmRlcnMgPSBbY2xhc3NOYW1lLCAuLi5maW5kZXJzXTtcbiAgICAgIHJldHVybiB0aGlzLl9maW5kZXI8R2FtZUVsZW1lbnQ+KHVuZGVmaW5lZCwge2xpbWl0OiBufSwgLi4uZmluZGVycyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9maW5kZXIoY2xhc3NOYW1lLCB7bGltaXQ6IG59LCAuLi5maW5kZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3Ige0BsaW5rIGxhc3R9XG4gICAqIEBjYXRlZ29yeSBRdWVyaWVzXG4gICAqL1xuICBib3R0b208RiBleHRlbmRzIEdhbWVFbGVtZW50PihjbGFzc05hbWU6IEVsZW1lbnRDbGFzczxGPiwgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcjxGPltdKTogRiB8IHVuZGVmaW5lZDtcbiAgYm90dG9tKGNsYXNzTmFtZT86IEVsZW1lbnRGaW5kZXIsIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXJbXSk6IFQgfCB1bmRlZmluZWQ7XG4gIGJvdHRvbShjbGFzc05hbWU/OiBFbGVtZW50RmluZGVyIHwgRWxlbWVudENsYXNzLCAuLi5maW5kZXJzOiBFbGVtZW50RmluZGVyW10pOiBHYW1lRWxlbWVudDxhbnk+IHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoKHR5cGVvZiBjbGFzc05hbWUgIT09ICdmdW5jdGlvbicpIHx8ICEoJ2lzR2FtZUVsZW1lbnQnIGluIGNsYXNzTmFtZSkpIHtcbiAgICAgIGlmIChjbGFzc05hbWUpIGZpbmRlcnMgPSBbY2xhc3NOYW1lLCAuLi5maW5kZXJzXTtcbiAgICAgIHJldHVybiB0aGlzLl9maW5kZXI8R2FtZUVsZW1lbnQ+KHVuZGVmaW5lZCwge2xpbWl0OiAxLCBvcmRlcjogJ2Rlc2MnfSwgLi4uZmluZGVycylbMF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9maW5kZXIoY2xhc3NOYW1lLCB7bGltaXQ6IDEsIG9yZGVyOiAnZGVzYyd9LCAuLi5maW5kZXJzKVswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3Ige0BsaW5rIGxhc3ROfVxuICAgKiBAY2F0ZWdvcnkgUXVlcmllc1xuICAgKi9cbiAgYm90dG9tTjxGIGV4dGVuZHMgR2FtZUVsZW1lbnQ+KG46IG51bWJlciwgY2xhc3NOYW1lOiBFbGVtZW50Q2xhc3M8Rj4sIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXI8Rj5bXSk6IEVsZW1lbnRDb2xsZWN0aW9uPEY+O1xuICBib3R0b21OKG46IG51bWJlciwgY2xhc3NOYW1lPzogRWxlbWVudEZpbmRlciwgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcltdKTogRWxlbWVudENvbGxlY3Rpb248VD47XG4gIGJvdHRvbU4objogbnVtYmVyLCBjbGFzc05hbWU/OiBFbGVtZW50RmluZGVyIHwgRWxlbWVudENsYXNzLCAuLi5maW5kZXJzOiBFbGVtZW50RmluZGVyW10pOiBFbGVtZW50Q29sbGVjdGlvbjxhbnk+IHtcbiAgICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInKSB0aHJvdyBFcnJvcignZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBudW1iZXIgb2YgbWF0Y2hlcycpO1xuICAgIGlmICgodHlwZW9mIGNsYXNzTmFtZSAhPT0gJ2Z1bmN0aW9uJykgfHwgISgnaXNHYW1lRWxlbWVudCcgaW4gY2xhc3NOYW1lKSkge1xuICAgICAgaWYgKGNsYXNzTmFtZSkgZmluZGVycyA9IFtjbGFzc05hbWUsIC4uLmZpbmRlcnNdO1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRlcjxHYW1lRWxlbWVudD4odW5kZWZpbmVkLCB7bGltaXQ6IG4sIG9yZGVyOiAnZGVzYyd9LCAuLi5maW5kZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRlcihjbGFzc05hbWUsIHtsaW1pdDogbiwgb3JkZXI6ICdkZXNjJ30sIC4uLmZpbmRlcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3cgdGhlc2UgZWxlbWVudHMgdG8gYWxsIHBsYXllcnNcbiAgICogQGNhdGVnb3J5IFZpc2liaWxpdHlcbiAgICovXG4gIHNob3dUb0FsbCh0aGlzOiBFbGVtZW50Q29sbGVjdGlvbjxQaWVjZTxCYXNlR2FtZT4+KSB7XG4gICAgZm9yIChjb25zdCBlbCBvZiB0aGlzKSB7XG4gICAgICBkZWxldGUoZWwuX3Zpc2libGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93IHRoZXNlIGVsZW1lbnRzIG9ubHkgdG8gdGhlIGdpdmVuIHBsYXllclxuICAgKiBAY2F0ZWdvcnkgVmlzaWJpbGl0eVxuICAgKi9cbiAgc2hvd09ubHlUbyh0aGlzOiBFbGVtZW50Q29sbGVjdGlvbjxQaWVjZTxCYXNlR2FtZT4+LCBwbGF5ZXI6IFBsYXllciB8IG51bWJlcikge1xuICAgIGlmICh0eXBlb2YgcGxheWVyICE9PSAnbnVtYmVyJykgcGxheWVyID0gcGxheWVyLnBvc2l0aW9uO1xuICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcykge1xuICAgICAgZWwuX3Zpc2libGUgPSB7XG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBleGNlcHQ6IFtwbGF5ZXJdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93IHRoZXNlIGVsZW1lbnRzIHRvIHRoZSBnaXZlbiBwbGF5ZXJzIHdpdGhvdXQgY2hhbmdpbmcgaXQncyB2aXNpYmlsaXR5IHRvXG4gICAqIGFueSBvdGhlciBwbGF5ZXJzLlxuICAgKiBAY2F0ZWdvcnkgVmlzaWJpbGl0eVxuICAgKi9cbiAgc2hvd1RvKHRoaXM6IEVsZW1lbnRDb2xsZWN0aW9uPFBpZWNlPEJhc2VHYW1lPj4sIC4uLnBsYXllcjogUGxheWVyW10gfCBudW1iZXJbXSkge1xuICAgIGlmICh0eXBlb2YgcGxheWVyWzBdICE9PSAnbnVtYmVyJykgcGxheWVyID0gKHBsYXllciBhcyBQbGF5ZXJbXSkubWFwKHAgPT4gcC5wb3NpdGlvbik7XG4gICAgZm9yIChjb25zdCBlbCBvZiB0aGlzKSB7XG4gICAgICBpZiAoZWwuX3Zpc2libGUgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgICBpZiAoZWwuX3Zpc2libGUuZGVmYXVsdCkge1xuICAgICAgICBpZiAoIWVsLl92aXNpYmxlLmV4Y2VwdCkgY29udGludWU7XG4gICAgICAgIGVsLl92aXNpYmxlLmV4Y2VwdCA9IGVsLl92aXNpYmxlLmV4Y2VwdC5maWx0ZXIoaSA9PiAhKHBsYXllciBhcyBudW1iZXJbXSkuaW5jbHVkZXMoaSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuX3Zpc2libGUuZXhjZXB0ID0gQXJyYXkuZnJvbShuZXcgU2V0KFsuLi4oZWwuX3Zpc2libGUuZXhjZXB0IGluc3RhbmNlb2YgQXJyYXkgPyBlbC5fdmlzaWJsZS5leGNlcHQgOiBbXSksIC4uLihwbGF5ZXIgYXMgbnVtYmVyW10pXSkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhpcyBlbGVtZW50IGZyb20gYWxsIHBsYXllcnNcbiAgICogQGNhdGVnb3J5IFZpc2liaWxpdHlcbiAgICovXG4gIGhpZGVGcm9tQWxsKHRoaXM6IEVsZW1lbnRDb2xsZWN0aW9uPFBpZWNlPEJhc2VHYW1lPj4pIHtcbiAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMpIHtcbiAgICAgIGVsLl92aXNpYmxlID0ge2RlZmF1bHQ6IGZhbHNlfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGlkZSB0aGVzZSBlbGVtZW50cyBmcm9tIHRoZSBnaXZlbiBwbGF5ZXJzIHdpdGhvdXQgY2hhbmdpbmcgaXQncyB2aXNpYmlsaXR5IHRvXG4gICAqIGFueSBvdGhlciBwbGF5ZXJzLlxuICAgKiBAY2F0ZWdvcnkgVmlzaWJpbGl0eVxuICAgKi9cbiAgaGlkZUZyb20odGhpczogRWxlbWVudENvbGxlY3Rpb248UGllY2U8QmFzZUdhbWU+PiwgLi4ucGxheWVyOiBQbGF5ZXJbXSB8IG51bWJlcltdKSB7XG4gICAgaWYgKHR5cGVvZiBwbGF5ZXJbMF0gIT09ICdudW1iZXInKSBwbGF5ZXIgPSAocGxheWVyIGFzIFBsYXllcltdKS5tYXAocCA9PiBwLnBvc2l0aW9uKTtcbiAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMpIHtcbiAgICAgIGlmIChlbC5fdmlzaWJsZT8uZGVmYXVsdCA9PT0gZmFsc2UgJiYgIWVsLl92aXNpYmxlLmV4Y2VwdCkgY29udGludWU7XG4gICAgICBpZiAoZWwuX3Zpc2libGUgPT09IHVuZGVmaW5lZCB8fCBlbC5fdmlzaWJsZS5kZWZhdWx0ID09PSB0cnVlKSB7XG4gICAgICAgIGVsLl92aXNpYmxlID0ge1xuICAgICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgICAgZXhjZXB0OiBBcnJheS5mcm9tKG5ldyBTZXQoWy4uLihlbC5fdmlzaWJsZT8uZXhjZXB0IGluc3RhbmNlb2YgQXJyYXkgPyBlbC5fdmlzaWJsZS5leGNlcHQgOiBbXSksIC4uLihwbGF5ZXIgYXMgbnVtYmVyW10pXSkpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWVsLl92aXNpYmxlLmV4Y2VwdCkgY29udGludWU7XG4gICAgICAgIGVsLl92aXNpYmxlLmV4Y2VwdCA9IGVsLl92aXNpYmxlLmV4Y2VwdC5maWx0ZXIoaSA9PiAhKHBsYXllciBhcyBudW1iZXJbXSkuaW5jbHVkZXMoaSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0cyB0aGlzIGNvbGxlY3Rpb24gYnkgc29tZSB7QGxpbmsgU29ydGVyfS5cbiAgICogQGNhdGVnb3J5IFN0cnVjdHVyZVxuICAgKi9cbiAgc29ydEJ5PEUgZXh0ZW5kcyBUPihrZXk6IFNvcnRlcjxFPiB8IFNvcnRlcjxFPltdLCBkaXJlY3Rpb24/OiBcImFzY1wiIHwgXCJkZXNjXCIpIHtcbiAgICBjb25zdCByYW5rID0gKGU6IEUsIGs6IFNvcnRlcjxFPikgPT4gdHlwZW9mIGsgPT09ICdmdW5jdGlvbicgPyBrKGUpIDogZVtrIGFzIGtleW9mIEVdXG4gICAgY29uc3QgW3VwLCBkb3duXSA9IGRpcmVjdGlvbiA9PT0gJ2Rlc2MnID8gWy0xLCAxXSA6IFsxLCAtMV07XG4gICAgcmV0dXJuIHRoaXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3Qga2V5cyA9IGtleSBpbnN0YW5jZW9mIEFycmF5ID8ga2V5IDogW2tleV07XG4gICAgICBmb3IgKGNvbnN0IGsgb2Yga2V5cykge1xuICAgICAgICBjb25zdCByMSA9IHJhbmsoYSBhcyBFLCBrKTtcbiAgICAgICAgY29uc3QgcjIgPSByYW5rKGIgYXMgRSwgayk7XG4gICAgICAgIGlmIChyMSA+IHIyKSByZXR1cm4gdXA7XG4gICAgICAgIGlmIChyMSA8IHIyKSByZXR1cm4gZG93bjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgY29sbGVjdGlvbiBzb3J0ZWQgYnkgc29tZSB7QGxpbmsgU29ydGVyfS5cbiAgICogQGNhdGVnb3J5IFN0cnVjdHVyZVxuICAgKi9cbiAgc29ydGVkQnkoa2V5OiBTb3J0ZXI8VD4gfCAoU29ydGVyPFQ+KVtdLCBkaXJlY3Rpb246IFwiYXNjXCIgfCBcImRlc2NcIiA9IFwiYXNjXCIpIHtcbiAgICByZXR1cm4gKHRoaXMuc2xpY2UoMCwgdGhpcy5sZW5ndGgpIGFzIHRoaXMpLnNvcnRCeShrZXksIGRpcmVjdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3VtIG9mIGFsbCBlbGVtZW50cyBpbiB0aGlzIGNvbGxlY3Rpb24gbWVhc3VyZWQgYnkgYSBwcm92aWRlZCBrZXlcbiAgICogQGNhdGVnb3J5IFF1ZXJpZXNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZGVjay5jcmVhdGUoQ2FyZCwgJzInLCB7IHBpcHM6IDIgfSk7XG4gICAqIGRlY2suY3JlYXRlKENhcmQsICczJywgeyBwaXBzOiAzIH0pO1xuICAgKiBkZWNrLmFsbChDYXJkKS5zdW0oJ3BpcHMnKTsgLy8gPT4gNVxuICAgKi9cbiAgc3VtKGtleTogKChlOiBUKSA9PiBudW1iZXIpIHwgKGtleW9mIHtbSyBpbiBrZXlvZiBUXTogVFtLXSBleHRlbmRzIG51bWJlciA/IG5ldmVyOiBLfSkpIHtcbiAgICByZXR1cm4gdGhpcy5yZWR1Y2UoKHN1bSwgbikgPT4gc3VtICsgKHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicgPyBrZXkobikgOiBuW2tleV0gYXMgdW5rbm93biBhcyBudW1iZXIpLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IGluIHRoaXMgY29sbGVjdGlvbiB3aXRoIHRoZSBoaWdoZXN0IHZhbHVlIG9mIHRoZVxuICAgKiBwcm92aWRlZCBrZXkocykuXG4gICAqIEBjYXRlZ29yeSBRdWVyaWVzXG4gICAqXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVzIC0gYW55IG51bWJlciBvZiB7QGxpbmsgU29ydGVyIHwgU29ydGVyJ3N9IHVzZWQgZm9yXG4gICAqIGNvbXBhcmluZy4gSWYgbXVsdGlwbGUgYXJlIHByb3ZpZGVkLCBzdWJzZXF1ZW50IG9uZXMgYXJlIHVzZWQgdG8gYnJlYWsgdGllc1xuICAgKiBvbiBlYXJsaWVyIG9uZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGFybXkuY3JlYXRlKFNvbGRpZXIsICdhJywgeyBzdHJlbmd0aDogMiwgaW5pdGlhdGl2ZTogMyB9KTtcbiAgICogYXJteS5jcmVhdGUoU29sZGllciwgJ2InLCB7IHN0cmVuZ3RoOiAzLCBpbml0aWF0aXZlOiAxIH0pO1xuICAgKiBhcm15LmNyZWF0ZShTb2xkaWVyLCAnYycsIHsgc3RyZW5ndGg6IDMsIGluaXRpYXRpdmU6IDIgfSk7XG4gICAqIGFybXkuYWxsKFNvbGlkZXIpLndpdGhIaWdoZXN0KCdzdHJlbmd0aCcsICdpbml0aWF0aXZlJyk7IC8vID0+IFNvbGRpZXIgJ2MnXG4gICAqL1xuICB3aXRoSGlnaGVzdCguLi5hdHRyaWJ1dGVzOiBTb3J0ZXI8VD5bXSk6IFQgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnNvcnRlZEJ5KGF0dHJpYnV0ZXMsICdkZXNjJylbMF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWxlbWVudCBpbiB0aGlzIGNvbGxlY3Rpb24gd2l0aCB0aGUgbG93ZXN0IHZhbHVlIG9mIHRoZVxuICAgKiBwcm92aWRlZCBrZXkocykuXG4gICAqIEBjYXRlZ29yeSBRdWVyaWVzXG4gICAqXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVzIC0gYW55IG51bWJlciBvZiB7QGxpbmsgU29ydGVyIHwgU29ydGVyJ3N9IHVzZWQgZm9yXG4gICAqIGNvbXBhcmluZy4gSWYgbXVsdGlwbGUgYXJlIHByb3ZpZGVkLCBzdWJzZXF1ZW50IG9uZXMgYXJlIHVzZWQgdG8gYnJlYWsgdGllc1xuICAgKiBvbiBlYXJsaWVyIG9uZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGFybXkuY3JlYXRlKFNvbGRpZXIsICdhJywgeyBzdHJlbmd0aDogMiwgaW5pdGlhdGl2ZTogMyB9KTtcbiAgICogYXJteS5jcmVhdGUoU29sZGllciwgJ2InLCB7IHN0cmVuZ3RoOiAzLCBpbml0aWF0aXZlOiAxIH0pO1xuICAgKiBhcm15LmNyZWF0ZShTb2xkaWVyLCAnYycsIHsgc3RyZW5ndGg6IDIsIGluaXRpYXRpdmU6IDIgfSk7XG4gICAqIGFybXkuYWxsKFNvbGlkZXIpLndpdGhMb3dlc3QoJ3N0cmVuZ3RoJywgJ2luaXRpYXRpdmUnKTsgLy8gPT4gU29sZGllciAnYydcbiAgICovXG4gIHdpdGhMb3dlc3QoLi4uYXR0cmlidXRlczogU29ydGVyPFQ+W10pOiBUIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5zb3J0ZWRCeShhdHRyaWJ1dGVzLCAnYXNjJylbMF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlnaGVzdCB2YWx1ZSBvZiB0aGUgcHJvdmlkZWQga2V5KHMpIGZvdW5kIG9uIGFueSBlbGVtZW50IGluXG4gICAqIHRoaXMgY29sbGVjdGlvbi5cbiAgICogQGNhdGVnb3J5IFF1ZXJpZXNcbiAgICpcbiAgICogQHBhcmFtIGtleSAtIGEge0BsaW5rIFNvcnRlciB8IFNvcnRlcidzfSB1c2VkIGZvciBjb21wYXJpbmcgYW5kIGV4dHJhY3RpbmdcbiAgICogdGhlIG1heC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYXJteS5jcmVhdGUoU29sZGllciwgJ2EnLCB7IHN0cmVuZ3RoOiAyLCBpbml0aWF0aXZlOiAzIH0pO1xuICAgKiBhcm15LmNyZWF0ZShTb2xkaWVyLCAnYicsIHsgc3RyZW5ndGg6IDMsIGluaXRpYXRpdmU6IDEgfSk7XG4gICAqIGFybXkuY3JlYXRlKFNvbGRpZXIsICdjJywgeyBzdHJlbmd0aDogMiwgaW5pdGlhdGl2ZTogMiB9KTtcbiAgICogYXJteS5hbGwoU29saWRlcikubWF4KCdzdHJlbmd0aCcpOyAvLyA9PiAzXG4gICAqL1xuICBtYXg8SyBleHRlbmRzIG51bWJlciB8IHN0cmluZz4oa2V5OiB7W0syIGluIGtleW9mIFRdOiBUW0syXSBleHRlbmRzIEsgPyBLMiA6IG5ldmVyfVtrZXlvZiBUXSB8ICgodDogVCkgPT4gSykpOiBLIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuc29ydGVkQnkoa2V5LCAnZGVzYycpWzBdO1xuICAgIGlmICghZWwpIHJldHVybjtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJyA/IGtleShlbCkgOiBlbFtrZXldIGFzIEs7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbG93ZXN0IHZhbHVlIG9mIHRoZSBwcm92aWRlZCBrZXkocykgZm91bmQgb24gYW55IGVsZW1lbnQgaW5cbiAgICogdGhpcyBjb2xsZWN0aW9uLlxuICAgKiBAY2F0ZWdvcnkgUXVlcmllc1xuICAgKlxuICAgKiBAcGFyYW0ga2V5IC0gYSB7QGxpbmsgU29ydGVyIHwgU29ydGVyJ3N9IHVzZWQgZm9yIGNvbXBhcmluZyBhbmQgZXh0cmFjdGluZ1xuICAgKiB0aGUgbWluaW11bS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYXJteS5jcmVhdGUoU29sZGllciwgJ2EnLCB7IHN0cmVuZ3RoOiAyLCBpbml0aWF0aXZlOiAzIH0pO1xuICAgKiBhcm15LmNyZWF0ZShTb2xkaWVyLCAnYicsIHsgc3RyZW5ndGg6IDMsIGluaXRpYXRpdmU6IDEgfSk7XG4gICAqIGFybXkuY3JlYXRlKFNvbGRpZXIsICdjJywgeyBzdHJlbmd0aDogMiwgaW5pdGlhdGl2ZTogMiB9KTtcbiAgICogYXJteS5hbGwoU29saWRlcikubWluKCdpbml0aWF0aXZlJyk7IC8vID0+IDFcbiAgICovXG4gIG1pbjxLIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nPihrZXk6IHtbSzIgaW4ga2V5b2YgVF06IFRbSzJdIGV4dGVuZHMgSyA/IEsyIDogbmV2ZXJ9W2tleW9mIFRdIHwgKCh0OiBUKSA9PiBLKSk6IEsgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGVsID0gdGhpcy5zb3J0ZWRCeShrZXksICdhc2MnKVswXVxuICAgIGlmICghZWwpIHJldHVybjtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJyA/IGtleShlbCkgOiBlbFtrZXldIGFzIEs7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIGFsbCBlbGVtZW50cyBpbiB0aGlzIGNvbGxlY3Rpb24gaGF2ZSB0aGUgc2FtZSB2YWx1ZSBmb3Iga2V5LlxuICAgKiBAY2F0ZWdvcnkgUXVlcmllc1xuICAgKi9cbiAgYXJlQWxsRXF1YWwoa2V5OiBrZXlvZiBUKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5ldmVyeShlbCA9PiBlbFtrZXldID09PSB0aGlzWzBdW2tleV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgZWxlbWVudHMgaW4gdGhpcyBjb2xsZWN0aW9uIGZyb20gdGhlIHBsYXlpbmcgYXJlYSBhbmQgcGxhY2UgdGhlbVxuICAgKiBpbnRvIHtAbGluayBHYW1lI3BpbGV9XG4gICAqIEBjYXRlZ29yeSBTdHJ1Y3R1cmVcbiAgICovXG4gIHJlbW92ZSgpIHtcbiAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMpIHtcbiAgICAgIGlmICgnaXNTcGFjZScgaW4gZWwpIHRocm93IEVycm9yKCdjYW5ub3QgbW92ZSBTcGFjZScpO1xuICAgICAgKGVsIGFzIHVua25vd24gYXMgUGllY2U8R2FtZT4pLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIGFsbCBwaWVjZXMgaW4gdGhpcyBjb2xsZWN0aW9uIGludG8gYW5vdGhlciBlbGVtZW50LiBTZWUge0BsaW5rIFBpZWNlI3B1dEludG99LlxuICAgKiBAY2F0ZWdvcnkgU3RydWN0dXJlXG4gICAqL1xuICBwdXRJbnRvKHRvOiBHYW1lRWxlbWVudCwgb3B0aW9ucz86IHtwb3NpdGlvbj86IG51bWJlciwgZnJvbVRvcD86IG51bWJlciwgZnJvbUJvdHRvbT86IG51bWJlcn0pIHtcbiAgICBpZiAodGhpcy5zb21lKGVsID0+IGVsLmhhc01vdmVkKCkpIHx8IHRvLmhhc01vdmVkKCkpIHRvLmdhbWUuYWRkRGVsYXkoKTtcbiAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMpIHtcbiAgICAgIGlmICgnaXNTcGFjZScgaW4gZWwpIHRocm93IEVycm9yKCdjYW5ub3QgbW92ZSBTcGFjZScpO1xuICAgICAgKGVsIGFzIHVua25vd24gYXMgUGllY2U8R2FtZT4pLnB1dEludG8odG8sIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVJXG5cbiAgLyoqXG4gICAqIEFwcGx5IGEgbGF5b3V0IHRvIHNvbWUgb2YgdGhlIGVsZW1lbnRzIGRpcmVjdGx5IGNvbnRhaW5lZCB3aXRoaW4gdGhlIGVsZW1lbnRzXG4gICAqIGluIHRoaXMgY29sbGVjdGlvbi4gU2VlIHtAbGluayBHYW1lRWxlbWVudCNsYXlvdXR9XG4gICAqIEBjYXRlZ29yeSBVSVxuICAgKi9cbiAgbGF5b3V0KFxuICAgIGFwcGx5VG86IFRbJ191aSddWydsYXlvdXRzJ11bbnVtYmVyXVsnYXBwbHlUbyddLFxuICAgIGF0dHJpYnV0ZXM6IFBhcnRpYWw8R2FtZUVsZW1lbnRbJ191aSddWydsYXlvdXRzJ11bbnVtYmVyXVsnYXR0cmlidXRlcyddPlxuICApIHtcbiAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMpIGVsLmxheW91dChhcHBseVRvLCBhdHRyaWJ1dGVzKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZSB0aGUgbGF5b3V0IGZvciBhbGwgZWxlbWVudHMgY29udGFpbmVkIHdpdGhpbiB0aGlzIGNvbGxlY3Rpb24uIFNlZVxuICAgKiB7QGxpbmsgR2FtZUVsZW1lbnQjY29uZmlndXJlTGF5b3V0fVxuICAgKiBAY2F0ZWdvcnkgVUlcbiAgICovXG4gIGNvbmZpZ3VyZUxheW91dChcbiAgICBhdHRyaWJ1dGVzOiBQYXJ0aWFsPEdhbWVFbGVtZW50WydfdWknXVsnbGF5b3V0cyddW251bWJlcl1bJ2F0dHJpYnV0ZXMnXT5cbiAgKSB7XG4gICAgZm9yIChjb25zdCBlbCBvZiB0aGlzKSBlbC5jb25maWd1cmVMYXlvdXQoYXR0cmlidXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBlbGVtZW50cyBpbiB0aGlzIGNvbGxlY3Rpb24uIEFueSB2YWx1ZXNcbiAgICogcHJvdmlkZWQgb3ZlcnJpZGUgcHJldmlvdXMgb25lcy4gU2VlIHtAbGluayBHYW1lRWxlbWVudCNhcHBlYXJhbmNlfS5cbiAgICogQGNhdGVnb3J5IFVJXG4gICAqL1xuICBhcHBlYXJhbmNlKGFwcGVhcmFuY2U6IEVsZW1lbnRVSTxUPlsnYXBwZWFyYW5jZSddKSB7XG4gICAgZm9yIChjb25zdCBlbCBvZiB0aGlzKSBlbC5hcHBlYXJhbmNlKGFwcGVhcmFuY2UpO1xuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBBcmd1bWVudCwgU2luZ2xlQXJndW1lbnQgfSBmcm9tICcuL2FjdGlvbi5qcyc7XG5pbXBvcnQgdHlwZSB7IFBsYXllciB9IGZyb20gJy4uL3BsYXllci9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7IEJhc2VHYW1lIH0gZnJvbSAnLi4vYm9hcmQvZ2FtZS5qcyc7XG5pbXBvcnQgdHlwZSBHYW1lRWxlbWVudCBmcm9tICcuLi9ib2FyZC9lbGVtZW50LmpzJztcblxuZXhwb3J0IHR5cGUgU2VyaWFsaXplZFNpbmdsZUFyZyA9IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW47XG5leHBvcnQgdHlwZSBTZXJpYWxpemVkQXJnID0gU2VyaWFsaXplZFNpbmdsZUFyZyB8IFNlcmlhbGl6ZWRTaW5nbGVBcmdbXTtcbmV4cG9ydCB0eXBlIFNlcmlhbGl6YWJsZSA9IFNpbmdsZUFyZ3VtZW50IHwgbnVsbCB8IHVuZGVmaW5lZCB8IFNlcmlhbGl6YWJsZVtdIHwgeyBba2V5OiBzdHJpbmddOiBTZXJpYWxpemFibGUgfTtcblxuZXhwb3J0IGNvbnN0IHNlcmlhbGl6ZSA9IChhcmc6IFNlcmlhbGl6YWJsZSwgZm9yUGxheWVyPXRydWUsIG5hbWU/OiBzdHJpbmcpOiBhbnkgPT4ge1xuICBpZiAoYXJnID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmIChhcmcgPT09IG51bGwpIHJldHVybiBudWxsO1xuICBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBhcmcubWFwKGEgPT4gc2VyaWFsaXplKGEsIGZvclBsYXllcikpO1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgJ2NvbnN0cnVjdG9yJyBpbiBhcmcgJiYgKCdpc1BsYXllcicgaW4gYXJnLmNvbnN0cnVjdG9yIHx8ICdpc0dhbWVFbGVtZW50JyBpbiBhcmcuY29uc3RydWN0b3IpKSB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZVNpbmdsZUFyZyhhcmcgYXMgR2FtZUVsZW1lbnQgfCBQbGF5ZXIsIGZvclBsYXllcik7XG4gIH1cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSByZXR1cm4gc2VyaWFsaXplT2JqZWN0KGFyZywgZm9yUGxheWVyKTtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8IHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBhcmcgPT09ICdib29sZWFuJykgcmV0dXJuIHNlcmlhbGl6ZVNpbmdsZUFyZyhhcmcsIGZvclBsYXllcik7XG4gIHRocm93IEVycm9yKGBVbmFibGUgdG8gc2VyaWFsaXplIHRoZSBwcm9wZXJ0eSAke25hbWUgPyAnXCInICsgbmFtZSArICdcIjogJyA6ICcnfSAke2FyZ30uIE9ubHkgcHJpbWl0aXZlcywgUGxheWVyJ3MsIEdhbWVFbGVtZW50J3Mgb3IgYXJyYXlzL29iamVjdHMgY29udGFpbmluZyBzdWNoIGNhbiBiZSB1c2VkLmApO1xufVxuXG5leHBvcnQgY29uc3Qgc2VyaWFsaXplQXJnID0gKGFyZzogQXJndW1lbnQsIGZvclBsYXllcj10cnVlKTogU2VyaWFsaXplZEFyZyA9PiB7XG4gIGlmIChhcmcgaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIGFyZy5tYXAoYSA9PiBzZXJpYWxpemVTaW5nbGVBcmcoYSwgZm9yUGxheWVyKSk7XG4gIHJldHVybiBzZXJpYWxpemVTaW5nbGVBcmcoYXJnLCBmb3JQbGF5ZXIpO1xufVxuXG5leHBvcnQgY29uc3Qgc2VyaWFsaXplU2luZ2xlQXJnID0gKGFyZzogU2luZ2xlQXJndW1lbnQsIGZvclBsYXllcj10cnVlKTogU2VyaWFsaXplZFNpbmdsZUFyZyA9PiB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAnY29uc3RydWN0b3InIGluIGFyZykge1xuICAgIGlmICgnaXNQbGF5ZXInIGluIGFyZy5jb25zdHJ1Y3RvcikgcmV0dXJuIGAkcFskeyhhcmcgYXMgUGxheWVyKS5wb3NpdGlvbn1dYDtcbiAgICBpZiAoJ2lzR2FtZUVsZW1lbnQnIGluIGFyZy5jb25zdHJ1Y3RvcikgcmV0dXJuIGZvclBsYXllciA/IGAkZWxbJHsoYXJnIGFzIEdhbWVFbGVtZW50KS5icmFuY2goKX1dYCA6IGAkZWlkWyR7KGFyZyBhcyBHYW1lRWxlbWVudCkuX3QuaWR9XWA7XG4gIH1cbiAgcmV0dXJuIGFyZyBhcyBTZXJpYWxpemVkU2luZ2xlQXJnO1xufVxuXG5leHBvcnQgY29uc3Qgc2VyaWFsaXplT2JqZWN0ID0gKG9iajogUmVjb3JkPHN0cmluZywgYW55PiwgZm9yUGxheWVyPXRydWUpID0+IHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhvYmopLm1hcCgoW2ssIHZdKSA9PiBbaywgc2VyaWFsaXplKHYsIGZvclBsYXllciwgayldKSk7XG59XG5cbmV4cG9ydCBjb25zdCBlc2NhcGVBcmd1bWVudCA9IChhcmc6IEFyZ3VtZW50KTogc3RyaW5nID0+IHtcbiAgaWYgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgY29uc3QgZXNjYXBlZXMgPSBhcmcubWFwKGVzY2FwZUFyZ3VtZW50KTtcbiAgICByZXR1cm4gZXNjYXBlZXMuc2xpY2UoMCwgLTEpLmpvaW4oJywgJykgKyAoZXNjYXBlZXMubGVuZ3RoID4gMSA/ICcgYW5kICcgOiAnJykgKyAoZXNjYXBlZXNbZXNjYXBlZXMubGVuZ3RoIC0gMV0gfHwgJycpO1xuICB9XG4gIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JykgcmV0dXJuIGBbWyR7c2VyaWFsaXplU2luZ2xlQXJnKGFyZyl9fCR7YXJnLnRvU3RyaW5nKCl9XV1gO1xuICByZXR1cm4gU3RyaW5nKGFyZyk7XG59XG5cbmV4cG9ydCBjb25zdCBkZXNlcmlhbGl6ZUFyZyA9IChhcmc6IFNlcmlhbGl6ZWRBcmcsIGdhbWU6IEJhc2VHYW1lKTogQXJndW1lbnQgPT4ge1xuICBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBhcmcubWFwKGEgPT4gZGVzZXJpYWxpemVTaW5nbGVBcmcoYSwgZ2FtZSkpIGFzIEdhbWVFbGVtZW50W107XG4gIHJldHVybiBkZXNlcmlhbGl6ZVNpbmdsZUFyZyhhcmcsIGdhbWUpO1xufVxuXG5leHBvcnQgY29uc3QgZGVzZXJpYWxpemVTaW5nbGVBcmcgPSAoYXJnOiBTZXJpYWxpemVkU2luZ2xlQXJnLCBnYW1lOiBCYXNlR2FtZSk6IFNpbmdsZUFyZ3VtZW50ID0+IHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8IHR5cGVvZiBhcmcgPT09ICdib29sZWFuJykgcmV0dXJuIGFyZztcbiAgbGV0IGRlc2VyOiBTaW5nbGVBcmd1bWVudCB8IHVuZGVmaW5lZDtcbiAgaWYgKGFyZy5zbGljZSgwLCAzKSA9PT0gJyRwWycpIHtcbiAgICBkZXNlciA9IGdhbWUucGxheWVycy5hdFBvc2l0aW9uKHBhcnNlSW50KGFyZy5zbGljZSgzLCAtMSkpKTtcbiAgfSBlbHNlIGlmIChhcmcuc2xpY2UoMCwgNCkgPT09ICckZWxbJykge1xuICAgIGRlc2VyID0gZ2FtZS5hdEJyYW5jaChhcmcuc2xpY2UoNCwgLTEpKTtcbiAgfSBlbHNlIGlmIChhcmcuc2xpY2UoMCwgNSkgPT09ICckZWlkWycpIHtcbiAgICBkZXNlciA9IGdhbWUuYXRJRChwYXJzZUludChhcmcuc2xpY2UoNSwgLTEpKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfVxuICBpZiAoIWRlc2VyKSB0aHJvdyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgYXJnOiAke2FyZ31gKTtcbiAgcmV0dXJuIGRlc2VyO1xufVxuXG5leHBvcnQgY29uc3QgZGVzZXJpYWxpemVPYmplY3QgPSAob2JqOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBnYW1lOiBCYXNlR2FtZSkgPT4ge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG9iaikubWFwKChbaywgdl0pID0+IFtrLCBkZXNlcmlhbGl6ZSh2LCBnYW1lKV0pKTtcbn1cblxuZXhwb3J0IGNvbnN0IGRlc2VyaWFsaXplID0gKGFyZzogYW55LCBnYW1lOiBCYXNlR2FtZSk6IFNlcmlhbGl6YWJsZSA9PiB7XG4gIGlmIChhcmcgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKGFyZyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIGlmIChhcmcgaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIGFyZy5tYXAoYSA9PiBkZXNlcmlhbGl6ZShhLCBnYW1lKSk7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JykgcmV0dXJuIGRlc2VyaWFsaXplT2JqZWN0KGFyZywgZ2FtZSk7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicpIHJldHVybiBkZXNlcmlhbGl6ZVNpbmdsZUFyZyhhcmcsIGdhbWUpO1xuICB0aHJvdyBFcnJvcihgdW5hYmxlIHRvIGRlc2VyaWFsaXplICR7YXJnfWApO1xufVxuXG5leHBvcnQgY29uc3QgY29tYmluYXRpb25zID0gPFQ+KHNldDogVFtdLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBUW11bXSA9PiB7XG4gIGNvbnN0IGNvbWJvcyA9IFtdIGFzIFRbXVtdO1xuICBjb25zdCBwb3NzID0gKGN1cnI6IFRbXSwgaTogbnVtYmVyKSA9PiB7XG4gICAgaWYgKHNldC5sZW5ndGggLSBpIDwgbWluIC0gY3Vyci5sZW5ndGgpIHJldHVybjtcbiAgICBpZiAoY3Vyci5sZW5ndGggPj0gbWluKSBjb21ib3MucHVzaChjdXJyKTtcbiAgICBpZiAoY3Vyci5sZW5ndGggPCBtYXgpIHtcbiAgICAgIGZvciAobGV0IGogPSBpOyBqICE9PSBzZXQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcG9zcyhjdXJyLmNvbmNhdChbc2V0W2pdXSksIGogKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcG9zcyhbXSwgMCk7XG4gIHJldHVybiBjb21ib3M7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBBcmd1bWVudCB9IGZyb20gJy4vYWN0aW9uL2FjdGlvbi5qcyc7XG5pbXBvcnQgeyBlc2NhcGVBcmd1bWVudCB9IGZyb20gJy4vYWN0aW9uL3V0aWxzLmpzJztcblxuZXhwb3J0IGNvbnN0IHNodWZmbGVBcnJheSA9IChhcnJheTogYW55W10sIHJhbmRvbTogKCkgPT4gbnVtYmVyKSA9PiB7XG4gIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgY29uc3QgaiA9IE1hdGguZmxvb3IocmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICBbYXJyYXlbaV0sIGFycmF5W2pdXSA9IFthcnJheVtqXSwgYXJyYXlbaV1dO1xuICB9XG59XG5cbi8vIHVzYWdlIHRpbWVzKG1heCwgbiA9PiAuLi4pIGZyb20gMSB0byBtYXhcbmV4cG9ydCBjb25zdCB0aW1lcyA9IDxUPihuOiBudW1iZXIsIGZuOiAobjogbnVtYmVyKSA9PiBUKTogVFtdID0+IEFycmF5LmZyb20oQXJyYXkobikpLm1hcCgoXywgaSkgPT4gZm4oaSArIDEpKTtcbmV4cG9ydCBjb25zdCByYW5nZSA9IChtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIHN0ZXAgPSAxKSA9PiB0aW1lcyhNYXRoLmZsb29yKChtYXggLSBtaW4pIC8gc3RlcCkgKyAxLCBpID0+IChpIC0gMSkgKiBzdGVwICsgbWluKTtcblxuZXhwb3J0IGNvbnN0IG4gPSAobWVzc2FnZTogc3RyaW5nLCBhcmdzPzogUmVjb3JkPHN0cmluZywgQXJndW1lbnQ+LCBlc2NhcGVkOiBib29sZWFuID0gZmFsc2UpID0+IHtcbiAgT2JqZWN0LmVudHJpZXMoYXJncyB8fCB7fSkuZm9yRWFjaCgoW2ssIHZdKSA9PiB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShuZXcgUmVnRXhwKGBcXFxce1xcXFx7XFxcXHMqJHtrfVxcXFxzKlxcXFx9XFxcXH1gKSwgZXNjYXBlZCA/IGVzY2FwZUFyZ3VtZW50KHYpIDogdi50b1N0cmluZygpKTtcbiAgfSlcblxuICBjb25zdCBtaXNzaW5nQXJncyA9IEFycmF5LmZyb20obWVzc2FnZS5tYXRjaEFsbChuZXcgUmVnRXhwKGBcXFxce1xcXFx7XFxcXHMqKFxcXFx3KylcXFxccypcXFxcfVxcXFx9YCwgJ2cnKSkpLm1hcCgoWywgYXJnXSkgPT4gYXJnKTtcbiAgaWYgKG1pc3NpbmdBcmdzLmxlbmd0aCkgdGhyb3cgRXJyb3IoYE1pc3Npbmcgc3RyaW5ncyBpbjpcXG4ke21lc3NhZ2V9XFxuQWxsIHN1YnN0aXR1dGlvbiBzdHJpbmdzIG11c3QgYmUgc3BlY2lmaWVkIGluIDJuZCBwYXJhbWV0ZXIuIE1pc3Npbmc6ICR7bWlzc2luZ0FyZ3Muam9pbignOyAnKX1gKTtcblxuICByZXR1cm4gbWVzc2FnZTtcbn1cblxuZXhwb3J0IGNvbnN0IGVxdWFscyA9IChhOiBhbnksIGI6IGFueSkgPT4ge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICBsZXQgbGVuZ3RoLCBpLCBrZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbHMoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmICghZXF1YWxzKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdHJ1ZSBpZiBib3RoIE5hTiwgZmFsc2Ugb3RoZXJ3aXNlXG4gIHJldHVybiBhIT09YSAmJiBiIT09Yjtcbn07XG4iLCAiaW1wb3J0IEVsZW1lbnRDb2xsZWN0aW9uIGZyb20gJy4vZWxlbWVudC1jb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IHNodWZmbGVBcnJheSwgdGltZXMgfSBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgeyBzZXJpYWxpemVPYmplY3QsIGRlc2VyaWFsaXplT2JqZWN0IH0gZnJvbSAnLi4vYWN0aW9uL3V0aWxzLmpzJztcbmltcG9ydCB1dWlkIGZyb20gJ3V1aWQtcmFuZG9tJztcblxuaW1wb3J0IHR5cGUgR2FtZU1hbmFnZXIgZnJvbSAnLi4vZ2FtZS1tYW5hZ2VyLmpzJztcbmltcG9ydCB0eXBlIHsgZGVmYXVsdCBhcyBQbGF5ZXIsIEJhc2VQbGF5ZXIgfSBmcm9tICcuLi9wbGF5ZXIvcGxheWVyLmpzJztcbmltcG9ydCB0eXBlIHsgZGVmYXVsdCBhcyBHYW1lLCBCYXNlR2FtZSB9IGZyb20gJy4vZ2FtZS5qcyc7XG5pbXBvcnQgdHlwZSBTcGFjZSBmcm9tICcuL3NwYWNlLmpzJztcbmltcG9ydCB0eXBlIENvbm5lY3RlZFNwYWNlTWFwIGZyb20gJy4vY29ubmVjdGVkLXNwYWNlLW1hcC5qcyc7XG5pbXBvcnQgdHlwZSB7IEVsZW1lbnRGaW5kZXIsIFNvcnRlciB9IGZyb20gJy4vZWxlbWVudC1jb2xsZWN0aW9uLmpzJztcbmltcG9ydCB0eXBlIEFkamFjZW5jeVNwYWNlIGZyb20gJy4vYWRqYWNlbmN5LXNwYWNlLmpzJztcbmltcG9ydCB0eXBlIHsgQXJndW1lbnQgfSBmcm9tICcuLi9hY3Rpb24vYWN0aW9uLmpzJztcblxuZXhwb3J0IHR5cGUgRWxlbWVudEpTT04gPSAoe2NsYXNzTmFtZTogc3RyaW5nLCBjaGlsZHJlbj86IEVsZW1lbnRKU09OW119ICYgUmVjb3JkPHN0cmluZywgYW55Pik7XG5cbmV4cG9ydCB0eXBlIEVsZW1lbnRDbGFzczxUIGV4dGVuZHMgR2FtZUVsZW1lbnQgPSBHYW1lRWxlbWVudD4gPSB7XG4gIG5ldyhjdHg6IFBhcnRpYWw8RWxlbWVudENvbnRleHQ+KTogVDtcbiAgaXNHYW1lRWxlbWVudDogYm9vbGVhbjsgLy8gaGVyZSB0byBoZWxwIGVuZm9yY2UgdHlwZXNcbiAgdmlzaWJsZUF0dHJpYnV0ZXM/OiBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBFaXRoZXIgdGhlIG5hbWUgb2YgYSBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0IHRoYXQgY2FuIGJlIGxleGljYWxseSBzb3J0ZWQsIG9yXG4gKiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgb2JqZWN0IHRvIHNvcnQgYW5kIG11c3QgcmV0dXJuIGFcbiAqIGxleGljYWxseSBzb3J0YWJsZSB2YWx1ZS5cbiAqIEBjYXRlZ29yeSBCb2FyZFxuICovXG5leHBvcnQgdHlwZSBHZW5lcmljU29ydGVyID0gc3RyaW5nIHwgKChlOiBHYW1lRWxlbWVudCkgPT4gbnVtYmVyIHwgc3RyaW5nKVxuXG4vKipcbiAqIFRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgY2xhc3MgdGhhdCBpbmhlcml0cyBHYW1lRWxlbWVudCwgZXhjbHVkaW5nIGludGVybmFsXG4gKiBvbmVzIGZyb20gdGhlIGJhc2UgR2FtZUVsZW1lbnRcbiAqL1xuZXhwb3J0IHR5cGUgRWxlbWVudEF0dHJpYnV0ZXM8VCBleHRlbmRzIEdhbWVFbGVtZW50PiA9XG4gIFBhcnRpYWw8UGljazxULCB7W0sgaW4ga2V5b2YgVF06IEsgZXh0ZW5kcyBrZXlvZiBHYW1lRWxlbWVudCA/IG5ldmVyIDogKFRbS10gZXh0ZW5kcyAoLi4uYTphbnlbXSkgPT4gYW55ID8gbmV2ZXIgOiBLKX1ba2V5b2YgVF0gfCAnbmFtZScgfCAncGxheWVyJyB8ICdyb3cnIHwgJ2NvbHVtbicgfCAncm90YXRpb24nPj5cblxuZXhwb3J0IHR5cGUgRWxlbWVudENvbnRleHQgPSB7XG4gIGdhbWVNYW5hZ2VyOiBHYW1lTWFuYWdlcjtcbiAgdG9wOiBHYW1lRWxlbWVudDtcbiAgbmFtZWRTcGFjZXM6IFJlY29yZDxzdHJpbmcsIFNwYWNlPEdhbWU+PlxuICB1bmlxdWVOYW1lczogUmVjb3JkPHN0cmluZywgYm9vbGVhbj5cbiAgcmVtb3ZlZDogR2FtZUVsZW1lbnQ7XG4gIHNlcXVlbmNlOiBudW1iZXI7XG4gIHBsYXllcj86IFBsYXllcjtcbiAgY2xhc3NSZWdpc3RyeTogRWxlbWVudENsYXNzW107XG4gIG1vdmVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICB0cmFja01vdmVtZW50OiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBBIEJveCBzaXplIGFuZCBwb3NpdGlvbiByZWxhdGl2ZSB0byBhIGNvbnRhaW5lclxuICogQGNhdGVnb3J5IFVJXG4gKi9cbmV4cG9ydCB0eXBlIEJveCA9IHsgbGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfTtcbi8qKlxuICogQW4gKHgsIHkpIFZlY3RvclxuICogQGNhdGVnb3J5IFVJXG4gKi9cbmV4cG9ydCB0eXBlIFZlY3RvciA9IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfTtcblxuZXhwb3J0IHR5cGUgRGlyZWN0aW9uID0gJ3VwJyB8ICdkb3duJyB8ICdsZWZ0JyB8ICdyaWdodCdcbmV4cG9ydCB0eXBlIERpcmVjdGlvbldpdGhEaWFnb25hbHMgPSBEaXJlY3Rpb24gfCAndXBsZWZ0JyB8ICd1cHJpZ2h0JyB8ICdkb3dubGVmdCcgfCAnZG93bnJpZ2h0JztcblxuZXhwb3J0IHR5cGUgRWxlbWVudFVJPFQgZXh0ZW5kcyBHYW1lRWxlbWVudD4gPSB7XG4gIGxheW91dHM6IHtcbiAgICBhcHBseVRvOiBFbGVtZW50Q2xhc3MgfCBHYW1lRWxlbWVudCB8IEVsZW1lbnRDb2xsZWN0aW9uIHwgc3RyaW5nLFxuICAgIGF0dHJpYnV0ZXM6IExheW91dEF0dHJpYnV0ZXNcbiAgfVtdLFxuICBhcHBlYXJhbmNlOiB7XG4gICAgY2xhc3NOYW1lPzogc3RyaW5nLFxuICAgIHJlbmRlcj86ICgoZWw6IFQpID0+IEpTWC5FbGVtZW50IHwgbnVsbCkgfCBmYWxzZSxcbiAgICBhc3BlY3RSYXRpbz86IG51bWJlcixcbiAgICBlZmZlY3RzPzogeyB0cmlnZ2VyOiAoZWxlbWVudDogVCwgb2xkQXR0cmlidXRlczogRWxlbWVudEF0dHJpYnV0ZXM8VD4pID0+IGJvb2xlYW4sIG5hbWU6IHN0cmluZyB9W10sXG4gICAgaW5mbz86ICgoZWw6IFQpID0+IEpTWC5FbGVtZW50IHwgbnVsbCB8IGJvb2xlYW4pIHwgYm9vbGVhbixcbiAgICBjb25uZWN0aW9ucz86IHtcbiAgICAgIHRoaWNrbmVzcz86IG51bWJlcixcbiAgICAgIHN0eWxlPzogJ3NvbGlkJyB8ICdkb3VibGUnLFxuICAgICAgY29sb3I/OiBzdHJpbmcsXG4gICAgICBmaWxsPzogc3RyaW5nLFxuICAgICAgbGFiZWw/OiAoe2Rpc3RhbmNlLCB0bywgZnJvbX06IHtkaXN0YW5jZTogbnVtYmVyLCB0bzogU3BhY2U8R2FtZT4sIGZyb206IFNwYWNlPEdhbWU+IH0pID0+IFJlYWN0LlJlYWN0Tm9kZSxcbiAgICAgIGxhYmVsU2NhbGU/OiBudW1iZXIsXG4gICAgfSxcbiAgfSxcbiAgZ2V0QmFzZUxheW91dDogKCkgPT4gTGF5b3V0QXR0cmlidXRlcyxcbiAgZ2hvc3Q/OiBib29sZWFuLFxufTtcblxuLyoqXG4gKiBMaXN0IG9mIGF0dHJpYnV0ZXMgdXNlZCB0byBjcmVhdGUgYSBuZXcgbGF5b3V0IGluIHtAbGluayBHYW1lRWxlbWVudCNsYXlvdXR9LlxuICogQGNhdGVnb3J5IFVJXG4gKi9cbmV4cG9ydCB0eXBlIExheW91dEF0dHJpYnV0ZXMgPSB7XG4gIC8qKlxuICAgKiBJbnN0ZWFkIG9mIHByb3ZpZGluZyBgYXJlYWAsIHByb3ZpZGluZyBhIGBtYXJnaW5gIGRlZmluZXMgdGhlIGJvdW5kaW5nIGJveFxuICAgKiBpbiB0ZXJtcyBvZiBhIG1hcmdpbiBhcm91bmQgdGhlIGVkZ2VzIG9mIHRoaXMgZWxlbWVudC4gVGhpcyB2YWx1ZSBpcyBhblxuICAgKiBhYnNvbHV0ZSBwZXJjZW50YWdlIG9mIHRoZSBib2FyZCdzIHNpemUgc28gdGhhdCBtYXJnaW5zIHNwZWNpZmllZCBvblxuICAgKiBkaWZmZXJlbnQgbGF5b3V0cyB3aXRoIHRoZSBzYW1lIHZhbHVlIHdpbGwgZXhhY3RseSBtYXRjaC5cbiAgICovXG4gbWFyZ2luPzogbnVtYmVyIHwgeyB0b3A6IG51bWJlciwgYm90dG9tOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgcmlnaHQ6IG51bWJlciB9LFxuICAvKipcbiAgICogQSBib3ggZGVmaW5pbmcgdGhlIGxheW91dCdzIGJvdW5kcyB3aXRoaW4gdGhpcyBlbGVtZW50LiBVbmxlc3MgYHNpemVgIGlzXG4gICAqIHNldCB0b28gbGFyZ2UsIG5vIGVsZW1lbnRzIHdpbGwgZXZlciBvdmVyZmxvdyB0aGlzIGFyZWEuIElmIHVuc3BlY2lmaWVkLFxuICAgKiB0aGUgZW50aXJlIGFyZWEgaXMgdXNlZCwgaS5lLiBgeyBsZWZ0OiAwLCB0b3A6IDAsIHdpZHRoOiAxMDAsIGhlaWdodDogMTAwXG4gICAqIH1gXG4gICAqL1xuICBhcmVhPzogQm94LFxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiByb3dzIHRvIGFsbG90IGZvciBwbGFjaW5nIGVsZW1lbnRzIGluIHRoaXMgbGF5b3V0LiBJZiBhXG4gICAqIG51bWJlciBpcyBwcm92aWRlZCwgdGhpcyBpcyBmaXhlZC4gSWYgbWluL21heCB2YWx1ZXMgYXJlIHByb3ZpZGVkLCB0aGVcbiAgICogbGF5b3V0IHdpbGwgYWxsb3QgYXQgbGVhc3QgYG1pbmAgYW5kIHVwIHRvIGBtYXhgIGFzIG5lZWRlZC4gSWYgYG1pbmAgaXNcbiAgICogb21pdHRlZCwgYSBtaW5pbXVtIG9mIDEgaXMgaW1wbGllZC4gSWYgYG1heGAgaXMgb21pdHRlZCwgYXMgbWFueSBhcmUgdXNlZFxuICAgKiBhcyBuZWVkZWQuIERlZmF1bHQgaXMgbm8gbGltaXRzIG9uIGVpdGhlci5cbiAgICovXG4gIHJvd3M/OiBudW1iZXIgfCB7bWluOiBudW1iZXIsIG1heD86IG51bWJlcn0gfCB7bWluPzogbnVtYmVyLCBtYXg6IG51bWJlcn0sXG4gIC8qKlxuICAgKiBDb2x1bW5zLCBhcyBwZXIgYHJvd3NgXG4gICAqL1xuICBjb2x1bW5zPzogbnVtYmVyIHwge21pbjogbnVtYmVyLCBtYXg/OiBudW1iZXJ9IHwge21pbj86IG51bWJlciwgbWF4OiBudW1iZXJ9LFxuICAvKipcbiAgICogSWYgc3VwcGxpZWQsIHRoaXMgb3ZlcnJpZGVzIGFsbCBvdGhlciBhdHRyaWJ1dGVzIHRvIGRlZmluZSBhIHNldCBvZlxuICAgKiBzdHJpY3RseSBkZWZpbmVkIGJveGVzIGZvciBwbGFjaW5nIGVhY2ggZWxlbWVudC4gQW55IGVsZW1lbnRzIHRoYXQgZXhjZWVkXG4gICAqIHRoZSBudW1iZXIgb2Ygc2xvdHMgcHJvdmlkZWQgYXJlIG5vdCBkaXNwbGF5ZWQuXG4gICAqL1xuICBzbG90cz86IEJveFtdLFxuICAvKipcbiAgICogU2l6ZSBhbGxvdGVkIGZvciBlYWNoIGVsZW1lbnQgcGxhY2VkIGluIHRoaXMgbGF5b3V0LiBPdmVycmlkZXMgYHNjYWxpbmdgXG4gICAqIGFuZCBhbGwgZGVmaW5lZCBhc3BlY3QgcmF0aW9zIGZvciB0aGVzZSBlbGVtZW50cywgZml4aW5nIHRoZSBzaXplIGZvciBlYWNoXG4gICAqIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBzaXplLlxuICAgKi9cbiAgc2l6ZT86IHsgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfSxcbiAgLyoqXG4gICAqIEFzcGVjdCByYXRpbyBmb3IgZWFjaCBlbGVtZW50IHBsYWNlZCBpbiB0aGlzIGxheW91dC4gVGhpcyB2YWx1ZSBpcyBhIHJhdGlvXG4gICAqIG9mIHdpZHRoIG92ZXIgaGVpZ2h0LiBFbGVtZW50cyB3aWxsIGFkaGVyZSB0byB0aGlzIHJhdGlvIHVubGVzcyB0aGV5IGhhdmVcbiAgICogdGhlaXIgb3duIHNwZWNpZmllZCBgYXNwZWN0UmF0aW9gIGluIHRoZWlyIHtAbGlua1xuICAgKiBHYW1lRWxlbWVudCNhcHBlYXJhbmNlfS4gVGhpcyB2YWx1ZSBpcyBpZ25vcmVkIGlmIGBzaXplYCBpcyBwcm92aWRlZC5cbiAgICovXG4gIGFzcGVjdFJhdGlvPzogbnVtYmVyLCAvLyB3IC8gaFxuICAvKipcbiAgICogU2NhbGluZyBzdHJhdGVneSBmb3IgdGhlIGVsZW1lbnRzIHBsYWNlZCBpbiB0aGlzIGxheW91dC5cbiAgICogLSAqZml0KjogRWxlbWVudHMgc2NhbGUgdXAgb3IgZG93biB0byBmaXQgd2l0aGluIHRoZSBhcmVhIGFsbG90ZWQgd2l0aG91dFxuICAgKiAgICBzcXVzaGluZ1xuICAgKiAtICpmaWxsKjogRWxlbWVudHMgc2NhbGUgdXAgb3IgZG93biB0byBjb21wbGV0ZWx5IGZpbGwgdGhlIGFyZWEsIHNxdWlzaGluZ1xuICAgKiAgICB0aGVtc2VsdmVzIHRvZ2V0aGVyIGFzIG5lZWRlZCBhbG9uZyBvbmUgZGltZW5zaW9uLlxuICAgKi9cbiAgc2NhbGluZz86ICdmaXQnIHwgJ2ZpbGwnXG4gIC8qKlxuICAgKiBJZiBwcm92aWRlZCwgdGhpcyBwbGFjZXMgYSBnYXAgYmV0d2VlbiBlbGVtZW50cy4gSWYgc2NhbGluZyBpcyAnZmlsbCcsIHRoaXNcbiAgICogaXMgY29uc2lkZXJlZCBhIG1heGltdW0gYnV0IG1heSBzaHJpbmsgb3IgZXZlbiBiZWNvbWUgbmVnYXRpdmUgaW4gb3JkZXIgdG9cbiAgICogZmlsbCB0aGUgYXJlYS4gVGhpcyB2YWx1ZSBpcyBhbiBhYnNvbHV0ZSBwZXJjZW50YWdlIG9mIHRoZSBib2FyZCdzIHNpemUgc29cbiAgICogdGhhdCBnYXBzIHNwZWNpZmllZCBvbiBkaWZmZXJlbnQgbGF5b3V0cyB3aXRoIHRoZSBzYW1lIHZhbHVlIHdpbGwgZXhhY3RseVxuICAgKiBtYXRjaFxuICAgKi9cbiAgZ2FwPzogbnVtYmVyIHwgeyB4OiBudW1iZXIsIHk6IG51bWJlciB9LFxuICAvKipcbiAgICogSWYgbW9yZSByb29tIGlzIHByb3ZpZGVkIHRoYW4gbmVlZGVkLCB0aGlzIGRldGVybWluZXMgaG93IHRoZSBlbGVtZW50cyB3aWxsXG4gICAqIGFsaWduIHRoZW1zZWx2ZXMgd2l0aGluIHRoZSBhcmVhLlxuICAgKi9cbiAgYWxpZ25tZW50OiAndG9wJyB8ICdib3R0b20nIHwgJ2xlZnQnIHwgJ3JpZ2h0JyB8ICd0b3AgbGVmdCcgfCAnYm90dG9tIGxlZnQnIHwgJ3RvcCByaWdodCcgfCAnYm90dG9tIHJpZ2h0JyB8ICdjZW50ZXInLFxuICAvKipcbiAgICogSW5zdGVhZCBvZiBgZ2FwYCwgcHJvdmlkaW5nIGFuIGBvZmZzZXRDb2x1bW5gL2BvZmZzZXRSb3dgIHNwZWNpZmllcyB0aGF0XG4gICAqIHRoZSBjb250YWluZWQgZWxlbWVudHMgbXVzdCBvZmZzZXQgb25lIGFub3RoZXIgYnkgYSBzcGVjaWZpZWQgYW1vdW50IGFzIGFcbiAgICogcGVyY2VudGFnZSBvZiB0aGUgZWxlbWVudHMgc2l6ZSwgaS5lLiBgb2Zmc2V0Q29sdW1uPTEwMGAgaXMgZXF1aXZhbGVudCB0byBhXG4gICAqIGBnYXBgIG9mIDAuIFRoaXMgYWxsb3dzIG5vbi1vcnRob2dvbmFsIGdyaWRzIGxpa2UgaGV4IG9yIGRpYW1vbmQuIElmIG9uZSBvZlxuICAgKiBgb2Zmc2V0Q29sdW1uYC9gb2Zmc2V0Um93YCBpcyBwcm92aWRlZCBidXQgbm90IHRoZSBvdGhlciwgdGhlIHVuc3BlY2lmaWVkXG4gICAqIG9uZSB3aWxsIGJlIDkwXHUwMEIwIHRvIHRoZSBvbmUgc3BlY2lmaWVkLiBMaWtlIGBnYXBgLCBpZiBgc2NhbGluZ2AgaXMgc2V0IHRvXG4gICAqIGBmaWxsYCwgdGhlc2Ugb2Zmc2V0cyBtYXkgc3F1aXNoIHRvIGZpbGwgc3BhY2UuXG4gICAqL1xuICBvZmZzZXRDb2x1bW4/OiBWZWN0b3IgfCBudW1iZXIsXG4gIC8qKlxuICAgKiBBcyBgb2Zmc2V0Q29sdW1uYFxuICAgKi9cbiAgb2Zmc2V0Um93PzogVmVjdG9yIHwgbnVtYmVyLFxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggZWxlbWVudHMgcGxhY2VkIGhlcmUgc2hvdWxkIGZpbGwgdXAgdGhlXG4gICAqIHJvd3MgYW5kIGNvbHVtbnMgb2YgdGhlIGxheW91dC4gUm93cyBvciBjb2x1bW5zIHdpbGwgaW5jcmVhc2UgdG8gdGhlaXJcbiAgICogc3BlY2lmaWVkIG1heGltdW0gYXMgbmVlZGVkLiBUaGVyZWZvcmUgaWYsIGZvciBleGFtcGxlLCBgZGlyZWN0aW9uYCBpc1xuICAgKiBgXCJsdHJcImAgYW5kIGBjb2x1bW5zYCBoYXMgbm8gbWF4aW11bSwgdGhlcmUgd2lsbCBuZXZlciBiZSBhIHNlY29uZCByb3dcbiAgICogYWRkZWQuIFZhbHVlcyBhcmU6XG4gICAqIC0gKnNxdWFyZSo6IGZpbGwgcm93cyBhbmQgY29sdW1ucyBlcXVhbGx5IHRvIG1haW50YWluIGFzIHNxdWFyZSBhIGdyaWQgYXMgcG9zc2libGUgKGRlZmF1bHQpXG4gICAqIC0gKmx0cio6IGZpbGwgY29sdW1ucyBsZWZ0IHRvIHJpZ2h0LCB0aGVuIHJvd3MgdG9wIHRvIGJvdHRvbSBvbmNlIG1heGltdW0gY29sdW1ucyByZWFjaGVkXG4gICAqIC0gKnJ0bCo6IGZpbGwgY29sdW1ucyByaWdodCB0byBsZWZ0LCB0aGVuIHJvd3MgdG9wIHRvIGJvdHRvbSBvbmNlIG1heGltdW0gY29sdW1ucyByZWFjaGVkXG4gICAqIC0gKmx0ci1idHQqOiBmaWxsIGNvbHVtbnMgbGVmdCB0byByaWdodCwgdGhlbiByb3dzIGJvdHRvbSB0byB0b3Agb25jZSBtYXhpbXVtIGNvbHVtbnMgcmVhY2hlZFxuICAgKiAtICpydGwtYnR0KjogZmlsbCBjb2x1bW5zIHJpZ2h0IHRvIGxlZnQsIHRoZW4gcm93cyBib3R0b20gdG8gdG9wIG9uY2UgbWF4aW11bSBjb2x1bW5zIHJlYWNoZWRcbiAgICogLSAqdHRiKjogZmlsbCByb3dzIHRvcCB0byBib3R0b20sIHRoZW4gY29sdW1ucyBsZWZ0IHRvIHJpZ2h0IG9uY2UgbWF4aW11bSByb3dzIHJlYWNoZWRcbiAgICogLSAqYnR0KjogZmlsbCByb3dzIGJvdHRvbSB0byB0b3AsIHRoZW4gY29sdW1ucyBsZWZ0IHRvIHJpZ2h0IG9uY2UgbWF4aW11bSByb3dzIHJlYWNoZWRcbiAgICogLSAqdHRiLXJ0bCo6IGZpbGwgcm93cyB0b3AgdG8gYm90dG9tLCB0aGVuIGNvbHVtbnMgcmlnaHQgdG8gbGVmdCBvbmNlIG1heGltdW0gcm93cyByZWFjaGVkXG4gICAqIC0gKmJ0dC1ydGwqOiBmaWxsIHJvd3MgYm90dG9tIHRvIHRvcCwgdGhlbiBjb2x1bW5zIHJpZ2h0IHRvIGxlZnQgb25jZSBtYXhpbXVtIHJvd3MgcmVhY2hlZFxuICAgKi9cbiAgZGlyZWN0aW9uOiAnc3F1YXJlJyB8ICdsdHInIHwgJ3J0bCcgfCAncnRsLWJ0dCcgfCAnbHRyLWJ0dCcgfCAndHRiJyB8ICd0dGItcnRsJyB8ICdidHQnIHwgJ2J0dC1ydGwnLFxuICAvKipcbiAgICogSWYgc3BlY2lmaWVkLCBubyBtb3JlIHRoYW4gYGxpbWl0YCBpdGVtcyB3aWxsIGJlIHZpc2libGUuIFRoaXMgaXMgdXNlZnVsXG4gICAqIGZvciBkaXNwbGF5aW5nIGUuZy4gZGVja3Mgb2YgY2FyZHMgd2hlcmUgc2hvd2luZyBvbmx5IDIgb3IgMyBjYXJkcyBwcm92aWRlc1xuICAgKiBhIGRlY2stbGlrZSBhcHBlYXJhbmNlIHdpdGhvdXQgbmVlZGVkIHRvIHJlbmRlciBtb3JlIGNhcmRzIHVuZGVybmVhdGggdGhhdFxuICAgKiBhcmVuJ3QgdmlzaWJsZS5cbiAgICovXG4gIGxpbWl0PzogbnVtYmVyLFxuICAvKipcbiAgICogSWYgYHNjYWxpbmdgIGlzIGBcImZpbGxcImAsIHRoaXMgd2lsbCBsaW1pdCB0aGUgdG90YWwgYW1vdW50IG9mIG92ZXJsYXAgaWZcbiAgICogZWxlbWVudHMgYXJlIHNxdWlzaGVkIHRvZ2V0aGVyIGluIHRoZWlyIHNwYWNlIGJlZm9yZSB0aGV5IHdpbGwgc3RhcnQgdG9cbiAgICogc2hyaW5rIHRvIGZpdC4gVGhpcyBpcyB1c2VmdWwgZm9yIGUuZy4gY2FyZHMgdGhhdCBjYW4gb3ZlcmxhcCBidXQgdGhhdCBtdXN0XG4gICAqIGxlYXZlIGEgY2VydGFpbiBhbW91bnQgdmlzaWJsZSB0byBjbGVhcmx5IGlkZW50aWZ5IHRoZSBjYXJkLlxuICAgKi9cbiAgbWF4T3ZlcmxhcD86IG51bWJlcixcbiAgLyoqXG4gICAqIEEgbnVtYmVyIHNwZWNpZnlpbmcgYW4gYW1vdW50IG9mIHJhbmRvbW5lc3MgYWRkZWQgdG8gdGhlIGxheW91dCB0byBwcm92aWRlXG4gICAqIGEgbW9yZSBuYXR1cmFsIGxvb2tpbmcgcGxhY2VtZW50XG4gICAqL1xuICBoYXBoYXphcmRseT86IG51bWJlcixcbiAgLyoqXG4gICAqIFNldCB0byB0cnVlIHRvIHByZXZlbnQgdGhlc2UgZWxlbWVudHMgZnJvbSBhdXRvbWF0aWNhbGx5IGNoYW5naW5nIHBvc2l0aW9uXG4gICAqIHdpdGhpbiB0aGUgY29udGFpbmVyIGdyaWQuXG4gICAqL1xuICBzdGlja3k/OiBib29sZWFuLFxuICAvKipcbiAgICogU2V0IHRvIHRydWUgZm9yIGRlYnVnZ2luZy4gQ3JlYXRlcyBhIHZpc2libGUgYm94IG9uIHNjcmVlbiBhcm91bmQgdGhlXG4gICAqIGRlZmluZWQgYGFyZWFgLCB0YWdnZWQgd2l0aCB0aGUgcHJvdmlkZWQgc3RyaW5nLlxuICAgKi9cbiAgc2hvd0JvdW5kaW5nQm94Pzogc3RyaW5nIHwgYm9vbGVhbixcbiAgX19jb250YWluZXJfXz86IHtcbiAgICB0eXBlOiAnZHJhd2VyJyB8ICdwb3BvdXQnIHwgJ3RhYnMnLFxuICAgIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgaWQ/OiBzdHJpbmcsXG4gICAga2V5Pzogc3RyaW5nLFxuICB9XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGFsbCBHYW1lIGVsZW1lbnRzLiBEbyBub3Qgc3ViY2xhc3MgdGhpc1xuICogZGlyZWN0bHkuIEluc3RlYWQgdXNlIHtAbGluayBTcGFjZX0gb3Ige0BsaW5rIFBpZWNlfSBhcyB0aGUgYmFzZSBmb3JcbiAqIHN1YmNsYXNzaW5nIHlvdXIgb3duIGVsZW1lbnRzLlxuICogQGNhdGVnb3J5IEJvYXJkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWVFbGVtZW50PEcgZXh0ZW5kcyBCYXNlR2FtZSA9IEJhc2VHYW1lLCBQIGV4dGVuZHMgQmFzZVBsYXllciA9IEJhc2VQbGF5ZXI+IHtcbiAgLyoqXG4gICAqIEVsZW1lbnQgbmFtZSwgdXNlZCB0byBkaXN0aW5ndWlzaCBlbGVtZW50cy4gRWxlbWVudHMgd2l0aCB0aGUgc2FtZSBuYW1lIGFyZVxuICAgKiBnZW5lcmFsbHkgY29uc2lkZXJlZCBpbmRpc3RpYnVpc2hhYmxlLiBOYW1lcyBhcmUgYWxzbyB1c2VkIGZvciBlYXN5XG4gICAqIHNlYXJjaGluZyBvZiBlbGVtZW50cy5cbiAgICogQGNhdGVnb3J5IFF1ZXJpZXNcbiAgICovXG4gIG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogUGxheWVyIHdpdGggd2hpY2ggdGhpcyBlbGVtZW50IGlzIGlkZW50aWZpZWQuIFRoaXMgZG9lcyBub3QgYWZmZWN0XG4gICAqIGJlaGF2aW91ciBidXQgd2lsbCBtYXJrIHRoZSBlbGVtZW50IGFzIGBtaW5lYCBpbiBxdWVyaWVzIGluIHRoZSBjb250ZXh0IG9mXG4gICAqIHRoaXMgcGxheWVyIChkdXJpbmcgYW4gYWN0aW9uIHRha2VuIGJ5IGEgcGxheWVyIG9yIHdoaWxlIHRoZSBnYW1lIGlzXG4gICAqIHZpZXdlZCBieSBhIGdpdmVuIHBsYXllci4pLlxuICAgKiBAY2F0ZWdvcnkgUXVlcmllc1xuICAgKi9cbiAgcGxheWVyPzogUDtcblxuICAvKipcbiAgICogUm93IG9mIGVsZW1lbnQgd2l0aGluIGl0cyBsYXlvdXQgZ3JpZCBpZiBzcGVjaWZpZWQgZGlyZWN0bHkgb3IgYnkgYVxuICAgKiBcInN0aWNreVwiIGxheW91dC5cbiAgICogQGNhdGVnb3J5IFN0cnVjdHVyZVxuICAgKi9cbiAgcm93PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBDb2x1bW4gb2YgZWxlbWVudCB3aXRoaW4gaXRzIGxheW91dCBncmlkIGlmIHNwZWNpZmllZCBkaXJlY3RseSBvciBieSBhXG4gICAqIFwic3RpY2t5XCIgbGF5b3V0LlxuICAgKiBAY2F0ZWdvcnkgU3RydWN0dXJlXG4gICAqL1xuICBjb2x1bW4/OiBudW1iZXI7XG5cbiAgX3JvdGF0aW9uPzogbnVtYmVyOyAvLyBkZWdyZWVzXG5cbiAgLyoqXG4gICAqIFRoZSB7QGxpbmsgR2FtZX0gdG8gd2hpY2ggdGhpcyBlbGVtZW50IGJlbG9uZ3NcbiAgICogQGNhdGVnb3J5IFN0cnVjdHVyZVxuICAgKi9cbiAgZ2FtZTogRztcblxuICAvKipcbiAgICogY3R4IHNoYXJlZCBmb3IgYWxsIGVsZW1lbnRzIGluIHRoZSB0cmVlXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2N0eDogRWxlbWVudENvbnRleHRcblxuICAvKipcbiAgICogdHJlZSBpbmZvXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3Q6IHtcbiAgICBjaGlsZHJlbjogRWxlbWVudENvbGxlY3Rpb248R2FtZUVsZW1lbnQ+LFxuICAgIHBhcmVudD86IEdhbWVFbGVtZW50LFxuICAgIGlkOiBudW1iZXIsIC8vIHVuaXF1ZSBhbmQgaW1tdWF0YWJsZVxuICAgIHJlZjogbnVtYmVyLCAvLyB1bmlxdWUgYW5kIG1heSBjaGFuZ2UgdG8gaGlkZSBtb3Zlc1xuICAgIHdhc1JlZj86IG51bWJlciwgLy8gcHJldmlvdXMgcmVmIHRvIHRyYWNrIGNoYW5nZXMsIG9ubHkgcG9wdWxhdGVkIGlmIHJlb3JkZXIgZHVyaW5nIHRyYWNrTW92ZW1lbnRcbiAgICBtb3ZlZD86IGJvb2xlYW4sIC8vIHRyYWNrIGlmIGFscmVhZHkgbW92ZWQgKGNoYW5nZWQgcGFyZW50KVxuICAgIG9yZGVyPzogJ25vcm1hbCcgfCAnc3RhY2tpbmcnLFxuICAgIHNldElkOiAoaWQ6IG51bWJlcikgPT4gdm9pZCxcbiAgfSA9IHtcbiAgICBjaGlsZHJlbjogbmV3IEVsZW1lbnRDb2xsZWN0aW9uPEdhbWVFbGVtZW50PigpLFxuICAgIGlkOiAwLFxuICAgIHJlZjogMCxcbiAgICBzZXRJZDogKCkgPT4ge31cbiAgfTtcblxuICBfc2l6ZT86IHtcbiAgICB3aWR0aDogbnVtYmVyLFxuICAgIGhlaWdodDogbnVtYmVyLFxuICAgIHNoYXBlOiBzdHJpbmdbXSxcbiAgICBlZGdlcz86IFJlY29yZDxzdHJpbmcsIFBhcnRpYWw8UmVjb3JkPERpcmVjdGlvbiwgc3RyaW5nPj4+XG4gIH1cblxuICBzdGF0aWMgaXNHYW1lRWxlbWVudCA9IHRydWU7XG5cbiAgc3RhdGljIHVuc2VyaWFsaXphYmxlQXR0cmlidXRlcyA9IFsnX2N0eCcsICdfdCcsICdfdWknLCAnZ2FtZSddO1xuXG4gIHN0YXRpYyB2aXNpYmxlQXR0cmlidXRlczogc3RyaW5nW10gfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIERvIG5vdCB1c2UgdGhlIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiBJbnN0ZWFkIENhbGwge0BsaW5rXG4gICAqIEdhbWVFbGVtZW50I2NyZWF0ZX0gb3Ige0BsaW5rIEdhbWVFbGVtZW50I2NyZWF0ZU1hbnl9IG9uIHRoZSBlbGVtZW50IGluXG4gICAqIHdoaWNoIHlvdSB3YW50IHRvIGNyZWF0ZSBhIG5ldyBlbGVtZW50LlxuICAgKiBAY2F0ZWdvcnkgU3RydWN0dXJlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjdHg6IFBhcnRpYWw8RWxlbWVudENvbnRleHQ+KSB7XG4gICAgdGhpcy5fY3R4ID0gY3R4IGFzIEVsZW1lbnRDb250ZXh0O1xuICAgIHRoaXMuX2N0eC5jbGFzc1JlZ2lzdHJ5ID8/PSBbXTtcbiAgICBpZiAoIWN0eC50b3ApIHtcbiAgICAgIHRoaXMuX2N0eC50b3AgPSB0aGlzIGFzIHVua25vd24gYXMgR2FtZUVsZW1lbnQ7XG4gICAgICB0aGlzLl9jdHguc2VxdWVuY2UgPSAwO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2N0eC5uYW1lZFNwYWNlcykge1xuICAgICAgdGhpcy5fY3R4LnVuaXF1ZU5hbWVzID0ge307XG4gICAgICB0aGlzLl9jdHgubmFtZWRTcGFjZXMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLl90ID0ge1xuICAgICAgY2hpbGRyZW46IG5ldyBFbGVtZW50Q29sbGVjdGlvbigpLFxuICAgICAgaWQ6IHRoaXMuX2N0eC5zZXF1ZW5jZSxcbiAgICAgIHJlZjogdGhpcy5fY3R4LnNlcXVlbmNlLFxuICAgICAgc2V0SWQ6IChpZD86IG51bWJlcikgPT4ge1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX3QuaWQgPSBpZDtcbiAgICAgICAgICBpZiAodGhpcy5fY3R4LnNlcXVlbmNlIDwgaWQpIHRoaXMuX2N0eC5zZXF1ZW5jZSA9IGlkO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH07XG4gICAgdGhpcy5fY3R4LnNlcXVlbmNlICs9IDE7XG4gIH1cblxuICAvKipcbiAgICogU3RyaW5nIHVzZWQgZm9yIHJlcHJlc2VudG5nIHRoaXMgZWxlbWVudCBpbiBnYW1lIG1lc3NhZ2VzIHdoZW4gdGhlIG9iamVjdFxuICAgKiBpcyBwYXNzZWQgZGlyZWN0bHksIGUuZy4gd2hlbiB0YWtpbmcgdGhlIGNob2ljZSBkaXJlY3RseSBmcm9tIGFcbiAgICogY2hvb3NlT25Cb2FyZCBjaG9pY2UuXG4gICAqIEBjYXRlZ29yeSBTdHJ1Y3R1cmVcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLnJlcGxhY2UoLyhbYS16MC05XSkoW0EtWl0pL2csIFwiJDEgJDJcIik7XG4gIH1cblxuICBpc1Zpc2libGVUbyhfcGxheWVyOiBQbGF5ZXIgfCBudW1iZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlzVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgZWxlbWVudHMgd2l0aGluIHRoaXMgZWxlbWVudCByZWN1cnNpdmVseSB0aGF0IG1hdGNoIHRoZSBhcmd1bWVudHNcbiAgICogcHJvdmlkZWQuXG4gICAqIEBjYXRlZ29yeSBRdWVyaWVzXG4gICAqXG4gICAqIEBwYXJhbSB7Y2xhc3N9IGNsYXNzTmFtZSAtIE9wdGlvbmFsbHkgcHJvdmlkZSBhIGNsYXNzIGFzIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgKiBhcyBhIGNsYXNzIGZpbHRlci4gVGhpcyB3aWxsIG9ubHkgbWF0Y2ggZWxlbWVudHMgd2hpY2ggYXJlIGluc3RhbmNlcyBvZiB0aGVcbiAgICogcHJvdmlkZWQgY2xhc3NcbiAgICpcbiAgICogQHBhcmFtIGZpbmRlcnMgLSBBbGwgb3RoZXIgcGFyYW1ldGVycyBhcmUgZmlsdGVycy4gU2VlIHtAbGlua1xuICAgKiBFbGVtZW50RmluZGVyfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgQW4ge0BsaW5rIEVsZW1lbnRDb2xsZWN0aW9ufSBvZiBhcyBtYW55IG1hdGNoaW5nIGVsZW1lbnRzIGFzIGNhbiBiZVxuICAgKiBmb3VuZC4gVGhlIGNvbGxlY3Rpb24gaXMgdHlwZWQgdG8gYEVsZW1lbnRDb2xsZWN0aW9uPGNsYXNzTmFtZT5gIGlmIG9uZSB3YXNcbiAgICogcHJvdmlkZWQuXG4gICAqL1xuICBhbGw8RiBleHRlbmRzIEdhbWVFbGVtZW50PihjbGFzc05hbWU6IEVsZW1lbnRDbGFzczxGPiwgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcjxGPltdKTogRWxlbWVudENvbGxlY3Rpb248Rj47XG4gIGFsbChjbGFzc05hbWU/OiBFbGVtZW50RmluZGVyLCAuLi5maW5kZXJzOiBFbGVtZW50RmluZGVyW10pOiBFbGVtZW50Q29sbGVjdGlvbjxHYW1lRWxlbWVudDxHLCBQPj47XG4gIGFsbChjbGFzc05hbWU/OiBhbnksIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXJbXSkge1xuICAgIHJldHVybiB0aGlzLl90LmNoaWxkcmVuLmFsbChjbGFzc05hbWUsIC4uLmZpbmRlcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBmaXJzdCBlbGVtZW50IHdpdGhpbiB0aGlzIGVsZW1lbnQgcmVjdXJzaXZlbHkgdGhhdCBtYXRjaGVzIHRoZSBhcmd1bWVudHNcbiAgICogcHJvdmlkZWQuIFNlZSB7QGxpbmsgYWxsfSBmb3IgcGFyYW1ldGVyIGRldGFpbHMuXG4gICAqIEBjYXRlZ29yeSBRdWVyaWVzXG4gICAqIEByZXR1cm5zIEEgbWF0Y2hpbmcgZWxlbWVudCwgaWYgZm91bmRcbiAgICovXG4gIGZpcnN0PEYgZXh0ZW5kcyBHYW1lRWxlbWVudD4oY2xhc3NOYW1lOiBFbGVtZW50Q2xhc3M8Rj4sIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXI8Rj5bXSk6IEYgfCB1bmRlZmluZWQ7XG4gIGZpcnN0KGNsYXNzTmFtZT86IEVsZW1lbnRGaW5kZXIsIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXJbXSk6IEdhbWVFbGVtZW50PEcsIFA+IHwgdW5kZWZpbmVkO1xuICBmaXJzdChjbGFzc05hbWU/OiBhbnksIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXJbXSkge1xuICAgIHJldHVybiB0aGlzLl90LmNoaWxkcmVuLmZpcnN0KGNsYXNzTmFtZSwgLi4uZmluZGVycyk7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgdGhlIGZpcnN0IGBuYCBlbGVtZW50cyB3aXRoaW4gdGhpcyBlbGVtZW50IHJlY3Vyc2l2ZWx5IHRoYXQgbWF0Y2ggdGhlIGFyZ3VtZW50c1xuICAgKiBwcm92aWRlZC4gU2VlIHtAbGluayBhbGx9IGZvciBwYXJhbWV0ZXIgZGV0YWlscy5cbiAgICogQGNhdGVnb3J5IFF1ZXJpZXNcbiAgICogQHBhcmFtIG4gLSBudW1iZXIgb2YgbWF0Y2hlc1xuICAgKlxuICAgKiBAcmV0dXJucyBBbiB7QGxpbmsgRWxlbWVudENvbGxlY3Rpb259IG9mIGFzIG1hbnkgbWF0Y2hpbmcgZWxlbWVudHMgYXMgY2FuIGJlXG4gICAqIGZvdW5kLCB1cCB0byBgbmAuIFRoZSBjb2xsZWN0aW9uIGlzIHR5cGVkIHRvIGBFbGVtZW50Q29sbGVjdGlvbjxjbGFzc05hbWU+YFxuICAgKiBpZiBvbmUgd2FzIHByb3ZpZGVkLlxuICAgKi9cbiAgZmlyc3ROPEYgZXh0ZW5kcyBHYW1lRWxlbWVudD4objogbnVtYmVyLCBjbGFzc05hbWU6IEVsZW1lbnRDbGFzczxGPiwgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcjxGPltdKTogRWxlbWVudENvbGxlY3Rpb248Rj47XG4gIGZpcnN0TihuOiBudW1iZXIsIGNsYXNzTmFtZT86IEVsZW1lbnRGaW5kZXIsIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXJbXSk6IEVsZW1lbnRDb2xsZWN0aW9uPEdhbWVFbGVtZW50PEcsIFA+PjtcbiAgZmlyc3ROKG46IG51bWJlciwgY2xhc3NOYW1lPzogYW55LCAuLi5maW5kZXJzOiBFbGVtZW50RmluZGVyW10pIHtcbiAgICByZXR1cm4gdGhpcy5fdC5jaGlsZHJlbi5maXJzdE4obiwgY2xhc3NOYW1lLCAuLi5maW5kZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgbGFzdCBlbGVtZW50IHdpdGhpbiB0aGlzIGVsZW1lbnQgcmVjdXJzaXZlbHkgdGhhdCBtYXRjaGVzIHRoZSBhcmd1bWVudHNcbiAgICogcHJvdmlkZWQuIFNlZSB7QGxpbmsgYWxsfSBmb3IgcGFyYW1ldGVyIGRldGFpbHMuXG4gICAqIEBjYXRlZ29yeSBRdWVyaWVzXG4gICAqIEByZXR1cm5zIEEgbWF0Y2hpbmcgZWxlbWVudCwgaWYgZm91bmRcbiAgICovXG4gIGxhc3Q8RiBleHRlbmRzIEdhbWVFbGVtZW50PihjbGFzc05hbWU6IEVsZW1lbnRDbGFzczxGPiwgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcjxGPltdKTogRiB8IHVuZGVmaW5lZDtcbiAgbGFzdChjbGFzc05hbWU/OiBFbGVtZW50RmluZGVyLCAuLi5maW5kZXJzOiBFbGVtZW50RmluZGVyW10pOiBHYW1lRWxlbWVudDxHLCBQPiB8IHVuZGVmaW5lZDtcbiAgbGFzdChjbGFzc05hbWU/OiBhbnksIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXJbXSkge1xuICAgIHJldHVybiB0aGlzLl90LmNoaWxkcmVuLmxhc3QoY2xhc3NOYW1lLCAuLi5maW5kZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgbGFzdCBgbmAgZWxlbWVudHMgd2l0aGluIHRoaXMgZWxlbWVudCByZWN1cnNpdmVseSB0aGF0IG1hdGNoIHRoZSBhcmd1bWVudHNcbiAgICogcHJvdmlkZWQuIFNlZSB7QGxpbmsgYWxsfSBmb3IgcGFyYW1ldGVyIGRldGFpbHMuXG4gICAqIEBjYXRlZ29yeSBRdWVyaWVzXG4gICAqIEBwYXJhbSBuIC0gbnVtYmVyIG9mIG1hdGNoZXNcbiAgICpcbiAgICogQHJldHVybnMgQW4ge0BsaW5rIEVsZW1lbnRDb2xsZWN0aW9ufSBvZiBhcyBtYW55IG1hdGNoaW5nIGVsZW1lbnRzIGFzIGNhbiBiZVxuICAgKiBmb3VuZCwgdXAgdG8gYG5gLiBUaGUgY29sbGVjdGlvbiBpcyB0eXBlZCB0byBgRWxlbWVudENvbGxlY3Rpb248Y2xhc3NOYW1lPmBcbiAgICogaWYgb25lIHdhcyBwcm92aWRlZC5cbiAgICovXG4gIGxhc3ROPEYgZXh0ZW5kcyBHYW1lRWxlbWVudD4objogbnVtYmVyLCBjbGFzc05hbWU6IEVsZW1lbnRDbGFzczxGPiwgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcjxGPltdKTogRWxlbWVudENvbGxlY3Rpb248Rj47XG4gIGxhc3ROKG46IG51bWJlciwgY2xhc3NOYW1lOiBFbGVtZW50RmluZGVyLCAuLi5maW5kZXJzOiBFbGVtZW50RmluZGVyW10pOiBFbGVtZW50Q29sbGVjdGlvbjxHYW1lRWxlbWVudDxHLCBQPj47XG4gIGxhc3ROKG46IG51bWJlciwgY2xhc3NOYW1lOiBhbnksIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXJbXSkge1xuICAgIHJldHVybiB0aGlzLl90LmNoaWxkcmVuLmxhc3ROKG4sIGNsYXNzTmFtZSwgLi4uZmluZGVycyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3Ige0BsaW5rIGZpcnN0fVxuICAgKiBAY2F0ZWdvcnkgUXVlcmllc1xuICAgKi9cbiAgdG9wPEYgZXh0ZW5kcyBHYW1lRWxlbWVudD4oY2xhc3NOYW1lOiBFbGVtZW50Q2xhc3M8Rj4sIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXI8Rj5bXSk6IEYgfCB1bmRlZmluZWQ7XG4gIHRvcChjbGFzc05hbWU/OiBFbGVtZW50RmluZGVyLCAuLi5maW5kZXJzOiBFbGVtZW50RmluZGVyW10pOiBHYW1lRWxlbWVudDxHLCBQPiB8IHVuZGVmaW5lZDtcbiAgdG9wKGNsYXNzTmFtZT86IGFueSwgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcltdKSB7XG4gICAgcmV0dXJuIHRoaXMuX3QuY2hpbGRyZW4udG9wKGNsYXNzTmFtZSwgLi4uZmluZGVycyk7XG4gIH1cblxuICAvKipcbiAgICogQWxpYXMgZm9yIHtAbGluayBmaXJzdE59XG4gICAqIEBjYXRlZ29yeSBRdWVyaWVzXG4gICAqL1xuICB0b3BOPEYgZXh0ZW5kcyBHYW1lRWxlbWVudD4objogbnVtYmVyLCBjbGFzc05hbWU6IEVsZW1lbnRDbGFzczxGPiwgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcjxGPltdKTogRWxlbWVudENvbGxlY3Rpb248Rj47XG4gIHRvcE4objogbnVtYmVyLCBjbGFzc05hbWU/OiBFbGVtZW50RmluZGVyLCAuLi5maW5kZXJzOiBFbGVtZW50RmluZGVyW10pOiBFbGVtZW50Q29sbGVjdGlvbjxHYW1lRWxlbWVudDxHLCBQPj47XG4gIHRvcE4objogbnVtYmVyLCBjbGFzc05hbWU/OiBhbnksIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXJbXSkge1xuICAgIHJldHVybiB0aGlzLl90LmNoaWxkcmVuLnRvcE4obiwgY2xhc3NOYW1lLCAuLi5maW5kZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3Ige0BsaW5rIGxhc3R9XG4gICAqIEBjYXRlZ29yeSBRdWVyaWVzXG4gICAqL1xuICBib3R0b208RiBleHRlbmRzIEdhbWVFbGVtZW50PihjbGFzc05hbWU6IEVsZW1lbnRDbGFzczxGPiwgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcjxGPltdKTogRiB8IHVuZGVmaW5lZDtcbiAgYm90dG9tKGNsYXNzTmFtZT86IEVsZW1lbnRGaW5kZXIsIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXJbXSk6IEdhbWVFbGVtZW50PEcsIFA+IHwgdW5kZWZpbmVkO1xuICBib3R0b20oY2xhc3NOYW1lPzogYW55LCAuLi5maW5kZXJzOiBFbGVtZW50RmluZGVyW10pIHtcbiAgICByZXR1cm4gdGhpcy5fdC5jaGlsZHJlbi5ib3R0b20oY2xhc3NOYW1lLCAuLi5maW5kZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3Ige0BsaW5rIGxhc3ROfVxuICAgKiBAY2F0ZWdvcnkgUXVlcmllc1xuICAgKi9cbiAgYm90dG9tTjxGIGV4dGVuZHMgR2FtZUVsZW1lbnQ+KG46IG51bWJlciwgY2xhc3NOYW1lOiBFbGVtZW50Q2xhc3M8Rj4sIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXI8Rj5bXSk6IEVsZW1lbnRDb2xsZWN0aW9uPEY+O1xuICBib3R0b21OKG46IG51bWJlciwgY2xhc3NOYW1lPzogRWxlbWVudEZpbmRlciwgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcltdKTogRWxlbWVudENvbGxlY3Rpb248R2FtZUVsZW1lbnQ8RywgUD4+O1xuICBib3R0b21OKG46IG51bWJlciwgY2xhc3NOYW1lPzogYW55LCAuLi5maW5kZXJzOiBFbGVtZW50RmluZGVyW10pIHtcbiAgICByZXR1cm4gdGhpcy5fdC5jaGlsZHJlbi5ib3R0b21OKG4sIGNsYXNzTmFtZSwgLi4uZmluZGVycyk7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgXCJzaWJsaW5nXCIgZWxlbWVudHMgKGVsZW1lbnRzIHRoYXQgYXJlIGRpcmVjdGx5IGluc2lkZSB0aGUgcGFyZW50IG9mIHRoaXMgZWxlbWVudCkgdGhhdCBtYXRjaCB0aGUgYXJndW1lbnRzXG4gICAqIHByb3ZpZGVkLiBTZWUge0BsaW5rIGFsbH0gZm9yIHBhcmFtZXRlciBkZXRhaWxzLlxuICAgKiBAY2F0ZWdvcnkgUXVlcmllc1xuICAgKi9cbiAgb3RoZXJzPEYgZXh0ZW5kcyBHYW1lRWxlbWVudD4oY2xhc3NOYW1lOiBFbGVtZW50Q2xhc3M8Rj4sIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXI8Rj5bXSk6IEVsZW1lbnRDb2xsZWN0aW9uPEY+O1xuICBvdGhlcnMoY2xhc3NOYW1lPzogRWxlbWVudEZpbmRlciwgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcltdKTogRWxlbWVudENvbGxlY3Rpb248R2FtZUVsZW1lbnQ8RywgUD4+O1xuICBvdGhlcnMoY2xhc3NOYW1lPzogYW55LCAuLi5maW5kZXJzOiBFbGVtZW50RmluZGVyW10pIHtcbiAgICBpZiAoIXRoaXMuX3QucGFyZW50KSBuZXcgRWxlbWVudENvbGxlY3Rpb24oKTtcbiAgICByZXR1cm4gdGhpcy5fdC5wYXJlbnQhLl90LmNoaWxkcmVuLmFsbChjbGFzc05hbWUsIChlbDogR2FtZUVsZW1lbnQpID0+IGVsICE9PSB0aGlzLCAuLi5maW5kZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciBhbnkgZWxlbWVudCB3aXRoaW4gdGhpcyBlbGVtZW50IHJlY3Vyc2l2ZWx5IG1hdGNoZXMgdGhlIGFyZ3VtZW50c1xuICAgKiBwcm92aWRlZC4gU2VlIHtAbGluayBhbGx9IGZvciBwYXJhbWV0ZXIgZGV0YWlscy5cbiAgICogQGNhdGVnb3J5IFF1ZXJpZXNcbiAgICovXG4gIGhhczxGIGV4dGVuZHMgR2FtZUVsZW1lbnQ+KGNsYXNzTmFtZTogRWxlbWVudENsYXNzPEY+LCAuLi5maW5kZXJzOiBFbGVtZW50RmluZGVyPEY+W10pOiBib29sZWFuO1xuICBoYXMoY2xhc3NOYW1lPzogRWxlbWVudEZpbmRlciwgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcltdKTogYm9vbGVhbjtcbiAgaGFzKGNsYXNzTmFtZT86IGFueSwgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcltdKSB7XG4gICAgaWYgKCh0eXBlb2YgY2xhc3NOYW1lICE9PSAnZnVuY3Rpb24nKSB8fCAhKCdpc0dhbWVFbGVtZW50JyBpbiBjbGFzc05hbWUpKSB7XG4gICAgICBpZiAoY2xhc3NOYW1lKSBmaW5kZXJzID0gW2NsYXNzTmFtZSwgLi4uZmluZGVyc107XG4gICAgICByZXR1cm4gISF0aGlzLmZpcnN0KEdhbWVFbGVtZW50LCAuLi5maW5kZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuICEhdGhpcy5maXJzdChjbGFzc05hbWUsIC4uLmZpbmRlcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoaXMgZWxlbWVudCBpcyBhZGphY2VudCB0byBzb21lIG90aGVyIGVsZW1lbnQsIHVzaW5nIHRoZSBuZWFyZXN0XG4gICAqIGNvbnRhaW5pbmcgc3BhY2UgdGhhdCBoYXMgYW4gYWRqYWNlbmN5IG1hcC5cbiAgICogQGNhdGVnb3J5IEFkamFjZW5jeVxuICAgKi9cbiAgaXNBZGphY2VudFRvKGVsZW1lbnQ6IEdhbWVFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgY29uc3QgZ3JhcGggPSB0aGlzLmNvbnRhaW5lcldpdGhQcm9wZXJ0eSgnaXNBZGphY2VudCcpO1xuICAgIGlmICghZ3JhcGgpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKGdyYXBoIGFzIEFkamFjZW5jeVNwYWNlPEc+KS5pc0FkamFjZW50KHRoaXMsIGVsZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBzaG9ydGVzdCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBzcGFjZXNcbiAgICogQGNhdGVnb3J5IEFkamFjZW5jeVxuICAgKlxuICAgKiBAcGFyYW0gZWxlbWVudCAtIHtAbGluayBlbGVtZW50fSB0byBtZWFzdXJlIGRpc3RhbmNlIHRvXG4gICAqL1xuICBkaXN0YW5jZVRvKGVsZW1lbnQ6IEdhbWVFbGVtZW50KTogbnVtYmVyIHtcbiAgICBjb25zdCBncmFwaCA9IHRoaXMuY29udGFpbmVyV2l0aFByb3BlcnR5KCdkaXN0YW5jZUJldHdlZW4nKTtcbiAgICBpZiAoIWdyYXBoKSByZXR1cm4gSW5maW5pdHk7XG4gICAgcmV0dXJuIChncmFwaCBhcyBDb25uZWN0ZWRTcGFjZU1hcDxHPikuZGlzdGFuY2VCZXR3ZWVuKHRoaXMsIGVsZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYWxsIGVsZW1lbnRzIGFkamFjZW50IGJhc2VkIG9uIHJvdy9jb2x1bW4gcGxhY2VtZW50IG9yIGJhc2VkIG9uIHRoaXNcbiAgICogZWxlbWVudCBoYXZpbmcgY29ubmVjdGlvbnMgY3JlYXRlZCBieSBTcGFjZSNjb25uZWN0VG8uIFVzZXMgdGhlIHNhbWVcbiAgICogcGFyYW1ldGVycyBhcyB7QGxpbmsgR2FtZUVsZW1lbnQjYWxsfVxuICAgKiBAY2F0ZWdvcnkgQWRqYWNlbmN5XG4gICAqL1xuICBhZGphY2VuY2llczxGIGV4dGVuZHMgR2FtZUVsZW1lbnQ+KGNsYXNzTmFtZTogRWxlbWVudENsYXNzPEY+LCAuLi5maW5kZXJzOiBFbGVtZW50RmluZGVyPEY+W10pOiBFbGVtZW50Q29sbGVjdGlvbjxGPjtcbiAgYWRqYWNlbmNpZXMoY2xhc3NOYW1lPzogRWxlbWVudEZpbmRlciwgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcltdKTogRWxlbWVudENvbGxlY3Rpb248R2FtZUVsZW1lbnQ8RywgUD4+O1xuICBhZGphY2VuY2llcyhjbGFzc05hbWU/OiBhbnksIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXJbXSkge1xuICAgIGNvbnN0IGdyYXBoID0gdGhpcy5jb250YWluZXJXaXRoUHJvcGVydHkoJ2lzQWRqYWNlbnQnKSBhcyBBZGphY2VuY3lTcGFjZTxHPiB8IHVuZGVmaW5lZDtcbiAgICBpZiAoIWdyYXBoKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIChncmFwaCBhcyBDb25uZWN0ZWRTcGFjZU1hcDxHPikuYWxsQWRqYWNlbnRUbyh0aGlzLCBjbGFzc05hbWUsIC4uLmZpbmRlcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBzcGFjZXMgY29ubmVjdGVkIHRvIHRoaXMgc3BhY2UgYnkgYSBkaXN0YW5jZSBubyBtb3JlIHRoYW5cbiAgICogYGRpc3RhbmNlYFxuICAgKlxuICAgKiBAY2F0ZWdvcnkgQWRqYWNlbmN5XG4gICAqL1xuICB3aXRoaW5EaXN0YW5jZTxGIGV4dGVuZHMgR2FtZUVsZW1lbnQ+KGRpc3RhbmNlOiBudW1iZXIsIGNsYXNzTmFtZTogRWxlbWVudENsYXNzPEY+LCAuLi5maW5kZXJzOiBFbGVtZW50RmluZGVyPEY+W10pOiBFbGVtZW50Q29sbGVjdGlvbjxGPjtcbiAgd2l0aGluRGlzdGFuY2UoZGlzdGFuY2U6IG51bWJlciwgY2xhc3NOYW1lPzogRWxlbWVudEZpbmRlciwgLi4uZmluZGVyczogRWxlbWVudEZpbmRlcltdKTogRWxlbWVudENvbGxlY3Rpb248R2FtZUVsZW1lbnQ8RywgUD4+O1xuICB3aXRoaW5EaXN0YW5jZShkaXN0YW5jZTogbnVtYmVyLCBjbGFzc05hbWU/OiBhbnksIC4uLmZpbmRlcnM6IEVsZW1lbnRGaW5kZXJbXSkge1xuICAgIGNvbnN0IGdyYXBoID0gdGhpcy5jb250YWluZXJXaXRoUHJvcGVydHkoJ2FsbFdpdGhpbkRpc3RhbmNlT2YnKTtcbiAgICBpZiAoIWdyYXBoKSByZXR1cm4gbmV3IEVsZW1lbnRDb2xsZWN0aW9uKCk7XG4gICAgcmV0dXJuIChncmFwaCBhcyBDb25uZWN0ZWRTcGFjZU1hcDxHPikuYWxsV2l0aGluRGlzdGFuY2VPZih0aGlzLCBkaXN0YW5jZSwgY2xhc3NOYW1lLCAuLi5maW5kZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhpcyBjbGFzcyB0byB1c2UgYSBkaWZmZXJlbnQgb3JkZXJpbmcgc3R5bGUuXG4gICAqIEBjYXRlZ29yeSBTdHJ1Y3R1cmVcbiAgICogQHBhcmFtIG9yZGVyIC0gb3JkZXJpbmcgc3R5bGVcbiAgICogLSBcIm5vcm1hbFwiOiBFbGVtZW50cyBwbGFjZWQgaW50byB0aGlzIGVsZW1lbnQgYXJlIHB1dCBhdCB0aGUgZW5kIG9mIHRoZVxuICAgKiAgIGxpc3QgKGRlZmF1bHQpXG4gICAqIC0gXCJzdGFja2luZ1wiOiBVc2VkIHByaW1hcmlseSBmb3Igc3RhY2tzIG9mIGNhcmRzLiBFbGVtZW50cyBwbGFjZWQgaW50byB0aGlzXG4gICAqICAgZWxlbWVudCBhcmUgcHV0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3QuIEUuZy4gaWYgYSBzdGFjayBvZiBjYXJkc1xuICAgKiAgIGhhcyBgb3JkZXJgIHNldCB0byBgc3RhY2tpbmdgIHRoZSB7QGxpbmsgZmlyc3R9IG1ldGhvZCB3aWxsIHJldHVybiB0aGVcbiAgICogICBsYXN0IGNhcmQgcGxhY2VkIGluIHRoZSBzdGFjaywgcmF0aGVyIHRoYW4gdGhlIGZpcnN0IG9uZSBwbGFjZWQgaW4gdGhlXG4gICAqICAgc3RhY2suIEhpZGRlbiBpdGVtcyBpbiB0aGUgc3RhY2sgYXJlIG5vdCB0cmFja2VkIG9yIGFuaW1hdGVkIHdoaWxlXG4gICAqICAgcmVvcmRlcmVkIHRvIHByZXZlbnQgdGhlaXIgaWRlbnRpdHkgZnJvbSBiZWluZyBleHBvc2VkIGFzIHRoZXkgbW92ZVxuICAgKi9cbiAgc2V0T3JkZXIob3JkZXI6IHR5cGVvZiB0aGlzLl90Lm9yZGVyKSB7XG4gICAgdGhpcy5fdC5vcmRlciA9IG9yZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBlbGVtZW50cyBwYXJlbnQuXG4gICAqIEBjYXRlZ29yeSBRdWVyaWVzXG4gICAqIEBwYXJhbSBjbGFzc05hbWUgLSBJZiBwcm92aWRlZCwgc2VhcmNoZXMgdXAgdGhlIHBhcmVudCB0cmVlIHRvIGZpbmQgdGhlIGZpcnN0XG4gICAqIG1hdGNoaW5nIGVsZW1lbnQuIEUuZy4gaWYgYSBUb2tlbiBpcyBwbGFjZWQgb24gYSBDYXJkIGluIGEgcGxheWVyc1xuICAgKiBUYWJsZWF1LiBjYWxsaW5nIGB0b2tlbi5jb250YWluZXIoVGFibGVhdSlgIGNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlXG4gICAqIGdyYW5kcGFyZW50LlxuICAgKi9cbiAgY29udGFpbmVyPFQgZXh0ZW5kcyBHYW1lRWxlbWVudD4oY2xhc3NOYW1lPzogRWxlbWVudENsYXNzPFQ+KTogVCB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCFjbGFzc05hbWUpIHJldHVybiB0aGlzLl90LnBhcmVudCBhcyBUO1xuICAgIGlmICh0aGlzLl90LnBhcmVudCkgcmV0dXJuIHRoaXMuX3QucGFyZW50IGluc3RhbmNlb2YgY2xhc3NOYW1lID9cbiAgICAgIHRoaXMuX3QucGFyZW50IGFzIFQ6XG4gICAgICB0aGlzLl90LnBhcmVudC5jb250YWluZXIoY2xhc3NOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgZWxlbWVudHMgY29udGFpbmluZyBlbGVtZW50IHRoYXQgYWxzbyBoYXMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgICogQGNhdGVnb3J5IFF1ZXJpZXNcbiAgICovXG4gIGNvbnRhaW5lcldpdGhQcm9wZXJ0eShwcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZT86IGFueSk6IEdhbWVFbGVtZW50IHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl90LnBhcmVudDtcbiAgICBpZiAocGFyZW50KSByZXR1cm4gcHJvcGVydHkgaW4gcGFyZW50ICYmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHBhcmVudFtwcm9wZXJ0eSBhcyBrZXlvZiB0eXBlb2YgcGFyZW50XSA9PT0gdmFsdWUpID9cbiAgICAgIHBhcmVudDpcbiAgICAgIHBhcmVudC5jb250YWluZXJXaXRoUHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBlbGVtZW50IGhhcyBubyBlbGVtZW50cyBwbGFjZWQgd2l0aGluIGl0LlxuICAgKiBAY2F0ZWdvcnkgU3RydWN0dXJlXG4gICAqL1xuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiAhdGhpcy5fdC5jaGlsZHJlbi5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogU29ydHMgdGhlIGVsZW1lbnRzIGRpcmVjdGx5IGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBlbGVtZW50IGJ5IHNvbWUge0BsaW5rIFNvcnRlcn0uXG4gICAqIEBjYXRlZ29yeSBTdHJ1Y3R1cmVcbiAgICovXG4gIHNvcnRCeShrZXk6IEdlbmVyaWNTb3J0ZXIgfCBHZW5lcmljU29ydGVyW10sIGRpcmVjdGlvbj86IFwiYXNjXCIgfCBcImRlc2NcIik6IEVsZW1lbnRDb2xsZWN0aW9uPEdhbWVFbGVtZW50PEcsIFA+PiB7XG4gICAgcmV0dXJuIHRoaXMuX3QuY2hpbGRyZW4uc29ydEJ5KGtleSBhcyBTb3J0ZXI8R2FtZUVsZW1lbnQ+IHwgU29ydGVyPEdhbWVFbGVtZW50PltdLCBkaXJlY3Rpb24pIGFzIEVsZW1lbnRDb2xsZWN0aW9uPEdhbWVFbGVtZW50PEcsIFA+PlxuICB9XG5cbiAgLyoqXG4gICAqIHJlLW9yZGVycyB0aGUgZWxlbWVudHMgZGlyZWN0bHkgY29udGFpbmVkIHdpdGhpbiB0aGlzIGVsZW1lbnQgcmFuZG9tbHkuXG4gICAqIEBjYXRlZ29yeSBTdHJ1Y3R1cmVcbiAgICovXG4gIHNodWZmbGUoKSB7XG4gICAgY29uc3QgcmVmcyA9IHRoaXMuY2hpbGRSZWZzSWZPYnNjdXJlZCgpO1xuICAgIHNodWZmbGVBcnJheSh0aGlzLl90LmNoaWxkcmVuLCB0aGlzLl9jdHguZ2FtZU1hbmFnZXI/LnJhbmRvbSB8fCBNYXRoLnJhbmRvbSk7XG4gICAgaWYgKHJlZnMpIHRoaXMuYXNzaWduQ2hpbGRSZWZzKHJlZnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwbGF5ZXIgdGhhdCBvd25zIHRoaXMgZWxlbWVudCwgb3IgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGlzXG4gICAqIGVsZW1lbnQgc2VhcmNoaW5nIHVwIHRocm91Z2ggdGhlIHBhcmVudCBoaWVyYXJjaHkuIFRoaXMgaXMgcmVsYXRlZCB0bywgYnV0XG4gICAqIGRpZmZlcmVudCB0aGFuIHtAbGluayBwbGF5ZXJ9LiBFLmcuIGlmIGEgc3RhbmRhcmQgcGxheWluZyBjYXJkIGlzIGluIGFcbiAgICogcGxheWVyJ3MgaGFuZCwgdHlwaWNhbGx5IHRoZSBgaGFuZC5wbGF5ZXJgIHdpbGwgYmUgYXNzaWduZWQgdG8gdGhhdCBwbGF5ZXJcbiAgICogYnV0IHRoZSBjYXJkIGl0c2VsZiB3b3VsZCBub3QgaGF2ZSBhIGBwbGF5ZXJgLiBJbiB0aGlzIGNhc2UgdGhlXG4gICAqIGNhcmQub3duZXIoKSB3aWxsIGVxdWFsIHRoZSBwbGF5ZXIgaW4gd2hvc2UgaGFuZCB0aGUgY2FyZCBpcyBwbGFjZWQuXG4gICAqIEBjYXRlZ29yeSBTdHJ1Y3R1cmVcbiAgICovXG4gIGdldCBvd25lcigpOiBQIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXIgIT09IHVuZGVmaW5lZCA/IHRoaXMucGxheWVyIGFzIFAgOiB0aGlzLl90LnBhcmVudD8ub3duZXIgYXMgUDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgZWxlbWVudCBiZWxvbmdzIHRvIHRoZSBwbGF5ZXIgdmlld2luZyB0aGUgZ2FtZS4gQSBwbGF5ZXIgaXNcbiAgICogY29uc2lkZXJlZCB0byBiZSBjdXJyZW50bHkgdmlld2luZyB0aGUgZ2FtZSBpZiB0aGlzIGlzIGNhbGxlZCBpbiB0aGVcbiAgICogY29udGV4dCBvZiBhbiBhY3Rpb24gdGFrZW4gYnkgYSBnaXZlbiBwbGF5ZXIgKGR1cmluZyBhbiBhY3Rpb24gdGFrZW4gYnkgYVxuICAgKiBwbGF5ZXIgb3Igd2hpbGUgdGhlIGdhbWUgaXMgdmlld2VkIGJ5IGEgZ2l2ZW4gcGxheWVyLikgSXQgaXMgYW4gZXJyb3IgdG9cbiAgICogY2FsbCB0aGlzIG1ldGhvZCB3aGVuIG5vdCBpbiB0aGUgY29udGV4dCBvZiBhIHBsYXllciBhY3Rpb24uIFdoZW4gcXVlcnlpbmdcbiAgICogZm9yIGVsZW1lbnRzIHVzaW5nIHtAbGluayBFbGVtZW50RmluZGVyfSBzdWNoIGFzIHtAbGluayBhbGx9IGFuZCB7QGxpbmtcbiAgICogZmlyc3R9LCB7QGxpbmsgbWluZX0gaXMgYXZhaWxhYmxlIGFzIGEgc2VhcmNoIGtleSB0aGF0IGFjY2VwdHMgYSB2YWx1ZSBvZlxuICAgKiB0cnVlL2ZhbHNlXG4gICBAY2F0ZWdvcnkgUXVlcmllc1xuICAgKi9cbiAgZ2V0IG1pbmUoKSB7XG4gICAgaWYgKCF0aGlzLl9jdHgucGxheWVyKSByZXR1cm4gZmFsc2U7IC8vIHRocm93P1xuICAgIHJldHVybiB0aGlzLm93bmVyID09PSB0aGlzLl9jdHgucGxheWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlbGVtZW50IGluc2lkZSB0aGlzIGVsZW1lbnQuIFRoaXMgY2FuIG9ubHkgYmUgY2FsbGVkIGR1cmluZyB0aGVcbiAgICogZ2FtZSBzZXR1cCAoc2VlIHtAbGluayBjcmVhdGVHYW1lfS4gQW55IGdhbWUgZWxlbWVudHMgdGhhdCBhcmUgcmVxdWlyZWRcbiAgICogbXVzdCBiZSBjcmVhdGVkIGJlZm9yZSB0aGUgZ2FtZSBzdGFydHMuIEVsZW1lbnRzIHRoYXQgb25seSBhcHBlYXIgbGF0ZXIgaW5cbiAgICogdGhlIGdhbWUgY2FuIGJlIGNyZWF0ZWQgaW5zaWRlIHRoZSB7QGxpbmsgR2FtZSNwaWxlfSBvciBtYWRlIGludmlzaWJsZS5cbiAgICogQGNhdGVnb3J5IFN0cnVjdHVyZVxuICAgKlxuICAgKiBAcGFyYW0gY2xhc3NOYW1lIC0gQ2xhc3MgdG8gY3JlYXRlLiBUaGlzIGNsYXNzIG11c3QgYmUgaW5jbHVkZWQgaW4gdGhlIGBlbGVtZW50Q2xhc3Nlc2AgaW4ge0BsaW5rIGNyZWF0ZUdhbWV9LlxuICAgKiBAcGFyYW0gbmFtZSAtIFNldHMge0BsaW5rIEdhbWVFbGVtZW50I25hbWUgfCBuYW1lfVxuICAgKiBAcGFyYW0gYXR0cmlidXRlcyAtIFNldHMgYW55IGF0dHJpYnV0ZXMgb2YgdGhlIGNsYXNzIHRoYXQgYXJlIGRlZmluZWQgaW5cbiAgICogeW91ciBvd24gY2xhc3MgdGhhdCBleHRlbmQge0BsaW5rIFNwYWNlfSwge0BsaW5rIFBpZWNlfSwgb3Ige0BsaW5rXG4gICAqIEdhbWV9LiBDYW4gYWxzbyBpbmNsdWRlIHtAbGluayBwbGF5ZXJ9LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBkZWNrLmNyZWF0ZShDYXJkLCAnYWNlLW9mLWhlYXJ0cycsIHsgc3VpdDogJ0gnLCB2YWx1ZTogJzEnIH0pO1xuICAgKi9cbiAgY3JlYXRlPFQgZXh0ZW5kcyBHYW1lRWxlbWVudD4oY2xhc3NOYW1lOiBFbGVtZW50Q2xhc3M8VD4sIG5hbWU6IHN0cmluZywgYXR0cmlidXRlcz86IEVsZW1lbnRBdHRyaWJ1dGVzPFQ+KTogVCB7XG4gICAgaWYgKHRoaXMuX2N0eC5nYW1lTWFuYWdlcj8ucGhhc2UgPT09ICdzdGFydGVkJykgdGhyb3cgRXJyb3IoJ0dhbWUgZWxlbWVudHMgY2Fubm90IGJlIGNyZWF0ZWQgb25jZSBnYW1lIGhhcyBzdGFydGVkLicpO1xuICAgIGNvbnN0IGVsID0gdGhpcy5jcmVhdGVFbGVtZW50KGNsYXNzTmFtZSwgbmFtZSwgYXR0cmlidXRlcyk7XG4gICAgZWwuX3QucGFyZW50ID0gdGhpcztcbiAgICBjb25zdCBmaXJzdFBpZWNlID0gdGhpcy5fdC5jaGlsZHJlbi5maW5kSW5kZXgoYyA9PiAhKCdpc1NwYWNlJyBpbiBjKSk7XG4gICAgaWYgKHRoaXMuX3Qub3JkZXIgPT09ICdzdGFja2luZycgJiYgISgnaXNTcGFjZScgaW4gZWwpKSB7XG4gICAgICBpZiAoZmlyc3RQaWVjZSA+IDApIHtcbiAgICAgICAgdGhpcy5fdC5jaGlsZHJlbi5zcGxpY2UoZmlyc3RQaWVjZSwgMCwgZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdC5jaGlsZHJlbi51bnNoaWZ0KGVsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCdpc1NwYWNlJyBpbiBlbCAmJiBmaXJzdFBpZWNlICE9PSAtMSkge1xuICAgICAgICB0aGlzLl90LmNoaWxkcmVuLnNwbGljZShmaXJzdFBpZWNlLCAwLCBlbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3QuY2hpbGRyZW4ucHVzaChlbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgnaXNTcGFjZScgaW4gZWwgJiYgbmFtZSkge1xuICAgICAgaWYgKG5hbWUgaW4gdGhpcy5fY3R4LnVuaXF1ZU5hbWVzKSB7IC8vIG5vIGxvbmdlciB1bmlxdWVcbiAgICAgICAgZGVsZXRlIHRoaXMuX2N0eC5uYW1lZFNwYWNlc1tuYW1lXTtcbiAgICAgICAgdGhpcy5fY3R4LnVuaXF1ZU5hbWVzW25hbWVdID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2N0eC5uYW1lZFNwYWNlc1tuYW1lXSA9IGVsIGFzIHVua25vd24gYXMgU3BhY2U8R2FtZT47XG4gICAgICAgIHRoaXMuX2N0eC51bmlxdWVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbCBhcyBUO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBuIGVsZW1lbnRzIGluc2lkZSB0aGlzIGVsZW1lbnQgb2YgdGhlIHNhbWUgY2xhc3MuIFRoaXMgY2FuIG9ubHkgYmVcbiAgICogY2FsbGVkIGR1cmluZyB0aGUgZ2FtZSBzZXR1cCAoc2VlIHtAbGluayBjcmVhdGVHYW1lfS4gQW55IGdhbWUgZWxlbWVudHNcbiAgICogdGhhdCBhcmUgcmVxdWlyZWQgbXVzdCBiZSBjcmVhdGVkIGJlZm9yZSB0aGUgZ2FtZSBzdGFydHMuIEVsZW1lbnRzIHRoYXRcbiAgICogb25seSBhcHBlYXIgbGF0ZXIgaW4gdGhlIGdhbWUgY2FuIGJlIGNyZWF0ZWQgaW5zaWRlIHRoZSB7QGxpbmsgR2FtZSNwaWxlfVxuICAgKiBvciBtYWRlIGludmlzaWJsZS5cbiAgICogQGNhdGVnb3J5IFN0cnVjdHVyZVxuICAgKlxuICAgKiBAcGFyYW0gbiAtIE51bWJlciB0byBjcmVhdGVcbiAgICogQHBhcmFtIGNsYXNzTmFtZSAtIENsYXNzIHRvIGNyZWF0ZS4gVGhpcyBjbGFzcyBtdXN0IGJlIGluY2x1ZGVkIGluIHRoZSBgZWxlbWVudENsYXNzZXNgIGluIHtAbGluayBjcmVhdGVHYW1lfS5cbiAgICogQHBhcmFtIG5hbWUgLSBTZXRzIHtAbGluayBHYW1lRWxlbWVudCNuYW1lIHwgbmFtZX1cbiAgICogQHBhcmFtIGF0dHJpYnV0ZXMgLSBTZXRzIGFueSBhdHRyaWJ1dGVzIG9mIHRoZSBjbGFzcyB0aGF0IGFyZSBkZWZpbmVkIGluXG4gICAqIHlvdXIgb3duIGNsYXNzIHRoYXQgZXh0ZW5kIHtAbGluayBTcGFjZX0sIHtAbGluayBQaWVjZX0sIG9yIHtAbGlua1xuICAgKiBHYW1lfS4gQ2FuIGFsc28gaW5jbHVkZSB7QGxpbmsgcGxheWVyfS4gSWYgYSBmdW5jdGlvbiBpcyBzdXBwbGllZCBoZXJlLCBhXG4gICAqIHNpbmdsZSBudW1iZXIgYXJndW1lbnQgd2lsbCBiZSBwYXNzZWQgd2l0aCB0aGUgbnVtYmVyIG9mIHRoZSBhZGRlZCBlbGVtZW50LFxuICAgKiBzdGFydGluZyB3aXRoIDEuXG4gICAqL1xuICBjcmVhdGVNYW55PFQgZXh0ZW5kcyBHYW1lRWxlbWVudD4objogbnVtYmVyLCBjbGFzc05hbWU6IEVsZW1lbnRDbGFzczxUPiwgbmFtZTogc3RyaW5nLCBhdHRyaWJ1dGVzPzogRWxlbWVudEF0dHJpYnV0ZXM8VD4gfCAoKG46IG51bWJlcikgPT4gRWxlbWVudEF0dHJpYnV0ZXM8VD4pKTogRWxlbWVudENvbGxlY3Rpb248VD4ge1xuICAgIHJldHVybiBuZXcgRWxlbWVudENvbGxlY3Rpb248VD4oLi4udGltZXMobiwgaSA9PiB0aGlzLmNyZWF0ZShjbGFzc05hbWUsIG5hbWUsIHR5cGVvZiBhdHRyaWJ1dGVzID09PSAnZnVuY3Rpb24nID8gYXR0cmlidXRlcyhpKSA6IGF0dHJpYnV0ZXMpKSk7XG4gIH1cblxuICAvKipcbiAgICogQmFzZSBlbGVtZW50IGNyZWF0aW9uIG1ldGhvZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNyZWF0ZUVsZW1lbnQ8VCBleHRlbmRzIEdhbWVFbGVtZW50PihjbGFzc05hbWU6IEVsZW1lbnRDbGFzczxUPiwgbmFtZTogc3RyaW5nLCBhdHRycz86IEVsZW1lbnRBdHRyaWJ1dGVzPFQ+KTogVCB7XG4gICAgaWYgKCF0aGlzLl9jdHguY2xhc3NSZWdpc3RyeS5pbmNsdWRlcyhjbGFzc05hbWUpKSB7XG4gICAgICB0aGlzLl9jdHguY2xhc3NSZWdpc3RyeS5wdXNoKGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGVsID0gbmV3IGNsYXNzTmFtZSh0aGlzLl9jdHgpO1xuICAgIGVsLmdhbWUgPSB0aGlzLmdhbWU7XG4gICAgZWwubmFtZSA9IG5hbWU7XG4gICAgT2JqZWN0LmFzc2lnbihlbCwgYXR0cnMpO1xuICAgIGlmICgnYWZ0ZXJDcmVhdGlvbicgaW4gZWwpIChlbC5hZnRlckNyZWF0aW9uIGFzICgpID0+IHZvaWQpLmJpbmQoZWwpKCk7XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcm1hbmVudGx5IHJlbW92ZSBhbiBlbGVtZW50LiBUaGlzIGNhbiBvbmx5IGJlIGRvbmUgd2hpbGUgZGVmaW5pbmcgdGhlXG4gICAqIGdhbWUsIGFuZCBpcyB1c3VhbGx5IG9ubHkgdXNlZnVsIHdoZW4gY3JlYXRpbmcgZ3JvdXBzIG9mIGVsZW1lbnRzLCBzdWNoIGFzXG4gICAqIHtAbGluayBjcmVhdGVNYW55fSBvciB7QGxpbmsgY3JlYXRlR3JpZH0gd2hlcmUgc29tZSBvZiB0aGUgY3JlYXRlZCBlbGVtZW50c1xuICAgKiBhcmUgbm90IG5lZWRlZC5cbiAgICogQGNhdGVnb3J5IFN0cnVjdHVyZVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fY3R4LmdhbWVNYW5hZ2VyPy5waGFzZSA9PT0gJ3N0YXJ0ZWQnKSB0aHJvdyBFcnJvcignR2FtZSBlbGVtZW50cyBjYW5ub3QgYmUgZGVzdHJveSBvbmNlIGdhbWUgaGFzIHN0YXJ0ZWQuJyk7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgdGhpcy5fdC5wYXJlbnQ/Ll90LmNoaWxkcmVuLnNwbGljZShwb3NpdGlvbiwgMSk7XG4gIH1cblxuICAvKipcbiAgICogUm90YXRpb24gb2YgZWxlbWVudCBpZiBzZXQsIG5vcm1hbGl6ZWQgdG8gMC0zNTkgZGVncmVlc1xuICAgKiBAY2F0ZWdvcnkgU3RydWN0dXJlXG4gICAqL1xuICBnZXQgcm90YXRpb24oKSB7XG4gICAgaWYgKHRoaXMuX3JvdGF0aW9uID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICAgIHJldHVybiAodGhpcy5fcm90YXRpb24gJSAzNjAgKyAzNjApICUgMzYwO1xuICB9XG5cbiAgc2V0IHJvdGF0aW9uKHI6IG51bWJlcikge1xuICAgIHRoaXMuX3JvdGF0aW9uID0gcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGlzIGVsZW1lbnQgd2l0aGluIGl0cyBwYXJlbnQsIHN0YXJ0aW5nIGF0IHplcm9cbiAgICogQGNhdGVnb3J5IFN0cnVjdHVyZVxuICAgKi9cbiAgcG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3QucGFyZW50Py5fdC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpID8/IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgaWRlbnRpZnlpbmcgdGhlIHRyZWUgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgc3VpdGFibGUgZm9yXG4gICAqIGFub255bW91cyByZWZlcmVuY2VcbiAgICogQGludGVybmFsXG4gICAqL1xuICBicmFuY2goKSB7XG4gICAgY29uc3QgYnJhbmNoZXMgPSBbXTtcbiAgICBsZXQgbm9kZSA9IHRoaXMgYXMgR2FtZUVsZW1lbnQ7XG4gICAgd2hpbGUgKG5vZGUuX3QucGFyZW50KSB7XG4gICAgICBjb25zdCBpbmRleCA9IG5vZGUucG9zaXRpb24oKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHRocm93IEVycm9yKGBSZWZlcmVuY2UgdG8gZWxlbWVudCAke3RoaXMuY29uc3RydWN0b3IubmFtZX0ke3RoaXMubmFtZSA/ICc6JyArIHRoaXMubmFtZSA6ICcnfSBpcyBubyBsb25nZXIgY3VycmVudGApO1xuICAgICAgYnJhbmNoZXMudW5zaGlmdChpbmRleCk7XG4gICAgICBub2RlID0gbm9kZS5fdC5wYXJlbnQ7XG4gICAgfVxuICAgIGJyYW5jaGVzLnVuc2hpZnQodGhpcy5fY3R4LnJlbW92ZWQgPT09IG5vZGUgPyAxIDogMCk7XG4gICAgcmV0dXJuIGJyYW5jaGVzLmpvaW4oXCIvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIHJldHVybmVkIGJ5IHtAbGluayBicmFuY2h9XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXRCcmFuY2goYjogc3RyaW5nKSB7XG4gICAgbGV0IGJyYW5jaCA9IGIuc3BsaXQoJy8nKTtcbiAgICBsZXQgaW5kZXggPSBwYXJzZUludChicmFuY2hbMF0pO1xuICAgIGxldCBub2RlID0gaW5kZXggPT09IDAgPyB0aGlzLl9jdHgudG9wIDogdGhpcy5fY3R4LnJlbW92ZWQuX3QuY2hpbGRyZW5baW5kZXggLSAxXTtcbiAgICBicmFuY2guc2hpZnQoKTtcbiAgICB3aGlsZSAoYnJhbmNoWzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vZGUgPSBub2RlLl90LmNoaWxkcmVuW3BhcnNlSW50KGJyYW5jaFswXSldO1xuICAgICAgYnJhbmNoLnNoaWZ0KCk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVsZW1lbnQgZm9yIHRoZSBnaXZlbiBpZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGF0SUQoaWQ6IG51bWJlcik6IEdhbWVFbGVtZW50IHwgdW5kZWZpbmVkIHtcbiAgICBsZXQgZWwgPSB0aGlzLl90LmNoaWxkcmVuLmZpbmQoYyA9PiBjLl90LmlkID09PSBpZCk7XG4gICAgaWYgKGVsKSByZXR1cm4gZWw7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLl90LmNoaWxkcmVuKSB7XG4gICAgICBlbCA9IGNoaWxkLmF0SUQoaWQpO1xuICAgICAgaWYgKGVsKSByZXR1cm4gZWw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVsZW1lbnQgZm9yIHRoZSBnaXZlbiByZWZcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhdFJlZihyZWY6IG51bWJlcik6IEdhbWVFbGVtZW50IHwgdW5kZWZpbmVkIHtcbiAgICBsZXQgZWwgPSB0aGlzLl90LmNoaWxkcmVuLmZpbmQoYyA9PiBjLl90LnJlZiA9PT0gcmVmKTtcbiAgICBpZiAoZWwpIHJldHVybiBlbDtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuX3QuY2hpbGRyZW4pIHtcbiAgICAgIGVsID0gY2hpbGQuYXRSZWYocmVmKTtcbiAgICAgIGlmIChlbCkgcmV0dXJuIGVsO1xuICAgIH1cbiAgfVxuXG4gIF9jZWxsQXQocG9zOiBWZWN0b3IpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGlmICghdGhpcy5fc2l6ZSkgcmV0dXJuIHBvcy54ID09PSAwICYmIHBvcy55ID09PSAwID8gJy4nIDogdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLnJvdGF0aW9uID09PSAwKSByZXR1cm4gdGhpcy5fc2l6ZS5zaGFwZVtwb3MueV0/Lltwb3MueF07XG4gICAgaWYgKHRoaXMucm90YXRpb24gPT09IDkwKSByZXR1cm4gdGhpcy5fc2l6ZS5zaGFwZVt0aGlzLl9zaXplLmhlaWdodCAtIDEgLSBwb3MueF0/Lltwb3MueV07XG4gICAgaWYgKHRoaXMucm90YXRpb24gPT09IDE4MCkgcmV0dXJuIHRoaXMuX3NpemUuc2hhcGVbdGhpcy5fc2l6ZS5oZWlnaHQgLSAxIC0gcG9zLnldPy5bdGhpcy5fc2l6ZS53aWR0aCAtIDEgLSBwb3MueF07XG4gICAgaWYgKHRoaXMucm90YXRpb24gPT09IDI3MCkgcmV0dXJuIHRoaXMuX3NpemUuc2hhcGVbcG9zLnhdPy5bdGhpcy5fc2l6ZS53aWR0aCAtIDEgLSBwb3MueV07XG4gIH1cblxuICBfc2l6ZU5lZWRlZEZvcihfZWxlbWVudDogR2FtZUVsZW1lbnQpIHtcbiAgICByZXR1cm4ge3dpZHRoOiAxLCBoZWlnaHQ6IDF9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhbiBpcnJlZ3VsYXIgc2hhcGUgZm9yIHRoaXMgZWxlbWVudC4gVGhpcyBpcyBvbmx5IG1lYW5pbmdmdWwgZm9yIHRoZVxuICAgKiBwdXJwb3NlcyBvZiBmaW5kaW5nIHNwZWNpZmljYWxseSBhZGphY2VudCBjZWxscyB3aGVuIHBsYWNlZCBpbnRvIGFcbiAgICogUGllY2VHcmlkLiBTZWUge0BsaW5rIFBpZWNlR3JpZCNhZGphY2VuY2llc0J5Q2VsbH0uIFdoZW4gcmVuZGVyZWQgaW4gYVxuICAgKiBQaWVjZUdyaWQsIHRoZSBlbGVtZW50IHdpbGwgaGF2ZSBhIHNpemUgbGFyZ2UgZW5vdWdoIHRvIGZpbGwgdGhlXG4gICAqIGFwcHJvcHJpYXRlIG51bWJlciBvZiBzcGFjZXMgaW4gdGhlIGdyaWQsIGJ1dCBpdCdzIGFwcGVhcmFuY2UgaXMgb3RoZXJ3aXNlXG4gICAqIHVuYWZmZWN0ZWQgYW5kIHdpbGwgYmUgYmFzZWQgb24ge0BsaW5rIGFwcGVhcmFuY2V9LiBXaGVuIG5vdCByZW5kZXJlZCBpbiBhXG4gICAqIFBpZWNlR3JpZCwgdGhlIGVsZW1lbnQgd2lsbCB0YWtlIHVwIGEgc2luZ2xlIGNlbGwgYnV0IHdpbGwgYmUgc2NhbGVkXG4gICAqIHJlbGF0aXZlbHkgdG8gb3RoZXIgZWxlbWVudHMgd2l0aCBhIHNoYXBlIGluIHRoZSBzYW1lIGxheW91dC5cbiAgICpcbiAgICogQHBhcmFtIHNoYXBlIC0gQSBzZXQgb2Ygc2luZ2xlIGNoYXJhY3RlcnMgdXNlZCBhcyBsYWJlbHMgZm9yIGVhY2ggY2VsbC4gVGhlXG4gICAqIGNlbGwgbGFiZWwgY2hhcmFjdGVycyBhcmUgcHJvdmlkZWQgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncywgd2l0aCBlYWNoIHN0cmluZ1xuICAgKiBiZWluZyBvbmUgcm93IG9mIGNlbGwgbGFiZWxzLCB3aXRoIHNwYWNlcyB1c2VkIHRvIGluZGljYXRlIGVtcHR5IFwiaG9sZXNcIiBpblxuICAgKiB0aGUgc2hhcGUuIEVhY2ggcm93IG11c3QgYmUgdGhlIHNhbWUgbGVuZ3RoLiBUaGUgc3BlY2lmaWMgbm9uLXNwYWNlXG4gICAqIGNoYXJhY3RlcnMgdXNlZCBhcmUgdXNlZCBmb3IgbGFiZWxsaW5nIHRoZSBhZGphY2VuY2llcyBpbiB7QGxpbmtcbiAgICogUGllY2VHcmlkI2FkamFjZW5jaWVzQnlDZWxsfSBidXQgYXJlIG90aGVyd2lzZSB1bmltcG9ydGFudC5cbiAgICogQGNhdGVnb3J5IEFkamFjZW5jeVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBkb21pbm8xMi5zZXRTaGFwZShcbiAgICogICAnMTInXG4gICAqICk7XG5cbiAgICogdGV0cmlzUGllY2Uuc2V0U2hhcGUoXG4gICAqICAgJ1hYICcsXG4gICAqICAgJyBYWCdcbiAgICogKTtcbiAgICovXG4gIHNldFNoYXBlKC4uLnNoYXBlOiBzdHJpbmdbXSkge1xuICAgIGlmICh0aGlzLl9jdHguZ2FtZU1hbmFnZXI/LnBoYXNlID09PSAnc3RhcnRlZCcpIHRocm93IEVycm9yKCdDYW5ub3QgY2hhbmdlIHNoYXBlIG9uY2UgZ2FtZSBoYXMgc3RhcnRlZC4nKTtcbiAgICBpZiAoc2hhcGUuc29tZShzID0+IHMubGVuZ3RoICE9PSBzaGFwZVswXS5sZW5ndGgpKSB0aHJvdyBFcnJvcihcIkVhY2ggcm93IGluIHNoYXBlIG11c3QgYmUgc2FtZSBzaXplLiBJbnZhbGlkIHNoYXBlOlxcblwiICsgc2hhcGUpO1xuICAgIHRoaXMuX3NpemUgPSB7XG4gICAgICBzaGFwZSxcbiAgICAgIHdpZHRoOiBzaGFwZVswXS5sZW5ndGgsXG4gICAgICBoZWlnaHQ6IHNoYXBlLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGVkZ2UgbGFiZWxzIGZvciB0aGlzIGVsZW1lbnQuIFRoZXNlIGFyZSBvbmx5IG1lYW5pbmdmdWwgZm9yIHRoZVxuICAgKiBwdXJwb3NlcyBvZiBmaW5kaW5nIHNwZWNpZmljYWxseSBhZGphY2VudCBlZGdlcyB3aGVuIHBsYWNlZCBpbnRvIGFcbiAgICogUGllY2VHcmlkLiBTZWUge0BsaW5rIFBpZWNlR3JpZCNhZGphY2VuY2llc0J5RWRnZX0uXG4gICAqIEBjYXRlZ29yeSBBZGphY2VuY3lcbiAgICpcbiAgICogQHBhcmFtIGVkZ2VzIC0gQSBzZXQgb2YgZWRnZSBsYWJlbHMgZm9yIGVhY2ggY2VsbCBsYWJlbCBwcm92aWRlZCBieSB7QGxpbmtcbiAgICogc2V0U2hhcGV9LiBGb3Igc2ltcGxlIDEtY2VsbGVkIHNoYXBlcywgdGhlIGVkZ2VzIGNhbiBiZSBwcm92aWRlZCB3aXRob3V0XG4gICAqIGNlbGwgbGFiZWxzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAvLyBhIGJyaWRnZSB0aWxlIHdpdGggYSByb2FkIGxlYWRpbmcgZnJvbSBsZWZ0IHRvIHJpZ2h0IGFuZCBhIHJpdmVyIGxlYWRpbmdcbiAgICogLy8gZnJvbSB0b3AgdG8gYm90dG9tLlxuICAgKiBzaW1wbGVUaWxlLnNldEVkZ2UoXG4gICAqICAgdXA6ICdyaXZlcicsXG4gICAqICAgZG93bjogJ3JpdmVyJyxcbiAgICogICBsZWZ0OiAncm9hZCdcbiAgICogICByaWdodDogJ3JvYWQnXG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBBIHRldHJpcy1zaGFwZWQgdGlsZSB3aXRoIHNvY2tldHMgY29taW5nIG91dCBlaXRoZXIgXCJlbmRcIlxuICAgKiB0ZXRyaXNQaWVjZS5zZXRTaGFwZShcbiAgICogICAnQVggJyxcbiAgICogICAnIFhCJ1xuICAgKiApO1xuICAgKiB0ZXRyaXNQaWVjZS5zZXRFZGdlKHtcbiAgICogICBBOiB7XG4gICAqICAgICBsZWZ0OiAnc29ja2V0J1xuICAgKiAgIH0sXG4gICAqICAgQjoge1xuICAgKiAgICAgcmlnaHQ6ICdzb2NrZXQnXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICovXG4gIHNldEVkZ2VzKGVkZ2VzOiBSZWNvcmQ8c3RyaW5nLCBQYXJ0aWFsPFJlY29yZDxEaXJlY3Rpb24sIHN0cmluZz4+PiB8IFBhcnRpYWw8UmVjb3JkPERpcmVjdGlvbiwgc3RyaW5nPj4pIHtcbiAgICBpZiAodGhpcy5fY3R4LmdhbWVNYW5hZ2VyPy5waGFzZSA9PT0gJ3N0YXJ0ZWQnKSB0aHJvdyBFcnJvcignQ2Fubm90IGNoYW5nZSBzaGFwZSBvbmNlIGdhbWUgaGFzIHN0YXJ0ZWQuJyk7XG4gICAgaWYgKE9iamVjdC5rZXlzKGVkZ2VzKVswXS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IG1pc3NpbmdDZWxsID0gT2JqZWN0LmtleXMoZWRnZXMpLmZpbmQoYyA9PiB0aGlzLl9zaXplPy5zaGFwZS5ldmVyeShzID0+ICFzLmluY2x1ZGVzKGMpKSk7XG4gICAgICBpZiAobWlzc2luZ0NlbGwpIHRocm93IEVycm9yKGBObyBjZWxsICcke21pc3NpbmdDZWxsfScgZGVmaW5lZCBpbiBzaGFwZWApO1xuICAgICAgdGhpcy5fc2l6ZSEuZWRnZXMgPSBlZGdlcyBhcyBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8RGlyZWN0aW9uLCBzdHJpbmc+PjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX3NpemUpIHRocm93IEVycm9yKFwic2V0RWRnZXMgbXVzdCB1c2UgdGhlIGNlbGwgY2hhcmFjdGVycyBmcm9tIHNldFNoYXBlIGFzIGtleXNcIik7XG4gICAgICB0aGlzLl9zaXplID0ge3NoYXBlOiBbJy4nXSwgd2lkdGg6IDEsIGhlaWdodDogMSwgZWRnZXM6IHsnLic6IGVkZ2VzfX07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBlbGVtZW50IGhhcyB0aGUgZ2l2ZW4gZWxlbWVudCBpbiBpdHMgcGFyZW50IGhpZXJhcmNoeVxuICAgKiBAY2F0ZWdvcnkgU3RydWN0dXJlXG4gICAqL1xuICBpc0Rlc2NlbmRhbnRPZihlbDogR2FtZUVsZW1lbnQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fdC5wYXJlbnQgPT09IGVsIHx8ICEhdGhpcy5fdC5wYXJlbnQ/LmlzRGVzY2VuZGFudE9mKGVsKVxuICB9XG5cbiAgYXR0cmlidXRlTGlzdDxUIGV4dGVuZHMgR2FtZUVsZW1lbnQ+KHRoaXM6IFQpOiBFbGVtZW50QXR0cmlidXRlczxUPiB7XG4gICAgbGV0IGF0dHJzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgICh7IC4uLmF0dHJzIH0gPSB0aGlzKTtcbiAgICBmb3IgKGNvbnN0IGF0dHIgb2YgKHRoaXMuY29uc3RydWN0b3IgYXMgdHlwZW9mIEdhbWVFbGVtZW50KS51bnNlcmlhbGl6YWJsZUF0dHJpYnV0ZXMgYXMgc3RyaW5nW10pIGRlbGV0ZSBhdHRyc1thdHRyXTtcblxuICAgIC8vIHJlbW92ZSBtZXRob2RzXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhhdHRycykuZmlsdGVyKFxuICAgICAgKFssIHZhbHVlXSkgPT4gdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nXG4gICAgKSkgYXMgRWxlbWVudEF0dHJpYnV0ZXM8VD47XG4gIH1cblxuICAvKipcbiAgICogSlNPTiByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0gc2VlbkJ5IC0gb3B0aW9uYWwgcGxheWVyIHBvc2l0aW9uIHZpZXdpbmcgdGhlIGdhbWVcbiAgICogQGludGVybmFsXG4gICAqL1xuICB0b0pTT04oc2VlbkJ5PzogbnVtYmVyKSB7XG4gICAgbGV0IGF0dHJzID0gdGhpcy5hdHRyaWJ1dGVMaXN0KCk7XG5cbiAgICAvLyByZW1vdmUgaGlkZGVuIGF0dHJpYnV0ZXNcbiAgICBpZiAoc2VlbkJ5ICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuaXNWaXNpYmxlVG8oc2VlbkJ5KSkge1xuICAgICAgYXR0cnMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoYXR0cnMpLmZpbHRlcihcbiAgICAgICAgKFthdHRyXSkgPT4gWydfdmlzaWJsZScsICdyb3cnLCAnY29sdW1uJywgJ19yb3RhdGlvbicsICdfc2l6ZSddLmluY2x1ZGVzKGF0dHIpIHx8XG4gICAgICAgICAgKGF0dHIgIT09ICduYW1lJyAmJiAodGhpcy5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgR2FtZUVsZW1lbnQpLnZpc2libGVBdHRyaWJ1dGVzPy5pbmNsdWRlcyhhdHRyKSlcbiAgICAgICkpIGFzIHR5cGVvZiBhdHRycztcbiAgICB9XG4gICAgY29uc3QganNvbjogRWxlbWVudEpTT04gPSBPYmplY3QuYXNzaWduKHNlcmlhbGl6ZU9iamVjdChhdHRycywgc2VlbkJ5ICE9PSB1bmRlZmluZWQpLCB7IGNsYXNzTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH0pO1xuICAgIGlmICh0aGlzLl90Lm9yZGVyKSBqc29uLm9yZGVyID0gdGhpcy5fdC5vcmRlcjtcbiAgICBpZiAoc2VlbkJ5ID09PSB1bmRlZmluZWQpIGpzb24uX2lkID0gdGhpcy5fdC5pZDtcbiAgICBpZiAoanNvbi5faWQgIT09IHRoaXMuX3QucmVmKSBqc29uLl9yZWYgPSB0aGlzLl90LnJlZjtcbiAgICAvLyBkbyBub3QgZXhwb3NlIG1vdmVzIHdpdGhpbiBkZWNrIChzaHVmZmxlcylcbiAgICBpZiAoc2VlbkJ5ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fdC53YXNSZWYgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmlzVmlzaWJsZVRvKHNlZW5CeSkpIGpzb24uX3dhc1JlZiA9IHRoaXMuX3Qud2FzUmVmO1xuICAgIGlmICh0aGlzLl90LmNoaWxkcmVuLmxlbmd0aCAmJiAoXG4gICAgICAhc2VlbkJ5IHx8ICEoJ19zY3JlZW4nIGluIHRoaXMpIHx8IHRoaXMuX3NjcmVlbiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICh0aGlzLl9zY3JlZW4gPT09ICdhbGwtYnV0LW93bmVyJyAmJiB0aGlzLm93bmVyPy5wb3NpdGlvbiA9PT0gc2VlbkJ5KSB8fFxuICAgICAgICAodGhpcy5fc2NyZWVuIGluc3RhbmNlb2YgQXJyYXkgJiYgdGhpcy5fc2NyZWVuLmluY2x1ZGVzKHRoaXMub3duZXI/LnBvc2l0aW9uKSlcbiAgICApKSB7XG4gICAgICBqc29uLmNoaWxkcmVuID0gQXJyYXkuZnJvbSh0aGlzLl90LmNoaWxkcmVuLm1hcChjID0+IGMudG9KU09OKHNlZW5CeSkpKTtcbiAgICB9XG5cbiAgICBpZiAoZ2xvYmFsVGhpcy53aW5kb3cpIHsgLy8gZ3VhcmQtcmFpbCBpbiBkZXZcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0cnVjdHVyZWRDbG9uZShqc29uKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgaW52YWxpZCBwcm9wZXJ0aWVzIG9uICR7dGhpc306XFxuJHtKU09OLnN0cmluZ2lmeShqc29uLCB1bmRlZmluZWQsIDIpfWApO1xuICAgICAgICB0aHJvdyhlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBjcmVhdGVDaGlsZHJlbkZyb21KU09OKGNoaWxkcmVuSlNPTjogRWxlbWVudEpTT05bXSwgYnJhbmNoOiBzdHJpbmcpIHtcbiAgICAvLyBwcmVzZXJ2ZSBwcmV2aW91cyBjaGlsZHJlbiByZWZlcmVuY2VzXG4gICAgY29uc3QgY2hpbGRyZW5SZWZzID0gWy4uLnRoaXMuX3QuY2hpbGRyZW5dO1xuICAgIHRoaXMuX3QuY2hpbGRyZW4gPSBuZXcgRWxlbWVudENvbGxlY3Rpb248R2FtZUVsZW1lbnQ8RywgUD4+KCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gY2hpbGRyZW5KU09OLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBqc29uID0gY2hpbGRyZW5KU09OW2ldO1xuICAgICAgY29uc3QgY2hpbGRCcmFuY2ggPSBicmFuY2ggKyAnLycgKyBpO1xuICAgICAgbGV0IHsgY2xhc3NOYW1lLCBjaGlsZHJlbiwgX2lkLCBfcmVmLCBfd2FzUmVmLCBuYW1lLCBvcmRlciB9ID0ganNvbjtcbiAgICAgIC8vIHRyeSB0byBtYXRjaCBhbmQgcHJlc2VydmUgdGhlIG9iamVjdCBhbmQgYW55IHJlZmVyZW5jZXMuXG4gICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlblJlZnMuZmluZChjID0+IF9pZCAhPT0gdW5kZWZpbmVkID8gKGMuX3QuaWQgPT09IF9pZCkgOiAoYy5fdC5yZWYgPT09IChfd2FzUmVmID8/IF9yZWYpKSk7XG4gICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRDbGFzcyA9IHRoaXMuX2N0eC5jbGFzc1JlZ2lzdHJ5LmZpbmQoYyA9PiBjLm5hbWUgPT09IGNsYXNzTmFtZSk7XG4gICAgICAgIGlmICghZWxlbWVudENsYXNzKSB0aHJvdyBFcnJvcihgTm8gY2xhc3MgZm91bmQgJHtjbGFzc05hbWV9LiBEZWNsYXJlIGFueSBjbGFzc2VzIGluIFxcYGdhbWUucmVnaXN0ZXJDbGFzc2VzXFxgYCk7XG4gICAgICAgIGNoaWxkID0gdGhpcy5jcmVhdGVFbGVtZW50KGVsZW1lbnRDbGFzcywgbmFtZSk7XG4gICAgICAgIGNoaWxkLl90LnNldElkKF9pZCk7XG4gICAgICAgIGNoaWxkLl90LnBhcmVudCA9IHRoaXM7XG4gICAgICAgIGNoaWxkLl90Lm9yZGVyID0gb3JkZXI7XG4gICAgICAgIGNoaWxkLl90LnJlZiA9IF9yZWYgPz8gX2lkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFic2VudCBhdHRyaWJ1dGVzXG4gICAgICAgIGNvbnN0IGVtcHR5QXR0cnMgPSBPYmplY3Qua2V5cyhjaGlsZCkuZmlsdGVyKGsgPT4gIShrIGluIGpzb24pICYmICFbJ19yb3RhdGlvbicsICdjb2x1bW4nLCAncm93J10uaW5jbHVkZXMoaykgJiYgIShjaGlsZCEuY29uc3RydWN0b3IgYXMgdHlwZW9mIEdhbWVFbGVtZW50KS51bnNlcmlhbGl6YWJsZUF0dHJpYnV0ZXMuaW5jbHVkZXMoaykpO1xuICAgICAgICBpZiAoZW1wdHlBdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBibGFuayA9IFJlZmxlY3QuY29uc3RydWN0KGNoaWxkLmNvbnN0cnVjdG9yLCBbe31dKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgZW1wdHlBdHRycykgT2JqZWN0LmFzc2lnbihjaGlsZCwge1thdHRyXTogYmxhbmtbYXR0cl19KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF9pZCAhPT0gdW5kZWZpbmVkKSBjaGlsZC5fdC5yZWYgPSBfcmVmID8/IF9pZDtcbiAgICAgIGlmIChfd2FzUmVmICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuX2N0eC50cmFja01vdmVtZW50KSBjaGlsZC5fdC53YXNSZWYgPSBfd2FzUmVmO1xuICAgICAgdGhpcy5fdC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIGNoaWxkLmNyZWF0ZUNoaWxkcmVuRnJvbUpTT04oY2hpbGRyZW4gfHwgW10sIGNoaWxkQnJhbmNoKTtcbiAgICB9XG4gIH1cblxuICBhc3NpZ25BdHRyaWJ1dGVzRnJvbUpTT04oY2hpbGRyZW5KU09OOiBFbGVtZW50SlNPTltdLCBicmFuY2g6IHN0cmluZykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBjaGlsZHJlbkpTT04ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGpzb24gPSBjaGlsZHJlbkpTT05baV07XG4gICAgICBsZXQgeyBjbGFzc05hbWU6IF9jbiwgY2hpbGRyZW4sIF9yZWYsIF93YXNSZWYsIF9pZCwgb3JkZXI6IF9vLCAuLi5yZXN0IH0gPSBqc29uO1xuICAgICAgcmVzdCA9IGRlc2VyaWFsaXplT2JqZWN0KHsuLi5yZXN0fSwgdGhpcy5nYW1lKTtcbiAgICAgIGxldCBjaGlsZCA9IHRoaXMuX3QuY2hpbGRyZW5baV07XG4gICAgICBPYmplY3QuYXNzaWduKGNoaWxkLCByZXN0KTtcbiAgICAgIGNoaWxkLmFzc2lnbkF0dHJpYnV0ZXNGcm9tSlNPTihjaGlsZHJlbiB8fCBbXSwgYnJhbmNoICsgJy8nICsgaSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVJXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICBfdWk6IEVsZW1lbnRVSTx0aGlzPiA9IHtcbiAgICBsYXlvdXRzOiBbXSxcbiAgICBhcHBlYXJhbmNlOiB7fSxcbiAgICBnZXRCYXNlTGF5b3V0OiAoKSA9PiAoe1xuICAgICAgYWxpZ25tZW50OiAnY2VudGVyJyxcbiAgICAgIGRpcmVjdGlvbjogJ3NxdWFyZSdcbiAgICB9KSxcbiAgfTtcblxuICByZXNldFVJKCkge1xuICAgIHRoaXMuX3VpLmxheW91dHMgPSBbe1xuICAgICAgYXBwbHlUbzogR2FtZUVsZW1lbnQsXG4gICAgICBhdHRyaWJ1dGVzOiB0aGlzLl91aS5nZXRCYXNlTGF5b3V0KClcbiAgICB9XTtcbiAgICB0aGlzLl91aS5hcHBlYXJhbmNlID0ge307XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLl90LmNoaWxkcmVuKSBjaGlsZC5yZXNldFVJKCk7XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgYSBsYXlvdXQgdG8gc29tZSBvZiB0aGUgZWxlbWVudHMgZGlyZWN0bHkgY29udGFpbmVkIHdpdGhpbiB0aGlzXG4gICAqIGVsZW1lbnQuIFNlZSBhbHNvIHtAbGluayBFbGVtZW50Q29sbGVjdGlvbiNsYXlvdXR9XG4gICAqIEBjYXRlZ29yeSBVSVxuICAgKlxuICAgKiBAcGFyYW0gYXBwbHlUbyAtIFdoaWNoIGVsZW1lbnRzIHRoaXMgbGF5b3V0IGFwcGxpZXMgdG8uIFByb3ZpZGVkIHZhbHVlIGNhbiBiZTpcbiAgICogLSBBIHNwZWNpZmljIHtAbGluayBHYW1lRWxlbWVudH1cbiAgICogLSBUaGUgbmFtZSBvZiBhbiBlbGVtZW50XG4gICAqIC0gQSBzcGVjaWZpYyBzZXQgb2YgZWxlbWVudHMgKHtAbGluayBFbGVtZW50Q29sbGVjdGlvbn0pXG4gICAqIC0gQSBjbGFzcyBvZiBlbGVtZW50c1xuICAgKlxuICAgKiBJZiBtdWx0aXBsZSBsYXlvdXQgZGVjbGFyYXRpb25zIHdvdWxkIGFwcGx5IHRvIHRoZSBzYW1lIGVsZW1lbnQsIG9ubHkgb25lXG4gICAqIHdpbGwgYmUgdXNlZC4gVGhlIG9yZGVyIG9mIHNwZWNpZmljaXR5IGlzIGFzIGFib3ZlLiBJZiBhIGNsYXNzIGlzIHVzZWQgYW5kXG4gICAqIG11dGlwbGUgYXBwbHksIHRoZSBtb3JlIHNwZWNpZmljIGNsYXNzIHdpbGwgYmUgdXNlZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBBIGxpc3Qgb2YgYXR0cmlidXRlcyBkZXNjcmliaW5nIHRoZVxuICAgKiBsYXlvdXQuIEFsbCB1bml0cyBvZiBtZWFzdXJlbWVudCBhcmUgcGVyY2VudGFnZXMgb2YgdGhpcyBlbGVtZW50cyB3aWR0aCBhbmRcbiAgICogaGVpZ2h0IGZyb20gMC0xMDAsIHVubGVzcyBvdGhlcndpc2Ugbm90ZWQgKFNlZSBgbWFyZ2luYCBhbmQgYGdhcGApXG4gICAqL1xuICBsYXlvdXQoXG4gICAgYXBwbHlUbzogdHlwZW9mIHRoaXMuX3VpLmxheW91dHNbbnVtYmVyXVsnYXBwbHlUbyddLFxuICAgIGF0dHJpYnV0ZXM6IFBhcnRpYWw8TGF5b3V0QXR0cmlidXRlcz5cbiAgKSB7XG4gICAgbGV0IHtzbG90cywgYXJlYSwgc2l6ZSwgYXNwZWN0UmF0aW8sIHNjYWxpbmcsIGdhcCwgbWFyZ2luLCBvZmZzZXRDb2x1bW4sIG9mZnNldFJvd30gPSBhdHRyaWJ1dGVzXG4gICAgaWYgKHNsb3RzICYmIChhcmVhIHx8IG1hcmdpbiB8fCBzY2FsaW5nIHx8IGdhcCB8fCBtYXJnaW4gfHwgb2Zmc2V0Q29sdW1uIHx8IG9mZnNldFJvdykpIHtcbiAgICAgIGNvbnNvbGUud2FybignTGF5b3V0IGhhcyBgc2xvdHNgIHdoaWNoIG92ZXJyaWRlcyBzdXBwbGllZCBncmlkIHBhcmFtZXRlcnMnKTtcbiAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLmFyZWE7XG4gICAgICBkZWxldGUgYXR0cmlidXRlcy5tYXJnaW47XG4gICAgICBkZWxldGUgYXR0cmlidXRlcy5nYXA7XG4gICAgICBkZWxldGUgYXR0cmlidXRlcy5zY2FsaW5nO1xuICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMub2Zmc2V0Um93O1xuICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMub2Zmc2V0Q29sdW1uO1xuICAgIH1cbiAgICBpZiAoYXJlYSAmJiBtYXJnaW4pIHtcbiAgICAgIGNvbnNvbGUud2FybignQm90aCBgYXJlYWAgYW5kIGBtYXJnaW5gIHN1cHBsaWVkIGluIGxheW91dC4gYG1hcmdpbmAgaXMgaWdub3JlZCcpO1xuICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMubWFyZ2luO1xuICAgIH1cbiAgICBpZiAoc2l6ZSAmJiBhc3BlY3RSYXRpbykge1xuICAgICAgY29uc29sZS53YXJuKCdCb3RoIGBzaXplYCBhbmQgYGFzcGVjdFJhdGlvYCBzdXBwbGllZCBpbiBsYXlvdXQuIGBhc3BlY3RSYXRpb2AgaXMgaWdub3JlZCcpO1xuICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMuYXNwZWN0UmF0aW87XG4gICAgfVxuICAgIGlmIChzaXplICYmIHNjYWxpbmcpIHtcbiAgICAgIGNvbnNvbGUud2FybignQm90aCBgc2l6ZWAgYW5kIGBzY2FsaW5nYCBzdXBwbGllZCBpbiBsYXlvdXQuIGBzY2FsaW5nYCBpcyBpZ25vcmVkJyk7XG4gICAgICBkZWxldGUgYXR0cmlidXRlcy5zY2FsaW5nO1xuICAgIH1cbiAgICBpZiAoZ2FwICYmIChvZmZzZXRDb2x1bW4gfHwgb2Zmc2V0Um93KSkge1xuICAgICAgY29uc29sZS53YXJuKCdCb3RoIGBnYXBgIGFuZCBgb2Zmc2V0YCBzdXBwbGllZCBpbiBsYXlvdXQuIGBnYXBgIGlzIGlnbm9yZWQnKTtcbiAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLmdhcDtcbiAgICB9XG4gICAgdGhpcy5fdWkubGF5b3V0cy5wdXNoKHsgYXBwbHlUbywgYXR0cmlidXRlczogeyBhbGlnbm1lbnQ6ICdjZW50ZXInLCBkaXJlY3Rpb246ICdzcXVhcmUnLCAuLi5hdHRyaWJ1dGVzfSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29sbGFwc2libGUgZHJhd2VyIGxheW91dCBmb3IgYSBTcGFjZSB3aXRoaW4gdGhpcyBFbGVtZW50LiBUaGlzXG4gICAqIGlzIGxpa2Uge0BsaW5rIEdhbWVFbGVtZW50I2xheW91dH0gZXhjZXB0IGZvciBvbmUgc3BlY2lmaWMgU3BhY2UsIHdpdGhcbiAgICogYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRoYXQgc2V0IHRoZSBiZWhhdmlvdXIvYXBwZWFyYW5jZSBvZiB0aGUgZHJhd2VyLiBBXG4gICAqIHRhYiB3aWxsIGJlIGF0dGFjaGVkIHRoZSBkcmF3ZXIgdGhhdCB3aWxsIGFsbG93IGl0IGJlIG9wZW5lZC9jbG9zZWQuXG4gICAqXG4gICAqIEBwYXJhbSBhcHBseVRvIC0gVGhlIFNwYWNlIGZvciB0aGUgZHJhd2VyLiBFaXRoZXIgdGhlIFNwYWNlIGl0c2VsZiBvciBpdHNcbiAgICogbmFtZS5cbiAgICogQHBhcmFtIGFyZWEgLSBUaGUgYXJlYSBmb3IgdGhlIGRyYXdlciB3aGVuIG9wZW5lZCBleHByZXNzZWQgaW4gcGVyY2VudGFnZVxuICAgKiBzaXplcyBvZiB0aGlzIGVsZW1lbnQuXG4gICAqIEBwYXJhbSBvcGVuRGlyZWN0aW9uIC0gdGhlIGRpcmVjdGlvbiB0aGUgZHJhd2VyIHdpbGwgb3BlblxuICAgKiBAcGFyYW0gdGFiIC0gSlNYIGZvciB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgdGFiXG4gICAqIEBwYXJhbSBjbG9zZWRUYWIgLSBKU1ggZm9yIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSB0YWIgd2hlbiBjbG9zZWQgaWZcbiAgICogZGlmZmVyZW50XG4gICAqIEBwYXJhbSBvcGVuSWYgLSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjaGVja2VkIGF0IGVhY2ggZ2FtZSBzdGF0ZS4gSWYgaXRcbiAgICogcmV0dXJucyB0cnVlLCB0aGUgZHJhd2VyIHdpbGwgYXV0b21hdGljYWxseSBvcGVuLlxuICAgKiBAcGFyYW0gY2xvc2VJZiAtIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNoZWNrZWQgYXQgZWFjaCBnYW1lIHN0YXRlLiBJZiBpdFxuICAgKiByZXR1cm5zIHRydWUsIHRoZSBkcmF3ZXIgd2lsbCBhdXRvbWF0aWNhbGx5IGNsb3NlLlxuICAgKi9cbiAgbGF5b3V0QXNEcmF3ZXIoYXBwbHlUbzogU3BhY2U8RywgUD4gfCBzdHJpbmcsIGF0dHJpYnV0ZXM6IHtcbiAgICBhcmVhPzogQm94LFxuICAgIG9wZW5EaXJlY3Rpb246ICdsZWZ0JyB8ICdyaWdodCcgfCAnZG93bicgfCAndXAnLFxuICAgIHRhYj86IFJlYWN0LlJlYWN0Tm9kZSxcbiAgICBjbG9zZWRUYWI/OiBSZWFjdC5SZWFjdE5vZGUsXG4gICAgb3BlbklmPzogKGFjdGlvbnM6IHsgbmFtZTogc3RyaW5nLCBhcmdzOiBSZWNvcmQ8c3RyaW5nLCBBcmd1bWVudD4gfVtdKSA9PiBib29sZWFuLFxuICAgIGNsb3NlSWY/OiAoYWN0aW9uczogeyBuYW1lOiBzdHJpbmcsIGFyZ3M6IFJlY29yZDxzdHJpbmcsIEFyZ3VtZW50PiB9W10pID0+IGJvb2xlYW4sXG4gIH0pIHtcbiAgICBjb25zdCB7IGFyZWEsIC4uLmNvbnRhaW5lciB9ID0gYXR0cmlidXRlcztcbiAgICB0aGlzLmxheW91dChhcHBseVRvLCB7IGFyZWEsIF9fY29udGFpbmVyX186IHsgdHlwZTogJ2RyYXdlcicsIGF0dHJpYnV0ZXM6IGNvbnRhaW5lciB9fSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRhYmJlZCBsYXlvdXQgZm9yIGEgc2V0IG9mIFNwYWNlJ3Mgd2l0aGluIHRoaXMgRWxlbWVudC4gVGhpcyBpc1xuICAgKiBsaWtlIHtAbGluayBHYW1lRWxlbWVudCNsYXlvdXR9IGV4Y2VwdCBmb3IgYSBzZXQgb2YgU3BhY2VzLCB3aXRoIGFkZGl0aW9uYWxcbiAgICogcGFyYW1ldGVycyB0aGF0IHNldCB0aGUgYmVoYXZpb3VyL2FwcGVhcmFuY2Ugb2YgdGhlIHRhYnMuIEVhY2ggU3BhY2Ugd2lsbFxuICAgKiBiZSBsYWlkIG91dCBpbnRvIHRoZSBzYW1lIGFyZWEsIHdpdGggYSBzZXQgb2YgdGFicyBhdHRhY2hlZCB0byBhbGxvdyB0aGVcbiAgICogUGxheWVyIG9yIHRoZSBnYW1lIHJ1bGVzIHRvIHNlbGVjdCB3aGljaCB0YWIgaXMgc2hvd24uXG4gICAqXG4gICAqIEBwYXJhbSBhcHBseVRvIC0gVGhlIFNwYWNlcyBmb3IgdGhlIGRyYXdlciBhcyBhIHNldCBvZiBrZXktdmFsdWVcbiAgICogcGFpcnMuIEVhY2ggdmFsdWUgaXMgYSBTcGFjZSBvciBhIG5hbWUgb2YgYSBTcGFjZS5cbiAgICogQHBhcmFtIGFyZWEgLSBUaGUgYXJlYSBmb3IgdGhlIHRhYnMgZXhwcmVzc2VkIGluIHBlcmNlbnRhZ2Ugc2l6ZXMgb2YgdGhpc1xuICAgKiBlbGVtZW50LlxuICAgKiBAcGFyYW0gdGFiRGlyZWN0aW9uIC0gdGhlIHNpZGUgb24gd2hpY2ggdGhlIHRhYnMgd2lsbCBiZSBwbGFjZWRcbiAgICogQHBhcmFtIHRhYnMgLSBKU1ggZm9yIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSB0YWJzIGFzIGEgc2V0IG9mIGtleS12YWx1ZSBwYWlyc1xuICAgKiBAcGFyYW0gc2V0VGFiVG8gLSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjaGVja2VkIGF0IGVhY2ggZ2FtZSBzdGF0ZS4gSWYgaXRcbiAgICogcmV0dXJucyBhIHN0cmluZywgdGhlIHRhYiB3aXRoIHRoZSBtYXRjaGluZyBrZXkgd2lsbCBiZSBzaG93bi5cbiAgICovXG4gIGxheW91dEFzVGFicyh0YWJzOiBSZWNvcmQ8c3RyaW5nLCBTcGFjZTxHLCBQPiB8IHN0cmluZz4sIGF0dHJpYnV0ZXM6IHtcbiAgICBhcmVhPzogQm94LFxuICAgIHRhYkRpcmVjdGlvbjogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdkb3duJyB8ICd1cCcsXG4gICAgdGFicz86IFJlY29yZDxzdHJpbmcsIFJlYWN0LlJlYWN0Tm9kZT4sXG4gICAgc2V0VGFiVG8/OiAoYWN0aW9uczogeyBuYW1lOiBzdHJpbmcsIGFyZ3M6IFJlY29yZDxzdHJpbmcsIEFyZ3VtZW50PiB9W10pID0+IHN0cmluZyxcbiAgfSkge1xuICAgIGNvbnN0IHsgYXJlYSwgLi4uY29udGFpbmVyIH0gPSBhdHRyaWJ1dGVzO1xuICAgIGNvbnN0IGlkID0gdXVpZCgpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdGFiXSBvZiBPYmplY3QuZW50cmllcyh0YWJzKSkge1xuICAgICAgdGhpcy5sYXlvdXQodGFiLCB7IGFyZWEsIF9fY29udGFpbmVyX186IHsgdHlwZTogJ3RhYnMnLCBpZCwga2V5LCBhdHRyaWJ1dGVzOiBjb250YWluZXIgfX0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlcyBhIFNwYWNlIHdpdGhpbiB0aGlzIGVsZW1lbnQgYW5kIHJlcGxhY2VzIGl0IHdpdGggcG9wb3V0XG4gICAqIGJ1dHRvbi4gQ2xpY2tpbmcgb24gdGhlIGJ1dHRvbiBvcGVucyB0aGlzIFNwYWNlIGluIGEgZnVsbC1ib2FyZCBtb2RhbC4gVGhpc1xuICAgKiBpcyBsaWtlIHtAbGluayBHYW1lRWxlbWVudCNsYXlvdXR9IGV4Y2VwdCBmb3Igb25lIFNwYWNlLCB3aXRoIGFkZGl0aW9uYWxcbiAgICogcGFyYW1ldGVycyB0aGF0IHNldCB0aGUgYmVoYXZpb3VyL2FwcGVhcmFuY2Ugb2YgdGhlIHBvcG91dCBtb2RhbC5cbiAgICpcbiAgICogQHBhcmFtIGFwcGx5VG8gLSBUaGUgU3BhY2UgZm9yIHRoZSBwb3BvdXQuIEVpdGhlciBhIFNwYWNlIG9yIHRoZSBuYW1lIG9mIGFcbiAgICogU3BhY2UuXG4gICAqIEBwYXJhbSBhcmVhIC0gVGhlIGFyZWEgZm9yIHRoZSB0YWJzIGV4cHJlc3NlZCBpbiBwZXJjZW50YWdlIHNpemVzIG9mIHRoaXNcbiAgICogZWxlbWVudC5cbiAgICogQHBhcmFtIGJ1dHRvbiAtIEpTWCBmb3IgdGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHBvcG91dCBidXR0b25cbiAgICogQHBhcmFtIHBvcG91dE1hcmdpbiAtIEFsdGVyIHRoZSBkZWZhdWx0IG1hcmdpbiBhcm91bmQgdGhlIG9wZW5lZFxuICAgKiBwb3BvdXQuIFRha2VzIGEgcGVyY2VudGFnZSBvciBhbiBvYmplY3Qgd2l0aCBwZXJjZW50YWdlcyBmb3IgdG9wLCBib3R0b20sXG4gICAqIGxlZnQgYW5kIHJpZ2h0LlxuICAgKi9cbiAgbGF5b3V0QXNQb3BvdXQoYXBwbHlUbzogU3BhY2U8RywgUD4gfCBzdHJpbmcsIGF0dHJpYnV0ZXM6IHtcbiAgICBhcmVhPzogQm94LFxuICAgIGJ1dHRvbjogUmVhY3QuUmVhY3ROb2RlLFxuICAgIHBvcG91dE1hcmdpbj86IG51bWJlciB8IHsgdG9wOiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIgfSxcbiAgfSkge1xuICAgIGNvbnN0IHsgYXJlYSwgLi4uY29udGFpbmVyIH0gPSBhdHRyaWJ1dGVzO1xuICAgIHRoaXMubGF5b3V0KGFwcGx5VG8sIHsgYXJlYSwgX19jb250YWluZXJfXzogeyB0eXBlOiAncG9wb3V0JywgYXR0cmlidXRlczogY29udGFpbmVyIH19KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIGxheW91dCBhdHRyaWJ1dGVzIGZvciB0aGlzIHNwYWNlJ3MgbGF5b3V0LlxuICAgKiBAY2F0ZWdvcnkgVUlcbiAgICovXG4gIGNvbmZpZ3VyZUxheW91dChsYXlvdXRDb25maWd1cmF0aW9uOiBQYXJ0aWFsPExheW91dEF0dHJpYnV0ZXM+KSB7XG4gICAgdGhpcy5fdWkubGF5b3V0c1swXSA9IHtcbiAgICAgIGFwcGx5VG86IEdhbWVFbGVtZW50LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi50aGlzLl91aS5nZXRCYXNlTGF5b3V0KCksXG4gICAgICAgIC4uLmxheW91dENvbmZpZ3VyYXRpb24sXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgdGhlIGFwcGVhcmFuY2Ugb2YgdGhpcyBlbGVtZW50LiBBbnkgdmFsdWVzIHByb3ZpZGVkIG92ZXJyaWRlXG4gICAqIHByZXZpb3VzIG9uZXMuIFNlZSBhbHNvIHtAbGluayBFbGVtZW50Q29sbGVjdGlvbiNhcHBlYXJhbmNlfVxuICAgKiBAY2F0ZWdvcnkgVUlcbiAgICpcbiAgICogQHBhcmFtIGFwcGVhcmFuY2UgLSBQb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgKiBAcGFyYW0gYXBwZWFyYW5jZS5jbGFzc05hbWUgLSBBIGNsYXNzIG5hbWUgdG8gYWRkIHRvIHRoZSBkb20gZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0gYXBwZWFyYW5jZS5yZW5kZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhpcyBlbGVtZW50IGFzIGl0cyBvbmx5XG4gICAqIGFyZ3VtZW50IGFuZCByZXR1cm5zIEpTWCBmb3IgdGhlIGVsZW1lbnQuIFNlZSB7QGxpbmsgLi4vdWkvYXBwZWFyYW5jZX0gZm9yXG4gICAqIG1vcmUgb24gdXNhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBhcHBlYXJhbmNlLmFzcGVjdFJhdGlvIC0gVGhlIGFzcGVjdCByYXRpbyBmb3IgdGhpcyBlbGVtZW50LiBUaGlzXG4gICAqIHZhbHVlIGlzIGEgcmF0aW8gb2Ygd2lkdGggb3ZlciBoZWlnaHQuIEFsbCBsYXlvdXRzIGRlZmluZWQgaW4ge0BsaW5rXG4gICAqIGxheW91dH0gd2lsbCByZXNwZWN0IHRoaXMgYXNwZWN0IHJhdGlvLlxuICAgKlxuICAgKiBAcGFyYW0gYXBwZWFyYW5jZS5pbmZvIC0gUmV0dXJuIEpTWCBmb3IgbW9yZSBpbmZvIG9uIHRoaXMgZWxlbWVudC4gSWZcbiAgICogcmV0dXJuaW5nIHRydWUsIGFuIGluZm8gbW9kYWwgd2lsbCBiZSBhdmFpbGFibGUgZm9yIHRoaXMgZWxlbWVudCBidXQgd2l0aFxuICAgKiBvbmx5IHRoZSByZW5kZXJlZCBlbGVtZW50IGFuZCBubyB0ZXh0XG4gICAqXG4gICAqIEBwYXJhbSBhcHBlYXJhbmNlLmNvbm5lY3Rpb25zIC0gSWYgdGhlIGVsZW1lbnRzIGltbWVkaWF0ZWx5IHdpdGhpbiB0aGlzXG4gICAqIGVsZW1lbnQgYXJlIGNvbm5lY3RlZCB1c2luZyB7QGxpbmsgU3BhY2UjY29ubmVjdFRvfSwgdGhpcyBtYWtlcyB0aG9zZVxuICAgKiBjb25uZWN0aW9ucyB2aXNpYmxlIGFzIGNvbm5lY3RpbmcgbGluZXMuIFByb3ZpZGluZyBhIGBsYWJlbGAgd2lsbCBwbGFjZSBhXG4gICAqIGxhYmVsIG92ZXIgdG9wIG9mIHRoaXMgbGluZSBieSBjYWxsaW5nIHRoZSBwcm92aWRlZCBmdW5jdGlvbiB3aXRoIHRoZVxuICAgKiBkaXN0YW5jZSBvZiB0aGUgY29ubmVjdGlvbiBzcGVjaWZpZWQgaW4ge0BsaW5rIFNwYWNlI2Nvbm5lY3RUb30gYW5kIHVzaW5nXG4gICAqIHRoZSByZXR1cmVkIEpTWC4gSWYgYGxhYmVsU2NhbGVgIGlzIHByb3ZpZGVkLCB0aGUgbGFiZWwgaXMgc2NhbGVkIGJ5IHRoaXNcbiAgICogYW1vdW50LlxuICAgKlxuICAgKiBAcGFyYW0gYXBwZWFyYW5jZS5lZmZlY3RzIC0gUHJvdmlkZXMgYSBDU1MgY2xhc3MgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG9cbiAgICogdGhpcyBlbGVtZW50IGlmIGl0cyBhdHRyaWJ1dGVzIGNoYW5nZSB0byBtYXRjaCB0aGUgcHJvdmlkZWQgb25lcy5cbiAgICovXG4gIGFwcGVhcmFuY2UoYXBwZWFyYW5jZTogRWxlbWVudFVJPHRoaXM+WydhcHBlYXJhbmNlJ10pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuX3VpLmFwcGVhcmFuY2UsIGFwcGVhcmFuY2UpO1xuICB9XG5cbiAgY2hpbGRSZWZzSWZPYnNjdXJlZCgpIHtcbiAgICBpZiAodGhpcy5fdC5vcmRlciAhPT0gJ3N0YWNraW5nJykgcmV0dXJuO1xuICAgIGNvbnN0IHJlZnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuX3QuY2hpbGRyZW4pIHtcbiAgICAgIGlmICh0aGlzLl9jdHgudHJhY2tNb3ZlbWVudCkgY2hpbGQuX3Qud2FzUmVmID8/PSBjaGlsZC5fdC5yZWY7XG4gICAgICByZWZzLnB1c2goY2hpbGQuX3QucmVmKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZnM7XG4gIH1cblxuICBhc3NpZ25DaGlsZFJlZnMocmVmczogbnVtYmVyW10pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSAhPSByZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl90LmNoaWxkcmVuW2ldLl90LnJlZiA9IHJlZnNbaV07XG4gICAgfVxuICB9XG5cbiAgaGFzTW92ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3QubW92ZWQgfHwgISF0aGlzLl90LnBhcmVudD8uaGFzTW92ZWQoKTtcbiAgfVxuXG4gIHJlc2V0TW92ZW1lbnRUcmFja2luZygpIHtcbiAgICB0aGlzLl90Lm1vdmVkID0gZmFsc2VcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuX3QuY2hpbGRyZW4pIGNoaWxkLnJlc2V0TW92ZW1lbnRUcmFja2luZygpO1xuICB9XG5cbiAgcmVzZXRSZWZUcmFja2luZygpIHtcbiAgICBkZWxldGUgdGhpcy5fdC53YXNSZWY7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLl90LmNoaWxkcmVuKSBjaGlsZC5yZXNldFJlZlRyYWNraW5nKCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgR2FtZUVsZW1lbnQgZnJvbSAnLi9lbGVtZW50LmpzJ1xuXG5pbXBvcnQgdHlwZSB7IEJhc2VHYW1lIH0gZnJvbSAnLi9nYW1lLmpzJztcbmltcG9ydCB0eXBlIFBsYXllciBmcm9tICcuLi9wbGF5ZXIvcGxheWVyLmpzJztcbmltcG9ydCB0eXBlIHsgRWxlbWVudENsYXNzLCBFbGVtZW50QXR0cmlidXRlcyB9IGZyb20gJy4vZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBQaWVjZSB9IGZyb20gJy4uL2luZGV4LmpzJztcblxuZXhwb3J0IHR5cGUgRWxlbWVudEV2ZW50SGFuZGxlcjxUIGV4dGVuZHMgR2FtZUVsZW1lbnQ+ID0ge2NhbGxiYWNrOiAoZWw6IFQpID0+IHZvaWR9ICYgUmVjb3JkPGFueSwgYW55PjtcblxuLyoqXG4gKiBTcGFjZXMgYXJlIGFyZWFzIG9mIHRoZSBnYW1lLiBUaGUgc3BhY2VzIG9mIHlvdXIgZ2FtZSBhcmUgZGVjbGFyZWQgZHVyaW5nXG4gKiBzZXR1cCBpbiB7QGxpbmsgY3JlYXRlR2FtZX0gYW5kIG5ldmVyIGNoYW5nZSBkdXJpbmcgcGxheS5cbiAqIEBjYXRlZ29yeSBCb2FyZFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGFjZTxHIGV4dGVuZHMgQmFzZUdhbWUsIFAgZXh0ZW5kcyBQbGF5ZXIgPSBOb25OdWxsYWJsZTxHWydwbGF5ZXInXT4+IGV4dGVuZHMgR2FtZUVsZW1lbnQ8RywgUD4ge1xuXG4gIHN0YXRpYyB1bnNlcmlhbGl6YWJsZUF0dHJpYnV0ZXMgPSBbLi4uR2FtZUVsZW1lbnQudW5zZXJpYWxpemFibGVBdHRyaWJ1dGVzLCAnX2V2ZW50SGFuZGxlcnMnLCAnX3Zpc09uRW50ZXInLCAnX3NjcmVlbiddO1xuXG4gIF9ldmVudEhhbmRsZXJzOiB7XG4gICAgZW50ZXI6IEVsZW1lbnRFdmVudEhhbmRsZXI8R2FtZUVsZW1lbnQ+W10sXG4gICAgZXhpdDogRWxlbWVudEV2ZW50SGFuZGxlcjxHYW1lRWxlbWVudD5bXSxcbiAgfSA9IHsgZW50ZXI6IFtdLCBleGl0OiBbXSB9O1xuXG4gIF92aXNPbkVudGVyPzoge1xuICAgIGRlZmF1bHQ6IGJvb2xlYW4sXG4gICAgZXhjZXB0PzogbnVtYmVyW10gfCAnb3duZXInXG4gIH1cblxuICBfc2NyZWVuPzogJ2FsbCcgfCAnYWxsLWJ1dC1vd25lcicgfCBudW1iZXJbXTtcblxuICAvKipcbiAgICogU2hvdyBwaWVjZXMgdG8gYWxsIHBsYXllcnMgd2hlbiB0aGV5IGVudGVyIHRoaXMgc3BhY2VcbiAgICogQGNhdGVnb3J5IFZpc2liaWxpdHlcbiAgICovXG4gIGNvbnRlbnRzV2lsbEJlU2hvd24oKSB7XG4gICAgdGhpcy5fdmlzT25FbnRlciA9IHtkZWZhdWx0OiB0cnVlfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93IHBpZWNlcyB3aGVuIHRoZXkgZW50ZXIgdGhpcyBzcGFjZSB0byBpdHMgb3duZXJcbiAgICogQGNhdGVnb3J5IFZpc2liaWxpdHlcbiAgICovXG4gIGNvbnRlbnRzV2lsbEJlU2hvd25Ub093bmVyKCkge1xuICAgIHRoaXMuX3Zpc09uRW50ZXIgPSB7ZGVmYXVsdDogZmFsc2UsIGV4Y2VwdDogJ293bmVyJ307XG4gIH1cblxuICAvKipcbiAgICogU2hvdyBwaWVjZSB0byB0aGVzZSBwbGF5ZXJzIHdoZW4gdGhleSBlbnRlciB0aGlzIHNwYWNlXG4gICAqIEBjYXRlZ29yeSBWaXNpYmlsaXR5XG4gICAqL1xuICBjb250ZW50c1dpbGxCZVNob3duVG8oLi4ucGxheWVyczogUFtdKSB7XG4gICAgdGhpcy5fdmlzT25FbnRlciA9IHtkZWZhdWx0OiBmYWxzZSwgZXhjZXB0OiBwbGF5ZXJzLm1hcChwID0+IHAucG9zaXRpb24pfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlIHBpZWNlcyB0byBhbGwgcGxheWVycyB3aGVuIHRoZXkgZW50ZXIgdGhpcyBzcGFjZVxuICAgKiBAY2F0ZWdvcnkgVmlzaWJpbGl0eVxuICAgKi9cbiAgY29udGVudHNXaWxsQmVIaWRkZW4oKSB7XG4gICAgdGhpcy5fdmlzT25FbnRlciA9IHtkZWZhdWx0OiBmYWxzZX07XG4gIH1cblxuICAvKipcbiAgICogSGlkZSBwaWVjZSB0byB0aGVzZSBwbGF5ZXJzIHdoZW4gdGhleSBlbnRlciB0aGlzIHNwYWNlXG4gICAqIEBjYXRlZ29yeSBWaXNpYmlsaXR5XG4gICAqL1xuICBjb250ZW50c1dpbGxCZUhpZGRlbkZyb20oLi4ucGxheWVyczogUFtdKSB7XG4gICAgdGhpcy5fdmlzT25FbnRlciA9IHtkZWZhdWx0OiB0cnVlLCBleGNlcHQ6IHBsYXllcnMubWFwKHAgPT4gcC5wb3NpdGlvbil9O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgdGhpcyB0byBzY3JlZW4gdmlldyBjb21wbGV0ZWx5IGZyb20gcGxheWVycy4gQmxvY2tlZCBzcGFjZXMgY29tcGxldGVseVxuICAgKiBoaWRlIHRoZWlyIGNvbnRlbnRzLCBsaWtlIGEgcGh5c2ljYWwgc2NyZWVuLiBObyBpbmZvcm1hdGlvbiBhYm91dCB0aGVcbiAgICogbnVtYmVyLCB0eXBlIG9yIG1vdmVtZW50IG9mIGNvbnRlbnRzIGluc2lkZSB0aGlzIFNwYWNlIHdpbGwgYmUgcmV2ZWFsZWQgdG9cbiAgICogdGhlIHNwZWNpZmllZCBwbGF5ZXJzXG4gICAqXG4gICAqIEBwYXJhbSBwbGF5ZXJzID0gUGxheWVycyBmb3Igd2hvbSB0aGUgdmlldyBpcyBibG9ja2VkXG4gICAqIEBjYXRlZ29yeSBWaXNpYmlsaXR5XG4gICAqL1xuICBibG9ja1ZpZXdGb3IocGxheWVyczogJ2FsbCcgfCAnbm9uZScgfCAnYWxsLWJ1dC1vd25lcicgfCBQbGF5ZXJbXSkge1xuICAgIHRoaXMuX3NjcmVlbiA9IHBsYXllcnMgPT09ICdub25lJyA/IHVuZGVmaW5lZCA6IHBsYXllcnMgaW5zdGFuY2VvZiBBcnJheSA/IHBsYXllcnMubWFwKHAgPT4gcC5wb3NpdGlvbikgOiBwbGF5ZXJzXG4gIH1cblxuICBpc1NwYWNlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIGNyZWF0ZTxUIGV4dGVuZHMgR2FtZUVsZW1lbnQ+KGNsYXNzTmFtZTogRWxlbWVudENsYXNzPFQ+LCBuYW1lOiBzdHJpbmcsIGF0dHJpYnV0ZXM/OiBFbGVtZW50QXR0cmlidXRlczxUPik6IFQge1xuICAgIGNvbnN0IGVsID0gc3VwZXIuY3JlYXRlKGNsYXNzTmFtZSwgbmFtZSwgYXR0cmlidXRlcyk7XG4gICAgaWYgKCdzaG93VG8nIGluIGVsKSB0aGlzLnRyaWdnZXJFdmVudChcImVudGVyXCIsIGVsIGFzIHVua25vd24gYXMgUGllY2U8Rz4pO1xuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIGFkZEV2ZW50SGFuZGxlcjxUIGV4dGVuZHMgR2FtZUVsZW1lbnQ+KHR5cGU6IGtleW9mIFNwYWNlPEc+WydfZXZlbnRIYW5kbGVycyddLCBoYW5kbGVyOiBFbGVtZW50RXZlbnRIYW5kbGVyPFQ+KSB7XG4gICAgaWYgKHRoaXMuX2N0eC5nYW1lTWFuYWdlcj8ucGhhc2UgPT09ICdzdGFydGVkJykgdGhyb3cgRXJyb3IoJ0V2ZW50IGhhbmRsZXJzIGNhbm5vdCBiZSBhZGRlZCBvbmNlIGdhbWUgaGFzIHN0YXJ0ZWQuJyk7XG4gICAgdGhpcy5fZXZlbnRIYW5kbGVyc1t0eXBlXS5wdXNoKGhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCBhIGNhbGxiYWNrIHRvIHRoaXMgc3BhY2UgZm9yIGV2ZXJ5IGVsZW1lbnQgdGhhdCBlbnRlcnMgb3IgaXMgY3JlYXRlZFxuICAgKiB3aXRoaW4uXG4gICAqIEBjYXRlZ29yeSBTdHJ1Y3R1cmVcbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSB0aGUgY2xhc3Mgb2YgZWxlbWVudCB0aGF0IHdpbGwgdHJpZ2dlciB0aGlzIGNhbGxiYWNrXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGVhY2ggdGltZSBhbiBlbGVtZW50IGVudGVycywgd2l0aFxuICAgKiB0aGUgZW50ZXJpbmcgZWxlbWVudCBhcyB0aGUgb25seSBhcmd1bWVudC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZGVjay5vbkVudGVyKENhcmQsIGNhcmQgPT4gY2FyZC5oaWRlRnJvbUFsbCgpKSAvLyBjYXJkIHBsYWNlZCBpbiB0aGUgZGVjayBhcmUgYXV0b21hdGljYWxseSB0dXJuZWQgZmFjZSBkb3duXG4gICAqL1xuICBvbkVudGVyPFQgZXh0ZW5kcyBHYW1lRWxlbWVudD4odHlwZTogRWxlbWVudENsYXNzPFQ+LCBjYWxsYmFjazogKGVsOiBUKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5hZGRFdmVudEhhbmRsZXI8VD4oXCJlbnRlclwiLCB7IGNhbGxiYWNrLCB0eXBlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCBhIGNhbGxiYWNrIHRvIHRoaXMgc3BhY2UgZm9yIGV2ZXJ5IGVsZW1lbnQgdGhhdCBpcyBtb3ZlZCBvdXQgb2YgdGhpc1xuICAgKiBzcGFjZS5cbiAgICogQGNhdGVnb3J5IFN0cnVjdHVyZVxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIHRoZSBjbGFzcyBvZiBlbGVtZW50IHRoYXQgd2lsbCB0cmlnZ2VyIHRoaXMgY2FsbGJhY2tcbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gQ2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgZWFjaCB0aW1lIGFuIGVsZW1lbnQgZXhpdHMsIHdpdGhcbiAgICogdGhlIGV4aXRpbmcgZWxlbWVudCBhcyB0aGUgb25seSBhcmd1bWVudC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZGVjay5vbkV4aXQoQ2FyZCwgY2FyZCA9PiBjYXJkLnNob3dUb0FsbCgpKSAvLyBjYXJkcyBkcmF3biBmcm9tIHRoZSBkZWNrIGFyZSBhdXRvbWF0aWNhbGx5IHR1cm5lZCBmYWNlIHVwXG4gICAqL1xuICBvbkV4aXQ8VCBleHRlbmRzIEdhbWVFbGVtZW50Pih0eXBlOiBFbGVtZW50Q2xhc3M8VD4sIGNhbGxiYWNrOiAoZWw6IFQpID0+IHZvaWQpIHtcbiAgICB0aGlzLmFkZEV2ZW50SGFuZGxlcjxUPihcImV4aXRcIiwgeyBjYWxsYmFjaywgdHlwZSB9KTtcbiAgfVxuXG4gIHRyaWdnZXJFdmVudChldmVudDoga2V5b2YgU3BhY2U8Rz5bJ19ldmVudEhhbmRsZXJzJ10sIGVsZW1lbnQ6IFBpZWNlPEc+KSB7XG4gICAgaWYgKHRoaXMuX3Zpc09uRW50ZXIpIHtcbiAgICAgIGVsZW1lbnQuX3Zpc2libGUgPSB7XG4gICAgICAgIGRlZmF1bHQ6IHRoaXMuX3Zpc09uRW50ZXIuZGVmYXVsdCxcbiAgICAgICAgZXhjZXB0OiB0aGlzLl92aXNPbkVudGVyLmV4Y2VwdCA9PT0gJ293bmVyJyA/ICh0aGlzLm93bmVyID8gW3RoaXMub3duZXIucG9zaXRpb25dIDogdW5kZWZpbmVkKSA6IHRoaXMuX3Zpc09uRW50ZXIuZXhjZXB0XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHRoaXMuX2V2ZW50SGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICBpZiAoZXZlbnQgPT09ICdlbnRlcicgJiYgIShlbGVtZW50IGluc3RhbmNlb2YgaGFuZGxlci50eXBlKSkgY29udGludWU7XG4gICAgICBpZiAoZXZlbnQgPT09ICdleGl0JyAmJiAhKGVsZW1lbnQgaW5zdGFuY2VvZiBoYW5kbGVyLnR5cGUpKSBjb250aW51ZTtcbiAgICAgIGhhbmRsZXIuY2FsbGJhY2soZWxlbWVudCk7XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IEdhbWVFbGVtZW50IGZyb20gJy4vZWxlbWVudC5qcydcbmltcG9ydCBTcGFjZSBmcm9tICcuL3NwYWNlLmpzJ1xuXG5pbXBvcnQgdHlwZSB7IEVsZW1lbnRBdHRyaWJ1dGVzLCBFbGVtZW50Q2xhc3MgfSBmcm9tICcuL2VsZW1lbnQuanMnXG5pbXBvcnQgdHlwZSBHYW1lIGZyb20gJy4vZ2FtZS5qcydcbmltcG9ydCB0eXBlIFBsYXllciBmcm9tICcuLi9wbGF5ZXIvcGxheWVyLmpzJztcbmltcG9ydCB0eXBlIHsgQmFzZUdhbWUgfSBmcm9tICcuL2dhbWUuanMnO1xuXG4vKipcbiAqIFBpZWNlcyBhcmUgZ2FtZSBlbGVtZW50cyB0aGF0IGNhbiBtb3ZlIGR1cmluZyBwbGF5XG4gKiBAY2F0ZWdvcnkgQm9hcmRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGllY2U8RyBleHRlbmRzIEdhbWUsIFAgZXh0ZW5kcyBQbGF5ZXIgPSBOb25OdWxsYWJsZTxHWydwbGF5ZXInXT4+IGV4dGVuZHMgR2FtZUVsZW1lbnQ8RywgUD4ge1xuXG4gIF92aXNpYmxlPzoge1xuICAgIGRlZmF1bHQ6IGJvb2xlYW4sXG4gICAgZXhjZXB0PzogbnVtYmVyW11cbiAgfVxuXG4gIGNyZWF0ZUVsZW1lbnQ8VCBleHRlbmRzIEdhbWVFbGVtZW50PihjbGFzc05hbWU6IEVsZW1lbnRDbGFzczxUPiwgbmFtZTogc3RyaW5nLCBhdHRycz86IEVsZW1lbnRBdHRyaWJ1dGVzPFQ+KTogVCB7XG4gICAgaWYgKGNsYXNzTmFtZSA9PT0gU3BhY2UgYXMgdW5rbm93biBhcyBFbGVtZW50Q2xhc3M8VD4gfHwgT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwoU3BhY2UsIGNsYXNzTmFtZSkpIHtcbiAgICAgIHRocm93IEVycm9yKGBNYXkgbm90IGNyZWF0ZSBTcGFjZSBcIiR7bmFtZX1cIiBpbiBQaWVjZSBcIiR7dGhpcy5uYW1lfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5jcmVhdGVFbGVtZW50KGNsYXNzTmFtZSwgbmFtZSwgYXR0cnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3cgdGhpcyBwaWVjZSB0byBhbGwgcGxheWVyc1xuICAgKiBAY2F0ZWdvcnkgVmlzaWJpbGl0eVxuICAgKi9cbiAgc2hvd1RvQWxsKCkge1xuICAgIGRlbGV0ZSh0aGlzLl92aXNpYmxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93IHRoaXMgcGllY2Ugb25seSB0byB0aGUgZ2l2ZW4gcGxheWVyXG4gICAqIEBjYXRlZ29yeSBWaXNpYmlsaXR5XG4gICAqL1xuICBzaG93T25seVRvKHBsYXllcjogUGxheWVyIHwgbnVtYmVyKSB7XG4gICAgaWYgKHR5cGVvZiBwbGF5ZXIgIT09ICdudW1iZXInKSBwbGF5ZXIgPSBwbGF5ZXIucG9zaXRpb247XG4gICAgdGhpcy5fdmlzaWJsZSA9IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgZXhjZXB0OiBbcGxheWVyXVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU2hvdyB0aGlzIHBpZWNlIHRvIHRoZSBnaXZlbiBwbGF5ZXJzIHdpdGhvdXQgY2hhbmdpbmcgaXQncyB2aXNpYmlsaXR5IHRvXG4gICAqIGFueSBvdGhlciBwbGF5ZXJzLlxuICAgKiBAY2F0ZWdvcnkgVmlzaWJpbGl0eVxuICAgKi9cbiAgc2hvd1RvKC4uLnBsYXllcjogUGxheWVyW10gfCBudW1iZXJbXSkge1xuICAgIGlmICh0eXBlb2YgcGxheWVyWzBdICE9PSAnbnVtYmVyJykgcGxheWVyID0gKHBsYXllciBhcyBQbGF5ZXJbXSkubWFwKHAgPT4gcC5wb3NpdGlvbik7XG4gICAgaWYgKHRoaXMuX3Zpc2libGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLl92aXNpYmxlLmRlZmF1bHQpIHtcbiAgICAgIGlmICghdGhpcy5fdmlzaWJsZS5leGNlcHQpIHJldHVybjtcbiAgICAgIHRoaXMuX3Zpc2libGUuZXhjZXB0ID0gdGhpcy5fdmlzaWJsZS5leGNlcHQuZmlsdGVyKGkgPT4gIShwbGF5ZXIgYXMgbnVtYmVyW10pLmluY2x1ZGVzKGkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdmlzaWJsZS5leGNlcHQgPSBBcnJheS5mcm9tKG5ldyBTZXQoWy4uLih0aGlzLl92aXNpYmxlLmV4Y2VwdCBpbnN0YW5jZW9mIEFycmF5ID8gdGhpcy5fdmlzaWJsZS5leGNlcHQgOiBbXSksIC4uLihwbGF5ZXIgYXMgbnVtYmVyW10pXSkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhpcyBwaWVjZSBmcm9tIGFsbCBwbGF5ZXJzXG4gICAqIEBjYXRlZ29yeSBWaXNpYmlsaXR5XG4gICAqL1xuICBoaWRlRnJvbUFsbCgpIHtcbiAgICB0aGlzLl92aXNpYmxlID0ge2RlZmF1bHQ6IGZhbHNlfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlIHRoaXMgcGllY2UgZnJvbSB0aGUgZ2l2ZW4gcGxheWVycyB3aXRob3V0IGNoYW5naW5nIGl0J3MgdmlzaWJpbGl0eSB0b1xuICAgKiBhbnkgb3RoZXIgcGxheWVycy5cbiAgICogQGNhdGVnb3J5IFZpc2liaWxpdHlcbiAgICovXG4gIGhpZGVGcm9tKC4uLnBsYXllcjogUGxheWVyW10gfCBudW1iZXJbXSkge1xuICAgIGlmICh0eXBlb2YgcGxheWVyWzBdICE9PSAnbnVtYmVyJykgcGxheWVyID0gKHBsYXllciBhcyBQbGF5ZXJbXSkubWFwKHAgPT4gcC5wb3NpdGlvbik7XG4gICAgaWYgKHRoaXMuX3Zpc2libGU/LmRlZmF1bHQgPT09IGZhbHNlICYmICF0aGlzLl92aXNpYmxlLmV4Y2VwdCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLl92aXNpYmxlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fdmlzaWJsZS5kZWZhdWx0ID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl92aXNpYmxlID0ge1xuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICBleGNlcHQ6IEFycmF5LmZyb20obmV3IFNldChbLi4uKHRoaXMuX3Zpc2libGU/LmV4Y2VwdCBpbnN0YW5jZW9mIEFycmF5ID8gdGhpcy5fdmlzaWJsZS5leGNlcHQgOiBbXSksIC4uLihwbGF5ZXIgYXMgbnVtYmVyW10pXSkpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuX3Zpc2libGUuZXhjZXB0KSByZXR1cm47XG4gICAgICB0aGlzLl92aXNpYmxlLmV4Y2VwdCA9IHRoaXMuX3Zpc2libGUuZXhjZXB0LmZpbHRlcihpID0+ICEocGxheWVyIGFzIG51bWJlcltdKS5pbmNsdWRlcyhpKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIHBpZWNlIGlzIHZpc2libGUgdG8gdGhlIGdpdmVuIHBsYXllclxuICAgKiBAY2F0ZWdvcnkgVmlzaWJpbGl0eVxuICAgKi9cbiAgaXNWaXNpYmxlVG8ocGxheWVyOiBQbGF5ZXIgfCBudW1iZXIpIHtcbiAgICBpZiAodHlwZW9mIHBsYXllciAhPT0gJ251bWJlcicpIHBsYXllciA9IHBsYXllci5wb3NpdGlvbjtcbiAgICBpZiAodGhpcy5fdmlzaWJsZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy5fdmlzaWJsZS5kZWZhdWx0KSB7XG4gICAgICByZXR1cm4gIXRoaXMuX3Zpc2libGUuZXhjZXB0IHx8ICEodGhpcy5fdmlzaWJsZS5leGNlcHQuaW5jbHVkZXMocGxheWVyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlLmV4Y2VwdD8uaW5jbHVkZXMocGxheWVyKSB8fCBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgcGllY2UgaXMgdmlzaWJsZSB0byBhbGwgcGxheWVycywgb3IgdG8gdGhlIGN1cnJlbnRcbiAgICogcGxheWVyIGlmIGNhbGxlZCB3aGVuIGluIGEgcGxheWVyIGNvbnRleHQgKGR1cmluZyBhbiBhY3Rpb24gdGFrZW4gYnkgYVxuICAgKiBwbGF5ZXIgb3Igd2hpbGUgdGhlIGdhbWUgaXMgdmlld2VkIGJ5IGEgZ2l2ZW4gcGxheWVyLilcbiAgICogQGNhdGVnb3J5IFZpc2liaWxpdHlcbiAgICovXG4gIGlzVmlzaWJsZSgpIHtcbiAgICBpZiAodGhpcy5fY3R4LnBsYXllcikgcmV0dXJuIHRoaXMuaXNWaXNpYmxlVG8odGhpcy5fY3R4LnBsYXllci5wb3NpdGlvbik7XG4gICAgcmV0dXJuIHRoaXMuX3Zpc2libGU/LmRlZmF1bHQgIT09IGZhbHNlICYmICh0aGlzLl92aXNpYmxlPy5leGNlcHQgPz8gW10pLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm92aWRlIGxpc3Qgb2YgYXR0cmlidXRlcyB0aGF0IHJlbWFpbiB2aXNpYmxlIGV2ZW4gd2hlbiB0aGVzZSBwaWVjZXMgYXJlXG4gICAqIG5vdCB2aXNpYmxlIHRvIHBsYXllcnMuIEUuZy4gSW4gYSBnYW1lIHdpdGggbXVsdGlwbGUgY2FyZCBkZWNrcyB3aXRoXG4gICAqIGRpZmZlcmVudCBiYWNrcywgaWRlbnRpZmllZCBieSBDYXJkI2RlY2ssIHRoZSBpZGVudGl0eSBvZiB0aGUgY2FyZCB3aGVuXG4gICAqIGZhY2UtZG93biBpcyBoaWRkZW4sIGJ1dCB0aGUgZGVjayBpdCBiZWxvbmdzIHRvIGlzIG5vdCwgc2luY2UgdGhlIGNhcmQgYXJ0XG4gICAqIG9uIHRoZSBiYWNrIHdvdWxkIGlkZW50aWZ5IHRoZSBkZWNrLiBJbiB0aGlzIGNhc2UgY2FsbGluZ1xuICAgKiBgQ2FyZC5yZXZlYWxXaGVuSGlkZGVuKCdkZWNrJylgIHdpbGwgY2F1c2UgYWxsIGF0dHJpYnV0ZXMgb3RoZXIgdGhhbiAnZGVjaydcbiAgICogdG8gYmUgaGlkZGVuIHdoZW4gdGhlIGNhcmQgaXMgZmFjZSBkb3duLCB3aGlsZSBzdGlsbCByZXZlYWxpbmcgd2hpY2ggZGVja1xuICAgKiBpdCBpcy5cbiAgICogQGNhdGVnb3J5IFZpc2liaWxpdHlcbiAgICovXG4gIHN0YXRpYyByZXZlYWxXaGVuSGlkZGVuPFQgZXh0ZW5kcyBQaWVjZTxCYXNlR2FtZT4+KHRoaXM6IEVsZW1lbnRDbGFzczxUPiwgLi4uYXR0cnM6IChzdHJpbmcgJiBrZXlvZiBUKVtdKTogdm9pZCB7XG4gICAgdGhpcy52aXNpYmxlQXR0cmlidXRlcyA9IGF0dHJzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhpcyBwaWVjZSBpbnRvIGFub3RoZXIgZWxlbWVudC4gVGhpcyB0cmlnZ2VycyBhbnkge0BsaW5rXG4gICAqIFNwYWNlI29uRW50ZXIgfCBvbkVudGVyfSBjYWxsYmFja3MgaW4gdGhlIGRlc3RpbmF0aW9uLlxuICAgKiBAY2F0ZWdvcnkgU3RydWN0dXJlXG4gICAqXG4gICAqIEBwYXJhbSB0byAtIERlc3RpbmF0aW9uIGVsZW1lbnRcbiAgICogQHBhcmFtIG9wdGlvbnMucG9zaXRpb24gLSBQbGFjZSB0aGUgcGllY2UgaW50byBhIHNwZWNpZmljIG51bWJlcmVkIHBvc2l0aW9uXG4gICAqIHJlbGF0aXZlIHRvIHRoZSBvdGhlciBlbGVtZW50cyBpbiB0aGlzIHNwYWNlLiBQb3NpdGl2ZSBudW1iZXJzIGNvdW50IGZyb21cbiAgICogdGhlIGJlZ2lubmluZy4gTmVnYXRpdmUgbnVtYmVycyBjb3VudCBmcm9tIHRoZSBlbmQuXG4gICAqIEBwYXJhbSBvcHRpb25zLmZyb21Ub3AgLSBQbGFjZSB0aGUgcGllY2UgaW50byBhIHNwZWNpZmljIG51bWJlcmVkIHBvc2l0aW9uIGNvdW50aW5nXG4gICAqIGZyb20gdGhlIGZpcnN0IGVsZW1lbnRcbiAgICogQHBhcmFtIG9wdGlvbnMuZnJvbUJvdHRvbSAtIFBsYWNlIHRoZSBwaWVjZSBpbnRvIGEgc3BlY2lmaWMgbnVtYmVyZWQgcG9zaXRpb25cbiAgICogY291bnRpbmcgZnJvbSB0aGUgbGFzdCBlbGVtZW50XG4gICAqL1xuICBwdXRJbnRvKHRvOiBHYW1lRWxlbWVudCwgb3B0aW9ucz86IHtwb3NpdGlvbj86IG51bWJlciwgcm93PzogbnVtYmVyLCBjb2x1bW4/OiBudW1iZXIsIGZyb21Ub3A/OiBudW1iZXIsIGZyb21Cb3R0b20/OiBudW1iZXJ9KSB7XG4gICAgaWYgKHRvLmlzRGVzY2VuZGFudE9mKHRoaXMpKSB0aHJvdyBFcnJvcihgQ2Fubm90IHB1dCAke3RoaXN9IGludG8gaXRzZWxmYCk7XG4gICAgbGV0IHBvczogbnVtYmVyID0gdG8uX3Qub3JkZXIgPT09ICdzdGFja2luZycgPyAwIDogdG8uX3QuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGlmIChvcHRpb25zPy5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSBwb3MgPSBvcHRpb25zLnBvc2l0aW9uID49IDAgPyBvcHRpb25zLnBvc2l0aW9uIDogdG8uX3QuY2hpbGRyZW4ubGVuZ3RoICsgb3B0aW9ucy5wb3NpdGlvbiArIDE7XG4gICAgaWYgKG9wdGlvbnM/LmZyb21Ub3AgIT09IHVuZGVmaW5lZCkgcG9zID0gb3B0aW9ucy5mcm9tVG9wO1xuICAgIGlmIChvcHRpb25zPy5mcm9tQm90dG9tICE9PSB1bmRlZmluZWQpIHBvcyA9IHRvLl90LmNoaWxkcmVuLmxlbmd0aCAtIG9wdGlvbnMuZnJvbUJvdHRvbTtcbiAgICBjb25zdCBwcmV2aW91c1BhcmVudCA9IHRoaXMuX3QucGFyZW50O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbigpO1xuICAgIGlmICh0aGlzLmhhc01vdmVkKCkgfHwgdG8uaGFzTW92ZWQoKSkgdGhpcy5nYW1lLmFkZERlbGF5KCk7XG4gICAgY29uc3QgcmVmcyA9IHByZXZpb3VzUGFyZW50ID09PSB0byAmJiBvcHRpb25zPy5yb3cgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zPy5jb2x1bW4gPT09IHVuZGVmaW5lZCAmJiB0by5jaGlsZFJlZnNJZk9ic2N1cmVkKCk7XG4gICAgdGhpcy5fdC5wYXJlbnQhLl90LmNoaWxkcmVuLnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgdGhpcy5fdC5wYXJlbnQgPSB0bztcbiAgICB0by5fdC5jaGlsZHJlbi5zcGxpY2UocG9zLCAwLCB0aGlzKTtcbiAgICBpZiAocmVmcykgdG8uYXNzaWduQ2hpbGRSZWZzKHJlZnMpO1xuXG4gICAgaWYgKHByZXZpb3VzUGFyZW50ICE9PSB0byAmJiBwcmV2aW91c1BhcmVudCBpbnN0YW5jZW9mIFNwYWNlKSBwcmV2aW91c1BhcmVudC50cmlnZ2VyRXZlbnQoXCJleGl0XCIsIHRoaXMpO1xuICAgIGlmIChwcmV2aW91c1BhcmVudCAhPT0gdG8gJiYgdGhpcy5fY3R4LnRyYWNrTW92ZW1lbnQpIHRoaXMuX3QubW92ZWQgPSB0cnVlO1xuXG4gICAgZGVsZXRlIHRoaXMuY29sdW1uO1xuICAgIGRlbGV0ZSB0aGlzLnJvdztcbiAgICBpZiAob3B0aW9ucz8ucm93ICE9PSB1bmRlZmluZWQpIHRoaXMucm93ID0gb3B0aW9ucy5yb3c7XG4gICAgaWYgKG9wdGlvbnM/LmNvbHVtbiAhPT0gdW5kZWZpbmVkKSB0aGlzLmNvbHVtbiA9IG9wdGlvbnMuY29sdW1uO1xuXG4gICAgaWYgKHByZXZpb3VzUGFyZW50ICE9PSB0byAmJiB0byBpbnN0YW5jZW9mIFNwYWNlKSB0by50cmlnZ2VyRXZlbnQoXCJlbnRlclwiLCB0aGlzKTtcbiAgfVxuXG4gIGNsb25lSW50bzxUIGV4dGVuZHMgR2FtZUVsZW1lbnQ+KHRoaXM6IFQsIGludG86IEdhbWVFbGVtZW50KTogVCB7XG4gICAgbGV0IGF0dHJzID0gdGhpcy5hdHRyaWJ1dGVMaXN0KCk7XG4gICAgZGVsZXRlIGF0dHJzLmNvbHVtbjtcbiAgICBkZWxldGUgYXR0cnMucm93O1xuXG4gICAgY29uc3QgY2xvbmUgPSBpbnRvLmNyZWF0ZUVsZW1lbnQodGhpcy5jb25zdHJ1Y3RvciBhcyBFbGVtZW50Q2xhc3M8VD4sIHRoaXMubmFtZSwgYXR0cnMpO1xuICAgIGlmIChpbnRvLl90Lm9yZGVyID09PSAnc3RhY2tpbmcnKSB7XG4gICAgICBpbnRvLl90LmNoaWxkcmVuLnVuc2hpZnQoY2xvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRvLl90LmNoaWxkcmVuLnB1c2goY2xvbmUpO1xuICAgIH1cbiAgICBjbG9uZS5fdC5wYXJlbnQgPSBpbnRvO1xuICAgIGNsb25lLl90Lm9yZGVyID0gdGhpcy5fdC5vcmRlcjtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuX3QuY2hpbGRyZW4pIGlmIChjaGlsZCBpbnN0YW5jZW9mIFBpZWNlKSBjaGlsZC5jbG9uZUludG8oY2xvbmUpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhpcyBwaWVjZSBmcm9tIHRoZSBwbGF5aW5nIGFyZWEgYW5kIHBsYWNlIGl0IGludG8ge0BsaW5rXG4gICAqIEdhbWUjcGlsZX1cbiAgICogQGNhdGVnb3J5IFN0cnVjdHVyZVxuICAgKi9cbiAgcmVtb3ZlKCkge1xuICAgIHJldHVybiB0aGlzLnB1dEludG8odGhpcy5fY3R4LnJlbW92ZWQpO1xuICB9XG59XG4iLCAiaW1wb3J0IFBpZWNlIGZyb20gJy4uLy4uL2JvYXJkL3BpZWNlLmpzJztcblxuaW1wb3J0IHR5cGUgR2FtZSBmcm9tICcuLi8uLi9ib2FyZC9nYW1lLmpzJztcblxuLyoqXG4gKiBTcGVjaWFsaXplZCBwaWVjZSBmb3IgcmVwcmVzZW50aW5nIDYtc2lkZWQgZGljZVxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBENiB9IGZyb20gJ0Bib2FyZHppbGxhL2NvcmUvY29tcG9uZW50cyc7XG4gKiAuLi5cbiAqIGdhbWUuY3JlYXRlKEQ2LCAnbXktZGllJyk7XG4gKiBAY2F0ZWdvcnkgQm9hcmRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRDY8RyBleHRlbmRzIEdhbWUgPSBHYW1lPiBleHRlbmRzIFBpZWNlPEc+IHtcbiAgc2lkZXM6IG51bWJlciA9IDY7XG5cbiAgLyoqXG4gICAqIEN1cnJlbnRseSBzaG93biBmYWNlXG4gICAqIEBjYXRlZ29yeSBENlxuICAgKi9cbiAgY3VycmVudDogbnVtYmVyID0gMTtcbiAgcm9sbFNlcXVlbmNlOiBudW1iZXIgPSAwO1xuXG4gIC8qKlxuICAgKiBSYW5kb21seSBjaG9vc2UgYSBuZXcgZmFjZSwgY2F1c2luZyB0aGUgcm9sbCBhbmltYXRpb25cbiAgICogQGNhdGVnb3J5IEQ2XG4gICAqL1xuICByb2xsKCkge1xuICAgIHRoaXMuY3VycmVudCA9IE1hdGguY2VpbCgodGhpcy5nYW1lLnJhbmRvbSB8fCBNYXRoLnJhbmRvbSkoKSAqIHRoaXMuc2lkZXMpO1xuICAgIHRoaXMucm9sbFNlcXVlbmNlID0gdGhpcy5fY3R4LmdhbWVNYW5hZ2VyLnNlcXVlbmNlO1xuICB9XG59XG4iLCAiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IGRpY2UgZnJvbSAnLi9hc3NldHMvZGljZS5vZ2cnO1xuaW1wb3J0IHsgdGltZXMgfSBmcm9tICcuLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgRDYgZnJvbSAnLi9kNi5qcyc7XG5pbXBvcnQgJy4vYXNzZXRzL2luZGV4LnNjc3MnO1xuXG5pbXBvcnQgdHlwZSB7IEJhc2VHYW1lIH0gZnJvbSAnLi4vLi4vYm9hcmQvZ2FtZS5qcyc7XG5cbi8qKlxuICogQWRkcyBhbiBhbmltYXRlZCBzcGlubmluZyBhcHBlYXJhbmNlIHRvIHRoZSB7QGxpbmsgRDZ9IGNsYXNzXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IHVzZUQ2IH0gZnJvbSAnQGJvYXJkemlsbGEvY29yZS9jb21wb25lbnRzJztcbiAqXG4gKiAvLyB0aGVuIGluIHRoZSBsYXlvdXQoKSBtZXRob2RcbiAqICAgICB1c2VENihnYW1lKTtcbiAqL1xuY29uc3QgRDZDb21wb25lbnQgPSAoeyBkaWUgfTogeyBkaWU6IEQ2IH0pID0+IHtcbiAgY29uc3QgZGljZUF1ZGlvID0gdXNlUmVmPEhUTUxBdWRpb0VsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBsYXN0Um9sbFNlcXVlbmNlID0gdXNlUmVmPG51bWJlcj4oKTtcbiAgY29uc3QgW2ZsaXAsIHNldEZsaXBdID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpZS5yb2xsU2VxdWVuY2UgPT09IE1hdGguY2VpbChkaWUuX2N0eC5nYW1lTWFuYWdlci5zZXF1ZW5jZSAtIDEpICYmIGxhc3RSb2xsU2VxdWVuY2UuY3VycmVudCAhPT0gdW5kZWZpbmVkICYmIGxhc3RSb2xsU2VxdWVuY2UuY3VycmVudCAhPT0gZGllLnJvbGxTZXF1ZW5jZSkge1xuICAgICAgZGljZUF1ZGlvLmN1cnJlbnQ/LnBsYXkoKTtcbiAgICAgIHNldEZsaXAoIWZsaXApO1xuICAgIH1cbiAgICBsYXN0Um9sbFNlcXVlbmNlLmN1cnJlbnQgPSBkaWUucm9sbFNlcXVlbmNlO1xuICB9LCBbZGllLCBkaWUucm9sbFNlcXVlbmNlLCBmbGlwLCBzZXRGbGlwXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGF1ZGlvIHJlZj17ZGljZUF1ZGlvfSBzcmM9e2RpY2V9IGlkPVwiZGljZVwiLz5cbiAgICAgIDxvbCBkYXRhLXNwaW49e2ZsaXAgPyAndXAnIDogJ2Rvd24nfT5cbiAgICAgICAge1sxLDIsMyw0LDUsNl0ubWFwKGRvdHMgPT4gKFxuICAgICAgICAgIDxsaSBrZXk9e2RvdHN9IGNsYXNzTmFtZT1cImRpZS1mYWNlXCIgZGF0YS1mYWNlPXtkb3RzfT5cbiAgICAgICAgICAgIHt0aW1lcyhkb3RzLCBkID0+IDxzcGFuIGtleT17ZH0gY2xhc3NOYW1lPVwiZG90XCIvPil9XG4gICAgICAgICAgPC9saT5cbiAgICAgICAgKSl9XG4gICAgICA8L29sPlxuICAgIDwvPlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCAoZ2FtZTogQmFzZUdhbWUpID0+IHtcbiAgZ2FtZS5hbGwoRDYpLmFwcGVhcmFuY2Uoe1xuICAgIHJlbmRlcjogKGRpZTogRDYpID0+IDxENkNvbXBvbmVudCBkaWU9e2RpZX0vPixcbiAgICBhc3BlY3RSYXRpbzogMSxcbiAgfSk7XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBRUEsS0FBQyxXQUFVO0FBRVQsVUFDRSxLQUNBLFNBQVMsR0FDVCxXQUFXLENBQUMsR0FDWjtBQUlGLFdBQUssSUFBSSxHQUFHLElBQUksS0FBSyxLQUFLO0FBQ3hCLGlCQUFTLENBQUMsS0FBSyxJQUFJLEtBQU8sU0FBUyxFQUFFLEVBQUUsT0FBTyxDQUFDO0FBQUEsTUFDakQ7QUFLQSxNQUFBQSxNQUFLLGNBQWM7QUFHbkIsTUFBQUEsTUFBSyxNQUFNO0FBR1gsTUFBQUEsTUFB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TEEsSUFBcUIsS0FBckIsY0FBdUQsTUFBUztBQUFBLEVBQWhFO0FBQUE7QUFDRSxpQkFBZ0I7QUFNaEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFBa0I7QUFDbEIsd0JBQXVCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBTXZCLE9BQU87QUFDTCxTQUFLLFVBQVUsS0FBSyxNQUFNLEtBQUssS0FBSyxVQUFVLEtBQUssUUFBUSxJQUFJLEtBQUssS0FBSztBQUN6RSxTQUFLLGVBQWUsS0FBSyxLQUFLLFlBQVk7QUFBQSxFQUM1QztBQUNGOzs7QUMvQkEsbUJBQW1EO0FBRW5ELE9BQU8sVUFBVTtBQWdCakIsSUFBTSxjQUFjLENBQUMsRUFBRSxJQUFJLE1BQW1CO0FBQzVDLFFBQU0sZ0JBQVkscUJBQXlCLElBQUk7QUFDL0MsUUFBTSx1QkFBbUIscUJBQWU7QUFDeEMsUUFBTSxDQUFDLE1BQU0sT0FBTyxRQUFJLHVCQUFrQixLQUFLO0FBRS9DLDhCQUFVLE1BQU07QUFDZCxRQUFJLElBQUksaUJBQWlCLEtBQUssS0FBSyxJQUFJLEtBQUssWUFBWSxXQUFXLENBQUMsS0FBSyxpQkFBaUIsWUFBWSxVQUFhLGlCQUFpQixZQUFZLElBQUksY0FBYztBQUNoSyxnQkFBVSxTQUFTLEtBQUs7QUFDeEIsY0FBUSxDQUFDLElBQUk7QUFBQSxJQUNmO0FBQ0EscUJBQWlCLFVBQVUsSUFBSTtBQUFBLEVBQ2pDLEdBQUcsQ0FBQyxLQUFLLElBQUksY0FBYyxNQUFNLE9BQU8sQ0FBQztBQUV6QyxTQUNFLDZCQUFBQyxRQUFBLDJCQUFBQSxRQUFBLGdCQUNFLDZCQUFBQSxRQUFBLGNBQUMsV0FBTSxLQUFLLFdBQVcsS0FBSyxNQUFNLElBQUcsUUFBTSxHQUMzQyw2QkFBQUEsUUFBQSxjQUFDLFFBQUcsYUFBVyxPQUFPLE9BQU8sVUFDMUIsQ0FBQyxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsQ0FBQyxFQUFFLElBQUksVUFDakIsNkJBQUFBLFFBQUEsY0FBQyxRQUFHLEtBQUssTUFBTSxXQUFVLFlBQVcsYUFBVyxRQUM1QyxNQUFNLE1BQU0sT0FBSyw2QkFBQUEsUUFBQSxjQUFDLFVBQUssS0FBSyxHQUFHLFdBQVUsT0FBSyxDQUFFLENBQ25ELENBQ0QsQ0FDSCxDQUNGO0FBRUo7QUFFQSxJQUFPLGdCQUFRLENBQUMsU0FBbUI7QUFDakMsT0FBSyxJQUFJLEVBQUUsRUFBRSxXQUFXO0FBQUEsSUFDdEIsUUFBUSxDQUFDLFFBQVksNkJBQUFBLFFBQUEsY0FBQyxlQUFZLEtBQVM7QUFBQSxJQUMzQyxhQUFhO0FBQUEsRUFDZixDQUFDO0FBQ0g7IiwKICAibmFtZXMiOiBbInV1aWQiLCAiaSIsICJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwgIm1vZHVsZU9iamVjdCIsICJlcnJvciIsICJ1c2VTdGF0ZSIsICJ1c2VSZWYiLCAidXNlRWZmZWN0IiwgIkNvbXBvbmVudCIsICJyZXR1cm5WYWx1ZSIsICJ1dWlkIiwgIlJlYWN0Il0KfQo=
