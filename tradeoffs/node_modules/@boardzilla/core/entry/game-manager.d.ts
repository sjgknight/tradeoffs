import { Action } from './action/index.js';
import { Player, PlayerCollection } from './player/index.js';
import Flow, { FlowBranchJSON } from './flow/flow.js';
import type { BaseGame } from './board/game.js';
import type { BasePlayer } from './player/player.js';
import type { ElementClass } from './board/element.js';
import type { PlayerState, GameUpdate, GameState } from './interface.js';
import type { SerializedArg } from './action/utils.js';
import type { Argument, ActionStub } from './action/action.js';
import type { ResolvedSelection } from './action/selection.js';
import type { SubflowSignal } from './flow/enums.js';
export type PlayerAttributes<T extends Player = Player> = {
    [K in keyof InstanceType<{
        new (...args: any[]): T;
    }> as InstanceType<{
        new (...args: any[]): T;
    }>[K] extends (...args: unknown[]) => unknown ? never : (K extends '_players' | 'game' | 'gameManager' ? never : K)]: InstanceType<{
        new (...args: any[]): T;
    }>[K];
};
export type Move = {
    player: Player;
    name: string;
    args: Record<string, Argument>;
};
export type PendingMove = {
    name: string;
    prompt?: string;
    args: Record<string, Argument>;
    selections: ResolvedSelection[];
};
export type SerializedMove = {
    name: string;
    args: Record<string, SerializedArg>;
};
export type Message = {
    position?: number;
    body: string;
};
export type ActionDebug = Record<string, {
    args: Record<string, 'sel' | 'skip' | 'only-one' | 'always' | 'tree' | 'forced' | 'imp' | 'ask' | 'future'>;
    impossible?: boolean;
}>;
export type FlowStackJSON = {
    name?: string;
    args?: Record<string, any>;
    currentPosition: number[];
    stack: FlowBranchJSON[];
};
/**
 * Game manager is used to coordinate other classes, the {@link Game}, the
 * {@link Player}'s, the {@link Action}'s and the {@link Flow}.
 * @category Core
 */
export default class GameManager<G extends BaseGame = BaseGame, P extends BasePlayer = BasePlayer> {
    flows: Record<string, Flow>;
    flowState: FlowStackJSON[];
    /**
     * The players in this game. See {@link Player}
     */
    players: PlayerCollection<P>;
    /**
     * The game. See {@link Game}
     */
    game: G;
    settings: Record<string, any>;
    actions: Record<string, (player: P) => Action<Record<string, Argument>>>;
    sequence: number;
    /**
     * Current game phase
     */
    phase: 'new' | 'started' | 'finished';
    rseed: string;
    random: () => number;
    messages: Message[];
    announcements: string[];
    intermediateUpdates: GameState[][];
    /**
     * If true, allows any piece to be moved or modified in any way. Used only
     * during development.
     */
    godMode: boolean;
    winner: P[];
    constructor(playerClass: {
        new (...a: any[]): P;
    }, gameClass: ElementClass<G>, elementClasses?: ElementClass[]);
    /**
     * configuration functions
     */
    setSettings(settings: Record<string, any>): void;
    setRandomSeed(rseed: string): void;
    /**
     * flow functions
     * @internal
     */
    start(): void;
    play(): void;
    flow(): Flow;
    getFlowStep(name: string): Flow | undefined;
    beginSubflow(flow: SubflowSignal['data']): void;
    setFlowFromJSON(json: FlowStackJSON[]): void;
    startFlow(json?: FlowStackJSON): void;
    flowJSON(player?: boolean): FlowStackJSON[];
    /**
     * state functions
     * @internal
     */
    getState(player?: P): GameState;
    getPlayerStates(): PlayerState[];
    getUpdate(): GameUpdate;
    contextualizeBoardToPlayer(player?: Player): Player<BaseGame, BasePlayer> | undefined;
    inContextOfPlayer<T>(player: Player, fn: () => T): T;
    trackMovement(track?: boolean): void;
    /**
     * action functions
     */
    getAction(name: string, player: P): Action<{}> & {
        name: string;
    };
    godModeActions(): Record<string, Action>;
    processMove({ player, name, args }: Move): string | undefined;
    allowedActions(player: P, debug?: ActionDebug): {
        step?: string;
        prompt?: string;
        description?: string;
        skipIf: 'always' | 'never' | 'only-one';
        continueIfImpossible?: boolean;
        actions: ActionStub[];
    };
    getPendingMoves(player: P, name?: string, args?: Record<string, Argument>, debug?: ActionDebug): {
        step?: string;
        prompt?: string;
        moves: PendingMove[];
    } | undefined;
}
//# sourceMappingURL=game-manager.d.ts.map