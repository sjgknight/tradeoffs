import GameElement from '../board/element.js';
import type { SingleArgument, Argument } from './action.js';
export type BoardQuerySingle<T extends GameElement, A extends Record<string, Argument> = Record<string, Argument>> = string | T | undefined | ((args: A) => T | undefined);
export type BoardQueryMulti<T extends GameElement, A extends Record<string, Argument> = Record<string, Argument>> = string | T[] | ((args: A) => T[]);
export type BoardQuery<T extends GameElement, A extends Record<string, Argument> = Record<string, Argument>> = BoardQuerySingle<T, A> | BoardQueryMulti<T, A>;
export type BoardSelection<T extends GameElement, A extends Record<string, Argument> = Record<string, Argument>> = {
    chooseFrom: BoardQueryMulti<T, A>;
    min?: number | ((args: A) => number);
    max?: number | ((args: A) => number);
    number?: number | ((args: A) => number);
    initial?: T[] | ((args: A) => T[]);
};
export type ChoiceSelection<A extends Record<string, Argument> = Record<string, Argument>> = {
    choices: SingleArgument[] | {
        label: string;
        choice: SingleArgument;
    }[] | ((args: A) => SingleArgument[] | {
        label: string;
        choice: SingleArgument;
    }[]);
    initial?: Argument | ((args: A) => Argument);
};
export type NumberSelection<A extends Record<string, Argument> = Record<string, Argument>> = {
    min?: number | ((args: A) => number);
    max?: number | ((args: A) => number);
    initial?: number | ((args: A) => number);
};
export type TextSelection<A extends Record<string, Argument> = Record<string, Argument>> = {
    regexp?: RegExp;
    initial?: string | ((args: A) => string);
};
export type ButtonSelection = Argument;
export type SelectionDefinition<A extends Record<string, Argument> = Record<string, Argument>> = {
    prompt?: string | ((args: A) => string);
    confirm?: string | [string, Record<string, Argument> | ((args: A) => Record<string, Argument>) | undefined];
    validation?: ((args: A) => string | boolean | undefined);
    clientContext?: Record<any, any>;
} & ({
    skipIf?: 'never' | 'always' | 'only-one' | ((args: A) => boolean);
    selectOnBoard: BoardSelection<GameElement>;
    selectPlaceOnBoard?: never;
    selectFromChoices?: never;
    selectNumber?: never;
    enterText?: never;
    value?: never;
} | {
    skipIf?: 'never' | 'always' | 'only-one' | ((args: A) => boolean);
    selectOnBoard?: never;
    selectPlaceOnBoard?: never;
    selectFromChoices: ChoiceSelection;
    selectNumber?: never;
    enterText?: never;
    value?: never;
} | {
    skipIf?: 'never' | 'always' | 'only-one' | ((args: A) => boolean);
    selectOnBoard?: never;
    selectPlaceOnBoard?: never;
    selectFromChoices?: never;
    selectNumber: NumberSelection;
    enterText?: never;
    value?: never;
} | {
    selectOnBoard?: never;
    selectPlaceOnBoard?: never;
    selectFromChoices?: never;
    selectNumber?: never;
    enterText: TextSelection;
    value?: never;
} | {
    selectOnBoard?: never;
    selectPlaceOnBoard?: never;
    selectFromChoices?: never;
    selectNumber?: never;
    enterText?: never;
    value: ButtonSelection;
} | {
    selectOnBoard?: never;
    selectPlaceOnBoard: {
        piece: string;
        rotationChoices?: number[];
    };
    selectFromChoices?: never;
    selectNumber?: never;
    enterText?: never;
    value?: never;
});
export type ResolvedSelection = Omit<Selection, 'prompt' | 'choices' | 'boardChoices' | 'min' | 'max' | 'initial' | 'skipIf'> & {
    prompt?: string;
    choices?: SingleArgument[] | {
        label: string;
        choice: SingleArgument;
    }[];
    boardChoices?: GameElement[];
    min?: number;
    max?: number;
    initial?: Argument;
    skipIf?: 'never' | 'always' | 'only-one' | boolean;
};
/**
 * Selection objects represent player choices. They either specify the options
 * or provide enough information for the client to contextually show options to
 * players at runtime
 * @internal
 */
export default class Selection {
    type: 'board' | 'choices' | 'text' | 'number' | 'button' | 'place';
    name: string;
    prompt?: string | ((args: Record<string, Argument>) => string);
    confirm?: [string, Record<string, Argument> | ((args: Record<string, Argument>) => Record<string, Argument>) | undefined];
    validation?: ((args: Record<string, Argument>) => string | boolean | undefined);
    clientContext: Record<any, any>;
    skipIf?: 'never' | 'always' | 'only-one' | ((args: Record<string, Argument>) => boolean);
    choices?: SingleArgument[] | {
        label: string;
        choice: SingleArgument;
    }[] | ((args: Record<string, Argument>) => SingleArgument[] | {
        label: string;
        choice: SingleArgument;
    }[]);
    boardChoices?: BoardQueryMulti<GameElement>;
    min?: number | ((args: Record<string, Argument>) => number);
    max?: number | ((args: Record<string, Argument>) => number);
    initial?: Argument | ((args: Record<string, Argument>) => Argument);
    regexp?: RegExp;
    placePiece?: string;
    rotationChoices?: number[];
    value?: Argument;
    invalidOptions: {
        option: Argument;
        error: string;
        label?: string;
    }[];
    constructor(name: string, s: SelectionDefinition | Selection);
    isLabeledChoice(this: ResolvedSelection): boolean | undefined;
    choiceLabels(this: ResolvedSelection): string[];
    choiceValues(this: ResolvedSelection): SingleArgument[];
    labelFor(this: ResolvedSelection, choice: Argument): string;
    /**
     * check specific selection with a given arg. evaluates within the context of
     * previous args, so any selection elements that have previous-arg-function
     * forms are here evaluated with the previous args. returns new selection and
     * error if any
     */
    error(args: Record<string, Argument>): string | undefined;
    options(this: ResolvedSelection): Argument[];
    isUnbounded(this: ResolvedSelection): boolean;
    isResolved(): this is ResolvedSelection;
    isMulti(): boolean;
    isBoardChoice(): boolean;
    resolve(args: Record<string, Argument>): ResolvedSelection;
    isPossible(this: ResolvedSelection): boolean;
    isForced(this: ResolvedSelection): Argument | undefined;
    overrideOptions(this: ResolvedSelection, options: SingleArgument[]): void;
    toString(): string;
}
//# sourceMappingURL=selection.d.ts.map