export const serialize = (arg, forPlayer = true, name) => {
    if (arg === undefined)
        return undefined;
    if (arg === null)
        return null;
    if (arg instanceof Array)
        return arg.map(a => serialize(a, forPlayer));
    if (typeof arg === 'object' && 'constructor' in arg && ('isPlayer' in arg.constructor || 'isGameElement' in arg.constructor)) {
        return serializeSingleArg(arg, forPlayer);
    }
    if (typeof arg === 'object')
        return serializeObject(arg, forPlayer);
    if (typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'boolean')
        return serializeSingleArg(arg, forPlayer);
    throw Error(`Unable to serialize the property ${name ? '"' + name + '": ' : ''} ${arg}. Only primitives, Player's, GameElement's or arrays/objects containing such can be used.`);
};
export const serializeArg = (arg, forPlayer = true) => {
    if (arg instanceof Array)
        return arg.map(a => serializeSingleArg(a, forPlayer));
    return serializeSingleArg(arg, forPlayer);
};
export const serializeSingleArg = (arg, forPlayer = true) => {
    if (typeof arg === 'object' && 'constructor' in arg) {
        if ('isPlayer' in arg.constructor)
            return `$p[${arg.position}]`;
        if ('isGameElement' in arg.constructor)
            return forPlayer ? `$el[${arg.branch()}]` : `$eid[${arg._t.id}]`;
    }
    return arg;
};
export const serializeObject = (obj, forPlayer = true) => {
    return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, serialize(v, forPlayer, k)]));
};
export const escapeArgument = (arg) => {
    if (arg instanceof Array) {
        const escapees = arg.map(escapeArgument);
        return escapees.slice(0, -1).join(', ') + (escapees.length > 1 ? ' and ' : '') + (escapees[escapees.length - 1] || '');
    }
    if (typeof arg === 'object')
        return `[[${serializeSingleArg(arg)}|${arg.toString()}]]`;
    return String(arg);
};
export const deserializeArg = (arg, game) => {
    if (arg instanceof Array)
        return arg.map(a => deserializeSingleArg(a, game));
    return deserializeSingleArg(arg, game);
};
export const deserializeSingleArg = (arg, game) => {
    if (typeof arg === 'number' || typeof arg === 'boolean')
        return arg;
    let deser;
    if (arg.slice(0, 3) === '$p[') {
        deser = game.players.atPosition(parseInt(arg.slice(3, -1)));
    }
    else if (arg.slice(0, 4) === '$el[') {
        deser = game.atBranch(arg.slice(4, -1));
    }
    else if (arg.slice(0, 5) === '$eid[') {
        deser = game.atID(parseInt(arg.slice(5, -1)));
    }
    else {
        return arg;
    }
    if (!deser)
        throw Error(`Unable to find arg: ${arg}`);
    return deser;
};
export const deserializeObject = (obj, game) => {
    return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, deserialize(v, game)]));
};
export const deserialize = (arg, game) => {
    if (arg === undefined)
        return undefined;
    if (arg === null)
        return null;
    if (arg instanceof Array)
        return arg.map(a => deserialize(a, game));
    if (typeof arg === 'object')
        return deserializeObject(arg, game);
    if (typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'boolean')
        return deserializeSingleArg(arg, game);
    throw Error(`unable to deserialize ${arg}`);
};
export const combinations = (set, min, max) => {
    const combos = [];
    const poss = (curr, i) => {
        if (set.length - i < min - curr.length)
            return;
        if (curr.length >= min)
            combos.push(curr);
        if (curr.length < max) {
            for (let j = i; j !== set.length; j++) {
                poss(curr.concat([set[j]]), j + 1);
            }
        }
    };
    poss([], 0);
    return combos;
};
//# sourceMappingURL=utils.js.map