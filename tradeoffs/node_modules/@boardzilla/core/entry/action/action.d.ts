import Selection from './selection.js';
import GameElement from '../board/element.js';
import Piece from '../board/piece.js';
import type { ResolvedSelection, BoardQueryMulti } from './selection.js';
import type { Game, PieceGrid } from '../board/index.js';
import type { Player } from '../player/index.js';
import type { default as GameManager, ActionDebug, PendingMove } from '../game-manager.js';
/**
 * A single argument
 * @category Actions
 */
export type SingleArgument = string | number | boolean | GameElement | Player;
/**
 * An argument that can be added to an {@link Action}. Each value is chosen by
 * player or in some cases passed from a previous action. Arguments can be:
 * - a number
 * - a string
 * - a boolean
 * - a {@link GameElement}
 * - a {@link Player}
 * - an array of one these in the case of a multi-choice selection
 * @category Actions
 */
export type Argument = SingleArgument | SingleArgument[];
/**
 * A follow-up action
 * @category Actions
 */
export type ActionStub = {
    /**
     * The name of the action, as defined in `{@link Game#defineactions}`.
     */
    name: string;
    /**
     * The player to take this action, if different than the current player
     */
    player?: Player;
    /**
     * Action prompt. If specified, overrides the `action.prompt` in `{@link
     * Game#defineactions}`.
     */
    prompt?: string;
    /**
     * Description of taking the action from a 3rd person perspective,
     * e.g. "choosing a card". The string will be automatically prefixed with the
     * player name and appropriate verb ("is/are"). If specified, this will be
     * used to convey to non-acting players what actions are happening.
     */
    description?: string;
    /**
     * An object containing arguments to be passed to the follow-up action. This
     * is useful if there are multiple ways to trigger this follow-up that have
     * variations.
     */
    args?: Record<string, Argument>;
};
type Group = Record<string, [
    'number',
    Parameters<Action['chooseNumber']>[1]?
] | [
    'select',
    Parameters<Action['chooseFrom']>[1],
    Parameters<Action['chooseFrom']>[2]?
] | [
    'text',
    Parameters<Action['enterText']>[1]?
]>;
type ExpandGroup<A extends Record<string, Argument>, R extends Group> = A & {
    [K in keyof R]: R[K][0] extends 'number' ? number : R[K][0] extends 'text' ? string : R[K][0] extends 'select' ? (R[K][1] extends Parameters<typeof Action.prototype.chooseFrom<any, infer E extends SingleArgument>>[1] ? E : never) : never;
};
/**
 * Actions represent discreet moves players can make. These contain the choices
 * needed to take this action and the results of the action. Create Actions
 * using the {@link Game#action} function. Actions are evaluated at the time the
 * player has the option to perform the action, so any expressions that involve
 * game state will reflect the state at the time the player is performing the
 * action.
 *
 * @privateRemarks
 * The Action object is responsible for:
 * - providing Selection objects to players to aid in supplying appropriate Arguments
 * - validating player Arguments and returning any Selections needed to complete
 * - accepting player Arguments and altering board state
 *
 * @category Actions
 */
export default class Action<A extends Record<string, Argument> = NonNullable<unknown>> {
    name?: string;
    prompt?: string;
    description?: string;
    selections: Selection[];
    moves: ((args: Record<string, Argument>) => any)[];
    condition?: ((args: A) => boolean) | boolean;
    messages: {
        text: string;
        args?: Record<string, Argument> | ((a: A) => Record<string, Argument>);
        position?: number;
    }[];
    order: ('move' | 'message')[];
    mutated: boolean;
    gameManager: GameManager;
    constructor({ prompt, description, condition }: {
        prompt?: string;
        description?: string;
        condition?: ((args: A) => boolean) | boolean;
    });
    isPossible(args: A): boolean;
    _getPendingMoves(args: Record<string, Argument>, debug?: ActionDebug): PendingMove[] | undefined;
    _getPendingMovesInner(args: Record<string, Argument>, debug?: ActionDebug): PendingMove[] | undefined;
    /**
     * given a partial arg list, returns a selection object for continuation if one exists.
     * @internal
     */
    _nextSelection(args: Record<string, Argument>): ResolvedSelection | undefined;
    /**
     * process this action with supplied args. returns error if any
     * @internal
     */
    _process(player: Player, args: Record<string, Argument>): string | undefined;
    _addSelection(selection: Selection): Selection;
    _withDecoratedArgs(args: A, fn: (args: A) => any): any;
    _getError(selection: ResolvedSelection, args: A): any;
    _getConfirmation(selection: ResolvedSelection, args: A): string | undefined;
    /**
     * Add behaviour to this action to alter game state. After adding the choices
     * to an action, calling `do` causes Boardzilla to use the player choices to
     * actually do something with those choices. Call this method after all the
     * methods for player choices so that the choices are properly available to
     * the `do` function.
     *
     * @param move - The action to perform. This function accepts one argument
     * with key-value pairs for each choice added to the action using the provided
     * names.
     *
     * @example
     * player => action({
     *   prompt: 'Take resources',
     * }).chooseFrom({
     *   'resource', ['lumber', 'steel'],
     *   { prompt: 'Select resource' }
     * }).chooseNumber(
     *   'amount', {
     *     prompt: 'Select amount',
     *     max: 3
     * }).do(({ resource, amount }) => {
     *   // the choices are automatically passed in with their proper type
     *   game.firstN(amount, Resource, {resource}).putInto(
     *     player.my('stockPile')
     *   );
     * })
     * @category Behaviour
     */
    do(move: (args: A) => any): Action<A>;
    /**
     * Add a message to this action that will be broadcast in the chat. Call this
     * method after all the methods for player choices so that the choices are
     * properly available to the `message` function. However the message should be
     * called before or after any `do` behaviour depending on whether you want the
     * message to reflect the game state before or after the move is performs. The
     * action's `message` and `do` functions can be intermixed in this way to
     * generate messages at different points int the execution of a move.
     *
     * @param text - The text of the message to send. This can contain interpolated
     * strings with double braces just as when calling {@link Game#message}
     * directly. However when using this method, the player performing the action,
     * plus any choices made in the action are automatically made available.
     *
     * @param args - If additional strings are needed in the message besides
     * 'player' and the player choices, these can be specified here. This can also
     * be specified as a function that accepts the player choices and returns
     * key-value pairs of strings for interpolation.
     *
     * @example
     * action({
     *   prompt: 'Say something',
     * }).enterText({
     *   'message',
     * }).message(
     *   '{{player}} said {{message}}' // no args needed
     * ).message(
     *   "I said, {{player}} said {{loudMessage}}",
     *   ({ message }) => ({ loudMessage: message.toUpperCase() })
     * )
     * @category Behaviour
     */
    message(text: string, args?: Record<string, Argument> | ((a: A) => Record<string, Argument>)): this;
    /**
     * Add a message to this action that will be broadcast in the chat to the
     * specified player(s). Call this method after all the methods for player
     * choices so that the choices are properly available to the `message`
     * function. However the message should be called before or after any `do`
     * behaviour depending on whether you want the message to reflect the game
     * state before or after the move is performs. The action's `message` and `do`
     * functions can be intermixed in this way to generate messages at different
     * points int the execution of a move.
     *
     * @param player - Player or players to receive the message
     *
     * @param text - The text of the message to send. This can contain interpolated
     * strings with double braces just as when calling {@link Game#message}
     * directly. However when using this method, the player performing the action,
     * plus any choices made in the action are automatically made available.
     *
     * @param args - If additional strings are needed in the message besides
     * 'player' and the player choices, these can be specified here. This can also
     * be specified as a function that accepts the player choices and returns
     * key-value pairs of strings for interpolation.
     *
     * @example
     * action({
     *   prompt: 'Say something',
     * }).enterText({
     *   'message',
     * }).message(
     *   '{{player}} said {{message}}' // no args needed
     * ).message(
     *   "I said, {{player}} said {{loudMessage}}",
     *   ({ message }) => ({ loudMessage: message.toUpperCase() })
     * )
     * @category Behaviour
     */
    messageTo(player: (Player | number) | (Player | number)[], text: string, args?: Record<string, Argument> | ((a: A) => Record<string, Argument>)): this;
    /**
     * Add a choice to this action from a list of options. These choices will be
     * displayed as buttons in the UI.
     *
     * @param name - The name of this choice. This name will be used in all
     * functions that accept the player's choices
     *
     * @param choices - An array of choices. This may be an array of simple values
     * or an array of objects in the form: `{ label: string, choice: value }`
     * where value is the actual choice that will be passed to the rest of the
     * action, but label is the text presented to the player that they will be
     * prompted to click. Use the object style when you want player text to
     * contain additional logic or differ in some way from the choice, similiar to
     * `<option value="key">Some text</option>` in HTML. This can also be a
     * function that returns the choice array. This function will accept arguments
     * for each choice the player has made up to this point in the action.
     *
     * @param {Object} options
     * @param options.prompt - Prompt displayed to the user for this choice.
     * @param options.skipIf - One of 'always', 'never' or 'only-one' or a
     * function returning a boolean. (Default 'only-one').
     *
     * <ul>
     * <li>only-one: If there is only valid choice in the choices given, the game
     * will skip this choice, prompting the player for subsequent choices, if any,
     * or completing the action otherwise.
     * <li>always: Rather than present this choice directly, the player will be
     * prompted with choices from the *next choice* in the action for each
     * possible choice here, essentially expanding the choices ahead of time to
     * save the player a step. This option only has relevance if there are
     * subsequent choices in the action.
     * <li>never: Always present this choice, even if the choice is forced
     * <li>function: A function that accepts all player choices up to this point
     * and returns a boolean. If returning true, this choice will be skipped.
     * This form is useful in the rare situations where the choice at the time may
     * be meaningless, e.g. selecting from a set of identical tokens. In this case
     * the game will make the choice for the player using the first viable option.
     * </ul>
     *
     * @param options.validate - A function that takes an object of key-value
     * pairs for all player choices and returns a boolean. If false, the game will
     * not allow the player to submit this choice. If a string is returned, this
     * will display as the reason for disallowing these selections.
     *
     * @param options.confirm - A confirmation message that the player will always
     * see before commiting this choice. This can be useful to present additional
     * information about the consequences of this choice, or simply to force the
     * player to hit a button with a clear message. This can be a simple string,
     * or a 2-celled array in the same form as {@link message} with a string
     * message and a set of key-value pairs for string interpolation, optionally
     * being a function that takes an object of key-value pairs for all player
     * choices, and returns the interpolation object.
     *
     * @example
     * action({
     *   prompt: 'Choose color',
     * }).chooseFrom(
     *   'color', ['white', 'blue', 'red'],
     * ).do(
     *   ({ color }) => ... color will be equal to the player-selected color ...
     * )
     *
     * // a more complex example:
     * action({
     *   prompt: 'Take resources',
     * }).chooseFrom(
     *   'resource', ['lumber', 'steel', 'oil'],
     *   { prompt: 'Select resource' }
     * ).chooseFrom(
     *   // Use the functional style to include the resource choice in the text
     *   // Also use object style to have the value simply be "high" or "low"
     *   'grade', ({ resource }) => [
     *     { choice: 'high', label: `High grade ${resource}` }
     *     { choice: 'low', label: `Low grade ${resource}` }
     *   ],
     *   {
     *     // A follow-up choice that doesn't apply to "oil"
     *     skipIf: ({ resource }) => resource === 'oil',
     *     // Add an 'are you sure?' message
     *     confirm: ['Buy {{grade}} grade {{resource}}?', ({ grade }) = ({ grade: grade.toUpperCase() })]
     *   }
     * ).do (
     *   ({ resource, grade }) => {
     *     // resource will equal 'lumber', 'steel' or 'oil'
     *     // grade will equal 'high' or 'low'
     *   }
     * )
     * @category Choices
     */
    chooseFrom<N extends string, T extends SingleArgument>(name: N, choices: (T & (string | number | boolean))[] | {
        label: string;
        choice: T;
    }[] | ((args: A) => (T & (string | number | boolean))[] | {
        label: string;
        choice: T;
    }[]), options?: {
        prompt?: string | ((args: A) => string);
        confirm?: string | [string, Record<string, Argument> | ((args: A & {
            [key in N]: T;
        }) => Record<string, Argument>) | undefined];
        validate?: ((args: A & {
            [key in N]: T;
        }) => string | boolean | undefined);
        skipIf?: 'never' | 'always' | 'only-one' | ((args: A) => boolean);
    }): Action<A & {
        [key in N]: T;
    }>;
    /**
     * Prompt the user for text entry. Use this in games where players submit
     * text, like word-guessing games.
     *
     * @param name - The name of this text input. This name will be used in all
     * functions that accept the player's choices
     *
     * @param {Object} options
     * @param options.initial - Default text that can appear initially before a
     * user types.
     * @param options.prompt - Prompt displayed to the user for entering this
     * text.
     *
     * @param options.validate - A function that takes an object of key-value
     * pairs for all player choices and returns a boolean. If false, the game will
     * not allow the player to submit this text. If a string is returned, this
     * will display as the reason for disallowing this text.
     *
     * @example
     * action({
     *   prompt: 'Guess a word',
     * }).enterText({
     *   'guess',
     *   { prompt: 'Your guess', }
     * }).message(
     *   guess => `{{player}} guessed ${guess}`
     * })
     * @category Choices
     */
    enterText<N extends string>(name: N, options?: {
        prompt?: string | ((args: A) => string);
        validate?: ((args: A & {
            [key in N]: string;
        }) => string | boolean | undefined);
        regexp?: RegExp;
        initial?: string | ((args: A) => string);
    }): Action<A & {
        [key in N]: string;
    }>;
    /**
     * Add a numerical choice for this action. This will be presented with a
     * number picker.
     *
     * @param name - The name of this choice. This name will be used in all
     * functions that accept the player's choices
     *
     * @param {Object} options
     *
     * @param options.prompt - Prompt displayed to the user for entering this
     * number.
     *
     * @param options.min - Minimum allowed. Default 1.
     *
     * @param options.max - Maximum allowed. Default Infinity
     *
     * @param options.initial - Initial value to display in the picker
     *
     * @param options.skipIf - One of 'always', 'never' or 'only-one' or a
     * function returning a boolean. (Default 'only-one').
     *
     * <ul>
     * <li>only-one: If there is only valid choice in the choices given, the game
     * will skip this choice, prompting the player for subsequent choices, if any,
     * or completing the action otherwise.
     * <li>always: Rather than present this choice directly, the player will be
     * prompted with choices from the *next choice* in the action for each
     * possible choice here, essentially expanding the choices ahead of time to
     * save the player a step. This option only has relevance if there are
     * subsequent choices in the action.
     * <li>never: Always present this choice, even if the choice is forced
     * <li>function: A function that accepts all player choices up to this point
     * and returns a boolean. If returning true, this choice will be skipped.
     * This form is useful in the rare situations where the choice at the time may
     * be meaningless, e.g. selecting from a set of identical tokens. In this case
     * the game will make the choice for the player using the first viable option.
     * </ul>
     *
     * @param options.validate - A function that takes an object of key-value
     * pairs for all player choices and returns a boolean. If false, the game will
     * not allow the player to submit this choice. If a string is returned, this
     * will display as the reason for disallowing these selections.
     *
     * @param options.confirm - A confirmation message that the player will always
     * see before commiting this choice. This can be useful to present additional
     * information about the consequences of this choice, or simply to force the
     * player to hit a button with a clear message. This can be a simple string,
     * or a 2-celled array in the same form as {@link message} with a string
     * message and a set of key-value pairs for string interpolation, optionally
     * being a function that takes an object of key-value pairs for all player
     * choices, and returns the interpolation object.
     *
     * @example
     * player => action({
     *   prompt: 'Buy resources',
     * }).chooseNumber(
     *   'amount', {
     *     min: 5,
     *     max: 10 // select from 5 - 10
     * }).do(
     *   ({ amount }) => player.resource += amount
     * );
     * @category Choices
     */
    chooseNumber<N extends string>(name: N, options?: {
        min?: number | ((args: A) => number);
        max?: number | ((args: A) => number);
        prompt?: string | ((args: A) => string);
        confirm?: string | [string, Record<string, Argument> | ((args: A & {
            [key in N]: number;
        }) => Record<string, Argument>) | undefined];
        validate?: ((args: A & {
            [key in N]: number;
        }) => string | boolean | undefined);
        initial?: number | ((args: A) => number);
        skipIf?: 'never' | 'always' | 'only-one' | ((args: A) => boolean);
    }): Action<A & {
        [key in N]: number;
    }>;
    /**
     * Add a choice of game elements to this action. Users will click on the
     * playing area to make their choice.
     *
     * @param {Object} options
  
     * @param name - The name of this choice. This name will be used in all
     * functions that accept the player's choices
  
     * @param choices - Elements that may be chosen. This can either be an array
     * of elements or a function returning an array, if the choices depend on
     * previous choices. If using a function, it will accept arguments for each
     * choice the player has made up to this point in the action.
     *
     * @param options.prompt - Prompt displayed to the user for this choice.
     *
     * @param options.number - If supplied, the choice is for a *set* of exactly
     * `number` elements. For example, if the player is being asked to pass 3
     * cards from their hand, the `choices` should be to the cards in their hand
     * and the `number` to 3.
     *
     * @param options.min - If supplied, the choice is for a *set* of
     * elements and the minimum required is `min`.
     *
     * @param options.max - If supplied, the choice is for a *set* of
     * elements and the maximum allowed is `max`.
     *
     * @param options.initial - Optional list of game elements to be preselected
     *
     * @param options.skipIf - One of 'always', 'never' or 'only-one' or a
     * function returning a boolean. (Default 'only-one').
     *
     * <ul>
     * <li>only-one: If there is only valid choice in the choices given, the game
     * will skip this choice, prompting the player for subsequent choices, if any,
     * or completing the action otherwise.
     * <li>always: Rather than present this choice directly, the player will be
     * prompted with choices from the *next choice* in the action for each
     * possible choice here, essentially expanding the choices ahead of time to
     * save the player a step. This option only has relevance if there are
     * subsequent choices in the action.
     * <li>never: Always present this choice, even if the choice is forced
     * <li>function: A function that accepts all player choices up to this point
     * and returns a boolean. If returning true, this choice will be skipped.
     * This form is useful in the rare situations where the choice at the time may
     * be meaningless, e.g. selecting from a set of identical tokens. In this case
     * the game will make the choice for the player using the first viable option.
     * </ul>
     *
     * @param options.validate - A function that takes an object of key-value
     * pairs for all player choices and returns a boolean. If false, the game will
     * not allow the player to submit this choice. If a string is returned, this
     * will display as the reason for disallowing these selections.
     *
     * @param options.confirm - A confirmation message that the player will always
     * see before commiting this choice. This can be useful to present additional
     * information about the consequences of this choice, or simply to force the
     * player to hit a button with a clear message. This can be a simple string,
     * or a 2-celled array in the same form as {@link message} with a string
     * message and a set of key-value pairs for string interpolation, optionally
     * being a function that takes an object of key-value pairs for all player
     * choices up to this point, including this one, and returns the interpolation
     * object.
     *
     * @example
     * player => action({
     *   prompt: 'Mulligan',
     * }).chooseOnBoard(
     *   'cards', player.allMy(Card), {
     *     prompt: 'Mulligan 1-3 cards',
     *     // select 1-3 cards from hand
     *     min: 1,
     *     max: 3
     * ).do(
     *   ({ cards }) => {
     *     // `cards` is an ElementCollection of the cards selected
     *     cards.putInto($.discard);
     *     $.deck.firstN(cards.length, Card).putInto(player.my('hand')!);
     *   }
     * )
     * @category Choices
     */
    chooseOnBoard<T extends GameElement, N extends string>(name: N, choices: BoardQueryMulti<T, A>, options?: {
        prompt?: string | ((args: A) => string);
        confirm?: string | [string, Record<string, Argument> | ((args: A & {
            [key in N]: T;
        }) => Record<string, Argument>) | undefined];
        validate?: ((args: A & {
            [key in N]: T;
        }) => string | boolean | undefined);
        initial?: never;
        min?: never;
        max?: never;
        number?: never;
        skipIf?: 'never' | 'always' | 'only-one' | ((args: A) => boolean);
    }): Action<A & {
        [key in N]: T;
    }>;
    chooseOnBoard<T extends GameElement, N extends string>(name: N, choices: BoardQueryMulti<T, A>, options?: {
        prompt?: string | ((args: A) => string);
        confirm?: string | [string, Record<string, Argument> | ((args: A & {
            [key in N]: T[];
        }) => Record<string, Argument>) | undefined];
        validate?: ((args: A & {
            [key in N]: T[];
        }) => string | boolean | undefined);
        initial?: T[] | ((args: A) => T[]);
        min?: number | ((args: A) => number);
        max?: number | ((args: A) => number);
        number?: number | ((args: A) => number);
        skipIf?: 'never' | 'always' | 'only-one' | ((args: A) => boolean);
    }): Action<A & {
        [key in N]: T[];
    }>;
    choose<N extends string, S extends 'number'>(name: N, type: S, options?: Parameters<this['chooseNumber']>[1]): Action<A & {
        [key in N]: number;
    }>;
    choose<N extends string, S extends 'text'>(name: N, type: S, options?: Parameters<this['enterText']>[1]): Action<A & {
        [key in N]: string;
    }>;
    choose<N extends string, S extends 'select', T extends SingleArgument>(name: N, type: S, choices: T[] | Record<string, T> | ((args: A) => T[] | Record<string, T>), options?: Parameters<this['chooseFrom']>[2]): Action<A & {
        [key in N]: T;
    }>;
    choose<N extends string, S extends 'board', T extends GameElement>(name: N, type: S, choices: BoardQueryMulti<T, A>, options?: Parameters<this['chooseOnBoard']>[2] & {
        min: never;
        max: never;
        number: never;
    }): Action<A & {
        [key in N]: T;
    }>;
    choose<N extends string, S extends 'board', T extends GameElement>(name: N, type: S, choices: BoardQueryMulti<T, A>, options?: Parameters<this['chooseOnBoard']>[2]): Action<A & {
        [key in N]: T[];
    }>;
    /**
     * Create a multi-selection choice. These selections will be presented all at
     * once as a form. This is used for form-like choices that have a number of
     * choices that are not board choices, i.e. chooseFrom, chooseNumber and
     * enterText
     *
     * @param choices - An object containing the selections. This is a set of
     * key-value pairs where each key is the name of the selection and each value
     * is an array of options where the first array element is a string indicating
     * the type of choice ('number', 'select', 'text') and subsequent elements
     * contain the options for the appropriate choice function (`chooseNumber`,
     * `chooseFrom` or `enterText`).
     *
     * @param options.validate - A function that takes an object of key-value
     * pairs for all player choices and returns a boolean. If false, the game will
     * not allow the player to submit these choices. If a string is returned, this
     * will display as the reason for disallowing these selections.
     *
     * @param options.confirm - A confirmation message that the player will always
     * see before commiting this choice. This can be useful to present additional
     * information about the consequences of this choice, or simply to force the
     * player to hit a button with a clear message. This can be a simple string,
     * or a 2-celled array in the same form as {@link message} with a string
     * message and a set of key-value pairs for string interpolation, optionally
     * being a function that takes an object of key-value pairs for all player
     * choices, and returns the interpolation object.
     *
     * @example
     * action({
     *   prompt: 'purchase'
     * }).chooseGroup({
     *   lumber: ['number', { min: 2 }],
     *   steel: ['number', { min: 2 }]
     * }, {
     *   // may not purchase more than 10 total resources
     *   validate: ({ lumber, steel }) => lumber + steel <= 10
     * });
     * @category Choices
     */
    chooseGroup<R extends Group>(choices: R, options?: {
        validate?: (args: ExpandGroup<A, R>) => string | boolean | undefined;
        confirm?: string | [string, Record<string, Argument> | ((args: ExpandGroup<A, R>) => Record<string, Argument>) | undefined];
    }): Action<ExpandGroup<A, R>>;
    /**
     * Add a confirmtation step to this action. This can be useful if you want to
     * present additional information to the player related to the consequences of
     * their choice, like a cost incurred. Or this can simply be used to force the
     * user to click an additional button on a particular important choice.
     *
     * @param prompt - Button text for the confirmation step. This can be a
     * function returning the text which accepts each choice the player has made
     * up till now as an argument.
     *
     * @example
     * action({
     *   prompt: "Buy resources",
     * }).chooseNumber({
     *   'amount', {
     *     prompt: "Amount",
     *     max: Math.floor(player.coins / 5)
     * }).confirm(
     *   ({ amount }) => `Spend ${amount * 5} coins`
     * }).do(({ amount }) => {
     *   player.resource += amount;
     *   player.coins -= amount * 5;
     * });
     */
    confirm(prompt: string | ((args: A) => string)): Action<A>;
    /**
     * Perform a move with the selected element(s) into a selected
     * Space/Piece. This is almost the equivalent of calling Action#do and adding
     * a putInto command, except that the game will also permit the UI to allow a
     * mouse drag for the move.
     *
     * @param piece - A {@link Piece} to move or the name of the piece selection in this action
     * @param into - A {@link GameElement} to move into or the name of the
     * destination selection in this action.
     *
     * player => action({
     *   prompt: 'Discard a card from hand'
     * }).chooseOnBoard(
     *   'card', player.my(Card)
     * ).move(
     *   'card', $.discard
     * )
     * @category Behaviour
     */
    move(piece: keyof A | Piece<Game>, into: keyof A | GameElement): this;
    /**
     * Swap the location of two Pieces. Each of the two pieces can either be the
     * name of a previous `chooseOnBoard`, or a simply provide a piece if it is
     * not a player choice. The game will also allow a mouse drag for the swap.
     *
     * @param piece1 - A {@link Piece} to swap or the name of the piece selection in this action
     * @param piece2 - A {@link Piece} to swap or the name of the piece selection in this action
     *
     * player => action({
     *   prompt: 'Exchange a card from hand with the top of the deck'
     * }).chooseOnBoard(
     *   'card', player.my(Card)
     * ).swap(
     *   'card', $.deck.first(Card)!
     * )
     * @category Behaviour
     */
    swap(piece1: keyof A | Piece<Game>, piece2: keyof A | Piece<Game>): this;
    /**
     * Have the player select one of the Pieces in the collection and select a new
     * position within the collection while keeping everything else in the same
     * order. The game will also permit a mouse drag for the reorder.
     *
     * @param collection - A collection of {@link Piece}s to reorder
     *
     * @param options.prompt - Prompt displayed to the user for this reorder
     * choice.
     *
     * player => action({
     *   prompt: 'Reorder cards in hand'
     * }).reorder(
     *   player.my(Card)
     * )
     * @category Behaviour
     */
    reorder(collection: Piece<Game>[], options?: {
        prompt?: string | ((args: A) => string);
    }): Action<A & {
        __reorder_to__: Piece<Game>;
        __reorder_from__: number;
    }>;
    /**
     * Add a placement selection to this action. This will be presented as a piece
     * that players can move into the desired location, snapping to the grid of
     * the destination as the player moves.
     *
     * @param piece - The name of the piece selection in this action from a
     * `chooseOnBoard` prior to this
     * @param into - A {@link GameElement} to move into
     *
     * @param options.prompt - Prompt displayed to the user for this placement
     * choice.
     *
     * @param options.validate - A function that takes an object of key-value
     * pairs for all player choices and returns a boolean. The position selected
     * during the piece placement can be checked by reading the 'column', 'row'
     * and `rotation` properties of the `piece` as provided in the first
     * argument. If false, the game will not allow the player to submit these
     * choices. If a string is returned, this will display as the reason for
     * disallowing these selections.
     *
     * @param options.confirm - A confirmation message that the player will always
     * see before commiting this choice. This can be useful to present additional
     * information about the consequences of this choice, or simply to force the
     * player to hit a button with a clear message. This can be a simple string,
     * or a 2-celled array in the same form as {@link message} with a string
     * message and a set of key-value pairs for string interpolation, optionally
     * being a function that takes an object of key-value pairs for all player
     * choices, and returns the interpolation object.
     *
     * @param options.rotationChoices = An array of valid rotations in
     * degrees. These choices must be normalized to numbers between 0-359°. If
     * supplied the piece will be given rotation handles for the player to set the
     * rotation and position together.
     *
     * player => action({
     *   prompt: 'Place your tile'
     * }).chooseOnBoard(
     *   'tile', player.my(Tile)
     * ).placePiece(
     *   'tile', $.map, {
     *     confirm: ({ tile }) => [
     *       'Place tile into row {{row}} and column {{column}}?',
     *       tile
     *     ]
     * })
     * @category Choices
     */
    placePiece<T extends keyof A & string>(piece: T, into: PieceGrid<Game>, options?: {
        prompt?: string | ((args: A) => string);
        confirm?: string | [string, Record<string, Argument> | ((args: A & {
            [key in T]: {
                column: number;
                row: number;
            };
        }) => Record<string, Argument>) | undefined];
        validate?: ((args: A & {
            [key in T]: {
                column: number;
                row: number;
            };
        }) => string | boolean | undefined);
        rotationChoices?: number[];
    }): Action<A & {
        __placement__: number[];
    } & { [key in T]: {
        column: number;
        row: number;
    }; }>;
}
export {};
//# sourceMappingURL=action.d.ts.map