import { range } from '../utils.js';
import { combinations } from './utils.js';
import GameElement from '../board/element.js';
import Player from '../player/player.js';
/**
 * Selection objects represent player choices. They either specify the options
 * or provide enough information for the client to contextually show options to
 * players at runtime
 * @internal
 */
export default class Selection {
    constructor(name, s) {
        this.clientContext = {}; // additional meta info that describes the context for this selection
        this.invalidOptions = [];
        this.name = name;
        if (s instanceof Selection) {
            Object.assign(this, s);
        }
        else {
            if (s.selectFromChoices) {
                this.type = 'choices';
                this.choices = s.selectFromChoices.choices;
                //this.min = s.selectFromChoices.min;
                //this.max = s.selectFromChoices.max;
                this.initial = s.selectFromChoices.initial;
            }
            else if (s.selectOnBoard) {
                this.type = 'board';
                this.boardChoices = s.selectOnBoard.chooseFrom;
                if (s.selectOnBoard.number !== undefined) {
                    this.min = s.selectOnBoard.number;
                    this.max = s.selectOnBoard.number;
                }
                this.min ?? (this.min = s.selectOnBoard.min);
                this.max ?? (this.max = s.selectOnBoard.max);
                this.initial ?? (this.initial = s.selectOnBoard.initial);
            }
            else if (s.selectNumber) {
                this.type = 'number';
                this.min = s.selectNumber.min;
                this.max = s.selectNumber.max;
                this.initial = s.selectNumber.initial ?? s.selectNumber.min ?? 1;
            }
            else if (s.enterText) {
                this.type = 'text';
                this.regexp = s.enterText.regexp;
                this.initial = s.enterText.initial;
            }
            else if (s.selectPlaceOnBoard) {
                this.type = 'place';
                this.placePiece = s.selectPlaceOnBoard.piece;
                this.rotationChoices = s.selectPlaceOnBoard.rotationChoices;
            }
            else {
                this.type = 'button';
                this.value = s.value;
                this.skipIf ?? (this.skipIf = 'only-one');
            }
        }
        this.prompt = s.prompt;
        this.confirm = typeof s.confirm === 'string' ? [s.confirm, undefined] : s.confirm;
        this.validation = s.validation;
        this.skipIf = ('skipIf' in s && s.skipIf) || 'only-one';
        this.clientContext = s.clientContext ?? {};
    }
    isLabeledChoice() {
        return this.choices && typeof this.choices[0] === 'object' && !(this.choices[0] instanceof GameElement) && !(this.choices[0] instanceof Player);
    }
    choiceLabels() {
        if (this.isLabeledChoice()) {
            return this.choices.map(c => c.label);
        }
        return (this.choices ?? []);
    }
    choiceValues() {
        if (this.isLabeledChoice()) {
            return this.choices.map(c => c.choice);
        }
        return (this.choices ?? []);
    }
    labelFor(choice) {
        return String(this.isLabeledChoice() ? this.choices.find(c => c.choice === choice)?.label : choice);
    }
    /**
     * check specific selection with a given arg. evaluates within the context of
     * previous args, so any selection elements that have previous-arg-function
     * forms are here evaluated with the previous args. returns new selection and
     * error if any
     */
    error(args) {
        const arg = args[this.name];
        const s = this.resolve(args);
        if (s.validation) {
            const error = s.validation(args);
            if (error !== undefined && error !== true)
                return error || 'Invalid selection';
        }
        if (s.type === 'choices' && s.choices) {
            if (arg instanceof Array)
                return "multi-choice stil unsupported";
            return s.choiceValues().includes(arg) ? undefined : "Not a valid choice";
        }
        if (s.type === 'board' && s.boardChoices) {
            const results = s.boardChoices;
            if (!results)
                console.warn('Attempted to validate an impossible move', s);
            if (this.isMulti()) {
                if (!(arg instanceof Array))
                    throw Error("Required multi select");
                if (results && arg.some(a => !results.includes(a)))
                    return "Selected elements are not valid";
                if (s.min !== undefined && arg.length < s.min)
                    return "Below minimum";
                if (s.max !== undefined && arg.length > s.max)
                    return "Above maximum";
            }
            else {
                return (results && results.includes(arg)) ? undefined : "Selected element is not valid";
            }
        }
        if (s.type === 'text') {
            return (typeof arg === 'string' && (!s.regexp || arg.match(s.regexp))) ? undefined : "Invalid text entered";
        }
        if (s.type === 'number') {
            if (typeof arg !== 'number')
                return "Not a number";
            if (s.min !== undefined && arg < s.min)
                return "Below minimum";
            if (s.max !== undefined && arg > s.max)
                return "Above maximum";
            return undefined;
        }
        return undefined;
    }
    // All possible valid Arguments to this selection. Have to make some assumptions here to tree shake possible moves
    options() {
        if (this.isUnbounded())
            return [];
        if (this.type === 'number')
            return range(this.min ?? 1, this.max);
        const choices = this.choiceValues();
        if (this.isMulti())
            return combinations(this.boardChoices || choices, this.min ?? 1, this.max ?? Infinity);
        if (this.boardChoices)
            return this.boardChoices;
        if (this.choices)
            return choices;
        return [];
    }
    isUnbounded() {
        if (this.type === 'number')
            return this.max === undefined || this.max - (this.min ?? 1) > 100;
        return this.type === 'text' || this.type === 'button' || this.type === 'place';
    }
    isResolved() {
        return typeof this.prompt !== 'function' &&
            typeof this.min !== 'function' &&
            typeof this.max !== 'function' &&
            typeof this.initial !== 'function' &&
            typeof this.skipIf !== 'function' &&
            typeof this.choices !== 'function' &&
            typeof this.boardChoices !== 'function';
    }
    isMulti() {
        return (this.type === 'choices' || this.type === 'board') && (this.min !== undefined || this.max !== undefined);
    }
    isBoardChoice() {
        return this.type === 'board' || this.type === 'place';
    }
    resolve(args) {
        const resolved = new Selection(this.name, this);
        if (typeof this.boardChoices === 'string')
            throw Error("not impl");
        if (typeof this.prompt === 'function')
            resolved.prompt = this.prompt(args);
        if (typeof this.min === 'function')
            resolved.min = this.min(args);
        if (typeof this.max === 'function')
            resolved.max = this.max(args);
        if (typeof this.initial === 'function')
            resolved.initial = this.initial(args);
        if (typeof this.skipIf === 'function')
            resolved.skipIf = this.skipIf(args);
        if (typeof this.choices === 'function')
            resolved.choices = this.choices(args);
        if (typeof this.boardChoices === 'string')
            throw Error("not impl");
        if (typeof this.boardChoices === 'function')
            resolved.boardChoices = this.boardChoices(args);
        return resolved;
    }
    isPossible() {
        if (this.type === 'choices' && this.choices)
            return this.choices.length > 0;
        const isInBounds = this.max !== undefined ? (this.min ?? 1) <= this.max : true;
        if (this.type === 'board' && this.boardChoices)
            return isInBounds && this.boardChoices.length >= (this.min ?? 1);
        if (this.type === 'number')
            return isInBounds;
        return true;
    }
    isForced() {
        if (this.skipIf === 'never')
            return;
        if (this.type === 'button') {
            return this.value;
        }
        else if (this.boardChoices && (this.skipIf === true || this.boardChoices?.length === 1) && !this.isMulti()) {
            return this.boardChoices[0];
        }
        else if (this.boardChoices && this.isMulti() && (this.skipIf === true || (this.boardChoices.length === (this.min ?? 1)) || this.max === 0)) {
            return this.boardChoices.slice(0, this.min);
        }
        else if (this.type === 'number' &&
            this.min !== undefined &&
            this.min === this.max) {
            return this.min;
        }
        else if (this.type === 'choices' && this.choices) {
            if (this.choices.length === 1 || this.skipIf === true)
                return this.choiceValues()[0];
        }
    }
    overrideOptions(options) {
        if (this.type === 'board') {
            this.boardChoices = options;
        }
        else if (this.isLabeledChoice()) {
            this.choices = this.choices.filter(c => options.includes(c.choice));
        }
        else {
            this.choices = options;
        }
    }
    toString() {
        if (!this.isResolved())
            return `unresolved selection ${this.type}`;
        return `${this.type === 'board' ? `click ${this.boardChoices[0]?.constructor.name || 'board element'}` : `pick ${this.type}`}${(this.choices || this.boardChoices) ? ` (${(this.choices || this.boardChoices).length} choices)` : ''}`;
    }
}
//# sourceMappingURL=selection.js.map