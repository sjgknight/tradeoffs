import GameElement from './element.js';
import type { BaseGame } from './game.js';
import type Player from '../player/player.js';
import type { ElementClass, ElementAttributes } from './element.js';
import { Piece } from '../index.js';
export type ElementEventHandler<T extends GameElement> = {
    callback: (el: T) => void;
} & Record<any, any>;
/**
 * Spaces are areas of the game. The spaces of your game are declared during
 * setup in {@link createGame} and never change during play.
 * @category Board
 */
export default class Space<G extends BaseGame, P extends Player = NonNullable<G['player']>> extends GameElement<G, P> {
    static unserializableAttributes: string[];
    _eventHandlers: {
        enter: ElementEventHandler<GameElement>[];
        exit: ElementEventHandler<GameElement>[];
    };
    _visOnEnter?: {
        default: boolean;
        except?: number[] | 'owner';
    };
    _screen?: 'all' | 'all-but-owner' | number[];
    /**
     * Show pieces to all players when they enter this space
     * @category Visibility
     */
    contentsWillBeShown(): void;
    /**
     * Show pieces when they enter this space to its owner
     * @category Visibility
     */
    contentsWillBeShownToOwner(): void;
    /**
     * Show piece to these players when they enter this space
     * @category Visibility
     */
    contentsWillBeShownTo(...players: P[]): void;
    /**
     * Hide pieces to all players when they enter this space
     * @category Visibility
     */
    contentsWillBeHidden(): void;
    /**
     * Hide piece to these players when they enter this space
     * @category Visibility
     */
    contentsWillBeHiddenFrom(...players: P[]): void;
    /**
     * Call this to screen view completely from players. Blocked spaces completely
     * hide their contents, like a physical screen. No information about the
     * number, type or movement of contents inside this Space will be revealed to
     * the specified players
     *
     * @param players = Players for whom the view is blocked
     * @category Visibility
     */
    blockViewFor(players: 'all' | 'none' | 'all-but-owner' | Player[]): void;
    isSpace(): boolean;
    create<T extends GameElement>(className: ElementClass<T>, name: string, attributes?: ElementAttributes<T>): T;
    addEventHandler<T extends GameElement>(type: keyof Space<G>['_eventHandlers'], handler: ElementEventHandler<T>): void;
    /**
     * Attach a callback to this space for every element that enters or is created
     * within.
     * @category Structure
     *
     * @param type - the class of element that will trigger this callback
     * @param callback - Callback will be called each time an element enters, with
     * the entering element as the only argument.
     *
     * @example
     * deck.onEnter(Card, card => card.hideFromAll()) // card placed in the deck are automatically turned face down
     */
    onEnter<T extends GameElement>(type: ElementClass<T>, callback: (el: T) => void): void;
    /**
     * Attach a callback to this space for every element that is moved out of this
     * space.
     * @category Structure
     *
     * @param type - the class of element that will trigger this callback
     * @param callback - Callback will be called each time an element exits, with
     * the exiting element as the only argument.
     *
     * @example
     * deck.onExit(Card, card => card.showToAll()) // cards drawn from the deck are automatically turned face up
     */
    onExit<T extends GameElement>(type: ElementClass<T>, callback: (el: T) => void): void;
    triggerEvent(event: keyof Space<G>['_eventHandlers'], element: Piece<G>): void;
}
//# sourceMappingURL=space.d.ts.map