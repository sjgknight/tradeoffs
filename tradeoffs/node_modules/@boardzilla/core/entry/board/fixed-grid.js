import ConnectedSpaceMap from "./connected-space-map.js";
import Space from './space.js';
/**
 * Abstract base class for {@link SquareGrid} and {@link HexGrid}
 * @category Board
 */
class FixedGrid extends ConnectedSpaceMap {
    constructor() {
        super(...arguments);
        this.rows = 1;
        this.columns = 1;
        this.space = (Space);
        this._ui = {
            layouts: [],
            appearance: {},
            getBaseLayout: () => ({
                rows: this.rows,
                columns: this.columns,
                sticky: true,
                alignment: 'center',
                direction: 'square'
            })
        };
    }
    afterCreation() {
        const name = this.name + '-' + this.space.name.toLowerCase();
        const grid = [];
        for (const [column, row] of this._gridPositions()) {
            const space = this.createElement(this.space, name, { column, row });
            space._t.parent = this;
            this._t.children.push(space);
            this._graph.addNode(space._t.id, { space });
            grid[column] ?? (grid[column] = []);
            grid[column][row] = space;
        }
        for (const space of this._t.children) {
            for (const [column, row, distance] of this._adjacentGridPositionsTo(space.column, space.row)) {
                if (grid[column]?.[row])
                    this._graph.addDirectedEdge(space._t.id, grid[column][row]._t.id, { distance: distance ?? 1 });
            }
        }
        this.configureLayout({ rows: this.rows, columns: this.columns });
    }
    create(_className, _name) {
        throw Error("Fixed grids automatically create it's own spaces. Spaces can be destroyed but not created");
    }
    _adjacentGridPositionsTo(_column, _row) {
        return []; // unimplemented
    }
    _gridPositions() {
        return []; // unimplemented
    }
}
FixedGrid.unserializableAttributes = [...ConnectedSpaceMap.unserializableAttributes, 'space'];
export default FixedGrid;
//# sourceMappingURL=fixed-grid.js.map