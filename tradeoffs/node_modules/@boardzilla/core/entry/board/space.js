import GameElement from './element.js';
/**
 * Spaces are areas of the game. The spaces of your game are declared during
 * setup in {@link createGame} and never change during play.
 * @category Board
 */
class Space extends GameElement {
    constructor() {
        super(...arguments);
        this._eventHandlers = { enter: [], exit: [] };
    }
    /**
     * Show pieces to all players when they enter this space
     * @category Visibility
     */
    contentsWillBeShown() {
        this._visOnEnter = { default: true };
    }
    /**
     * Show pieces when they enter this space to its owner
     * @category Visibility
     */
    contentsWillBeShownToOwner() {
        this._visOnEnter = { default: false, except: 'owner' };
    }
    /**
     * Show piece to these players when they enter this space
     * @category Visibility
     */
    contentsWillBeShownTo(...players) {
        this._visOnEnter = { default: false, except: players.map(p => p.position) };
    }
    /**
     * Hide pieces to all players when they enter this space
     * @category Visibility
     */
    contentsWillBeHidden() {
        this._visOnEnter = { default: false };
    }
    /**
     * Hide piece to these players when they enter this space
     * @category Visibility
     */
    contentsWillBeHiddenFrom(...players) {
        this._visOnEnter = { default: true, except: players.map(p => p.position) };
    }
    /**
     * Call this to screen view completely from players. Blocked spaces completely
     * hide their contents, like a physical screen. No information about the
     * number, type or movement of contents inside this Space will be revealed to
     * the specified players
     *
     * @param players = Players for whom the view is blocked
     * @category Visibility
     */
    blockViewFor(players) {
        this._screen = players === 'none' ? undefined : players instanceof Array ? players.map(p => p.position) : players;
    }
    isSpace() { return true; }
    create(className, name, attributes) {
        const el = super.create(className, name, attributes);
        if ('showTo' in el)
            this.triggerEvent("enter", el);
        return el;
    }
    addEventHandler(type, handler) {
        if (this._ctx.gameManager?.phase === 'started')
            throw Error('Event handlers cannot be added once game has started.');
        this._eventHandlers[type].push(handler);
    }
    /**
     * Attach a callback to this space for every element that enters or is created
     * within.
     * @category Structure
     *
     * @param type - the class of element that will trigger this callback
     * @param callback - Callback will be called each time an element enters, with
     * the entering element as the only argument.
     *
     * @example
     * deck.onEnter(Card, card => card.hideFromAll()) // card placed in the deck are automatically turned face down
     */
    onEnter(type, callback) {
        this.addEventHandler("enter", { callback, type });
    }
    /**
     * Attach a callback to this space for every element that is moved out of this
     * space.
     * @category Structure
     *
     * @param type - the class of element that will trigger this callback
     * @param callback - Callback will be called each time an element exits, with
     * the exiting element as the only argument.
     *
     * @example
     * deck.onExit(Card, card => card.showToAll()) // cards drawn from the deck are automatically turned face up
     */
    onExit(type, callback) {
        this.addEventHandler("exit", { callback, type });
    }
    triggerEvent(event, element) {
        if (this._visOnEnter) {
            element._visible = {
                default: this._visOnEnter.default,
                except: this._visOnEnter.except === 'owner' ? (this.owner ? [this.owner.position] : undefined) : this._visOnEnter.except
            };
        }
        for (const handler of this._eventHandlers[event]) {
            if (event === 'enter' && !(element instanceof handler.type))
                continue;
            if (event === 'exit' && !(element instanceof handler.type))
                continue;
            handler.callback(element);
        }
    }
}
Space.unserializableAttributes = [...GameElement.unserializableAttributes, '_eventHandlers', '_visOnEnter', '_screen'];
export default Space;
//# sourceMappingURL=space.js.map