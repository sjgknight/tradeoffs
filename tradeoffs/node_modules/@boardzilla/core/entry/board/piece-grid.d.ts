import AdjacencySpace from "./adjacency-space.js";
import type Game from './game.js';
import type Piece from './piece.js';
import type { default as GameElement, Vector, DirectionWithDiagonals } from "./element.js";
import type { ElementContext, ElementUI } from './element.js';
/**
 * A grid that tracks adjacency for pieces placed within it. This is useful for
 * tile placement games, e.g. dominoes. Only pieces can be placed in a PieceGrid
 * and each must have a column and row. Pieces that have been assigned irregular
 * shapes using {@link Piece#setShape} will be rendered as taking up more than a
 * single cell in the grid, depending on their shape. Adjacency is calculated
 * for the entire shape.
 * @category Board
 */
export default class PieceGrid<G extends Game> extends AdjacencySpace<G> {
    /**
     * If true, the space will be automatically enlarged when new places are added
     * using {@link Action#placePiece}.
     * @category Adjacency
     */
    extendableGrid: boolean;
    /**
     * Initial number of rows to render, but this can increase if {@link
     * extendableGrid} is true.
     * @category Adjacency
     */
    rows: number;
    /**
     * Initial number of columns to render, but this can increase if {@link
     * extendableGrid} is true.
     * @category Adjacency
     */
    columns: number;
    /**
     * Whether to consider tiles that touch at the corners to be adjacent when
     * using adjacenciesByCell.
     * @category Adjacency
     */
    diagonalAdjacency: boolean;
    _ui: ElementUI<this>;
    constructor(ctx: ElementContext);
    isAdjacent(el1: GameElement, el2: GameElement): boolean;
    _sizeNeededFor(element: GameElement): {
        width: number;
        height: number;
    };
    cellsAround(piece: Piece<G>, pos: Vector): Partial<Record<DirectionWithDiagonals, string>>;
    isOverlapping(piece: Piece<G>, other?: Piece<G>): boolean;
    _fitPieceInFreePlace(piece: Piece<G>, rows: number, columns: number, origin: {
        column: number;
        row: number;
    }): void;
    /**
     * Returns a list of other Pieces in the grid that have a touching edge (or
     * touching corner if {@link diagonalAdjacency} is true} with this shape. Each
     * item in the list contains the adjacent Piece, as well as the string
     * representation of cells in both pieces, as provided in {@link
     * Piece#setShape}.
     * @category Adjacency
     *
     * @param piece - The piece to check for adjacency
     * @param other - An optional other piece to check against. If undefined, it
     * will check for all pieces against the first argument
     *
     * @example
     *
     * A domino named "domino12" is adjacent to a domino named "domino34" with the
     * 2 touching the 3:
     *
     * domino12.setShape('12');
     * domino34.setShape('34');
     * board.adjacenciesByCell(domino12) =>
     *    [
     *      {
     *        piece: domino34,
     *        from: '2',
     *        to: '3'
     *      }
     *    ]
     */
    adjacenciesByCell(piece: Piece<G>, other?: Piece<G>): {
        piece: Piece<G>;
        from: string;
        to: string;
    }[];
    /**
     * Returns a list of other Pieces in the grid that have a touching edge with
     * this shape. Each item in the list contains the adjacent Piece, as well as
     * the string representation of the edges in both pieces, as provided in
     * {@link Piece#setEdges}.
     * @category Adjacency
     *
     * @param piece - The piece to check for adjacency
     * @param other - An optional other piece to check against. If undefined, it
     * will check for all pieces against the first argument
     *
     * @example
     *
     * A tile named "corner" is adjacent directly to the left of a tile named
     * "bridge".
     *
     * corner.setEdges({
     *   up: 'road',
     *   right: 'road'
     * });
     *
     * bridge.setEdges({
     *   up: 'river',
     *   down: 'river',
     *   left: 'road'
     *   right: 'road'
     * });
     *
     * board.adjacenciesByCell(corner) =>
     *    [
     *      {
     *        piece: bridge,
     *        from: 'road',
     *        to: 'road'
     *      }
     *    ]
     */
    adjacenciesByEdge(piece: Piece<G>, other?: Piece<G>): {
        piece: Piece<G>;
        from?: string;
        to?: string;
    }[];
}
//# sourceMappingURL=piece-grid.d.ts.map