/**
 * Operations that return groups of {@link GameElement}'s return
 * this Array-like class.
 * @noInheritDoc
 * @category Board
 */
export default class ElementCollection extends Array {
    slice(...a) { return super.slice(...a); }
    filter(...a) { return super.filter(...a); }
    all(className, ...finders) {
        if ((typeof className !== 'function') || !('isGameElement' in className)) {
            if (className)
                finders = [className, ...finders];
            return this._finder(undefined, {}, ...finders);
        }
        return this._finder(className, {}, ...finders);
    }
    _finder(className, options, ...finders) {
        const coll = new ElementCollection();
        if (options.limit !== undefined && options.limit <= 0)
            return coll;
        const fns = finders.map(finder => {
            if (typeof finder === 'object') {
                const attrs = finder;
                return el => Object.entries(attrs).every(([k1, v1]) => ((k1 === 'empty' ? el.isEmpty() : el[k1]) === v1));
            }
            if (typeof finder === 'string') {
                const name = finder;
                return el => el.name === name;
            }
            return finder;
        });
        const finderFn = (el, order) => {
            if ((!className || el instanceof className) && fns.every(fn => fn(el))) {
                if (order === 'asc') {
                    coll.push(el);
                }
                else {
                    coll.unshift(el);
                }
            }
            if (!options.noRecursive) {
                if (options.limit !== undefined) {
                    coll.push(...el._t.children._finder(className, { limit: options.limit - coll.length, order: options.order }, ...finders));
                }
                else {
                    coll.push(...el._t.children._finder(className, {}, ...finders));
                }
            }
        };
        if (options.order === 'desc') {
            for (let e = this.length - 1; e >= 0; e--) {
                const el = this[e];
                if (options.limit !== undefined && coll.length >= options.limit)
                    break;
                finderFn(el, 'desc');
            }
        }
        else {
            for (const el of this) {
                if (options.limit !== undefined && coll.length >= options.limit)
                    break;
                finderFn(el, 'asc');
            }
        }
        return coll;
    }
    first(className, ...finders) {
        if ((typeof className !== 'function') || !('isGameElement' in className)) {
            if (className)
                finders = [className, ...finders];
            return this._finder(undefined, { limit: 1 }, ...finders)[0];
        }
        return this._finder(className, { limit: 1 }, ...finders)[0];
    }
    firstN(n, className, ...finders) {
        if (typeof n !== 'number')
            throw Error('first argument must be number of matches');
        if ((typeof className !== 'function') || !('isGameElement' in className)) {
            if (className)
                finders = [className, ...finders];
            return this._finder(undefined, { limit: n }, ...finders);
        }
        return this._finder(className, { limit: n }, ...finders);
    }
    last(className, ...finders) {
        if ((typeof className !== 'function') || !('isGameElement' in className)) {
            if (className)
                finders = [className, ...finders];
            return this._finder(undefined, { limit: 1, order: 'desc' }, ...finders)[0];
        }
        return this._finder(className, { limit: 1, order: 'desc' }, ...finders)[0];
    }
    lastN(n, className, ...finders) {
        if (typeof n !== 'number')
            throw Error('first argument must be number of matches');
        if ((typeof className !== 'function') || !('isGameElement' in className)) {
            if (className)
                finders = [className, ...finders];
            return this._finder(undefined, { limit: n, order: 'desc' }, ...finders);
        }
        return this._finder(className, { limit: n, order: 'desc' }, ...finders);
    }
    top(className, ...finders) {
        if ((typeof className !== 'function') || !('isGameElement' in className)) {
            if (className)
                finders = [className, ...finders];
            return this._finder(undefined, { limit: 1 }, ...finders)[0];
        }
        return this._finder(className, { limit: 1 }, ...finders)[0];
    }
    topN(n, className, ...finders) {
        if (typeof n !== 'number')
            throw Error('first argument must be number of matches');
        if ((typeof className !== 'function') || !('isGameElement' in className)) {
            if (className)
                finders = [className, ...finders];
            return this._finder(undefined, { limit: n }, ...finders);
        }
        return this._finder(className, { limit: n }, ...finders);
    }
    bottom(className, ...finders) {
        if ((typeof className !== 'function') || !('isGameElement' in className)) {
            if (className)
                finders = [className, ...finders];
            return this._finder(undefined, { limit: 1, order: 'desc' }, ...finders)[0];
        }
        return this._finder(className, { limit: 1, order: 'desc' }, ...finders)[0];
    }
    bottomN(n, className, ...finders) {
        if (typeof n !== 'number')
            throw Error('first argument must be number of matches');
        if ((typeof className !== 'function') || !('isGameElement' in className)) {
            if (className)
                finders = [className, ...finders];
            return this._finder(undefined, { limit: n, order: 'desc' }, ...finders);
        }
        return this._finder(className, { limit: n, order: 'desc' }, ...finders);
    }
    /**
     * Show these elements to all players
     * @category Visibility
     */
    showToAll() {
        for (const el of this) {
            delete (el._visible);
        }
    }
    /**
     * Show these elements only to the given player
     * @category Visibility
     */
    showOnlyTo(player) {
        if (typeof player !== 'number')
            player = player.position;
        for (const el of this) {
            el._visible = {
                default: false,
                except: [player]
            };
        }
    }
    /**
     * Show these elements to the given players without changing it's visibility to
     * any other players.
     * @category Visibility
     */
    showTo(...player) {
        if (typeof player[0] !== 'number')
            player = player.map(p => p.position);
        for (const el of this) {
            if (el._visible === undefined)
                continue;
            if (el._visible.default) {
                if (!el._visible.except)
                    continue;
                el._visible.except = el._visible.except.filter(i => !player.includes(i));
            }
            else {
                el._visible.except = Array.from(new Set([...(el._visible.except instanceof Array ? el._visible.except : []), ...player]));
            }
        }
    }
    /**
     * Hide this element from all players
     * @category Visibility
     */
    hideFromAll() {
        for (const el of this) {
            el._visible = { default: false };
        }
    }
    /**
     * Hide these elements from the given players without changing it's visibility to
     * any other players.
     * @category Visibility
     */
    hideFrom(...player) {
        if (typeof player[0] !== 'number')
            player = player.map(p => p.position);
        for (const el of this) {
            if (el._visible?.default === false && !el._visible.except)
                continue;
            if (el._visible === undefined || el._visible.default === true) {
                el._visible = {
                    default: true,
                    except: Array.from(new Set([...(el._visible?.except instanceof Array ? el._visible.except : []), ...player]))
                };
            }
            else {
                if (!el._visible.except)
                    continue;
                el._visible.except = el._visible.except.filter(i => !player.includes(i));
            }
        }
    }
    /**
     * Sorts this collection by some {@link Sorter}.
     * @category Structure
     */
    sortBy(key, direction) {
        const rank = (e, k) => typeof k === 'function' ? k(e) : e[k];
        const [up, down] = direction === 'desc' ? [-1, 1] : [1, -1];
        return this.sort((a, b) => {
            const keys = key instanceof Array ? key : [key];
            for (const k of keys) {
                const r1 = rank(a, k);
                const r2 = rank(b, k);
                if (r1 > r2)
                    return up;
                if (r1 < r2)
                    return down;
            }
            return 0;
        });
    }
    /**
     * Returns a copy of this collection sorted by some {@link Sorter}.
     * @category Structure
     */
    sortedBy(key, direction = "asc") {
        return this.slice(0, this.length).sortBy(key, direction);
    }
    /**
     * Returns the sum of all elements in this collection measured by a provided key
     * @category Queries
     *
     * @example
     * deck.create(Card, '2', { pips: 2 });
     * deck.create(Card, '3', { pips: 3 });
     * deck.all(Card).sum('pips'); // => 5
     */
    sum(key) {
        return this.reduce((sum, n) => sum + (typeof key === 'function' ? key(n) : n[key]), 0);
    }
    /**
     * Returns the element in this collection with the highest value of the
     * provided key(s).
     * @category Queries
     *
     * @param attributes - any number of {@link Sorter | Sorter's} used for
     * comparing. If multiple are provided, subsequent ones are used to break ties
     * on earlier ones.
     *
     * @example
     * army.create(Soldier, 'a', { strength: 2, initiative: 3 });
     * army.create(Soldier, 'b', { strength: 3, initiative: 1 });
     * army.create(Soldier, 'c', { strength: 3, initiative: 2 });
     * army.all(Solider).withHighest('strength', 'initiative'); // => Soldier 'c'
     */
    withHighest(...attributes) {
        return this.sortedBy(attributes, 'desc')[0];
    }
    /**
     * Returns the element in this collection with the lowest value of the
     * provided key(s).
     * @category Queries
     *
     * @param attributes - any number of {@link Sorter | Sorter's} used for
     * comparing. If multiple are provided, subsequent ones are used to break ties
     * on earlier ones.
     *
     * @example
     * army.create(Soldier, 'a', { strength: 2, initiative: 3 });
     * army.create(Soldier, 'b', { strength: 3, initiative: 1 });
     * army.create(Soldier, 'c', { strength: 2, initiative: 2 });
     * army.all(Solider).withLowest('strength', 'initiative'); // => Soldier 'c'
     */
    withLowest(...attributes) {
        return this.sortedBy(attributes, 'asc')[0];
    }
    /**
     * Returns the highest value of the provided key(s) found on any element in
     * this collection.
     * @category Queries
     *
     * @param key - a {@link Sorter | Sorter's} used for comparing and extracting
     * the max.
     *
     * @example
     * army.create(Soldier, 'a', { strength: 2, initiative: 3 });
     * army.create(Soldier, 'b', { strength: 3, initiative: 1 });
     * army.create(Soldier, 'c', { strength: 2, initiative: 2 });
     * army.all(Solider).max('strength'); // => 3
     */
    max(key) {
        const el = this.sortedBy(key, 'desc')[0];
        if (!el)
            return;
        return typeof key === 'function' ? key(el) : el[key];
    }
    /**
     * Returns the lowest value of the provided key(s) found on any element in
     * this collection.
     * @category Queries
     *
     * @param key - a {@link Sorter | Sorter's} used for comparing and extracting
     * the minimum.
     *
     * @example
     * army.create(Soldier, 'a', { strength: 2, initiative: 3 });
     * army.create(Soldier, 'b', { strength: 3, initiative: 1 });
     * army.create(Soldier, 'c', { strength: 2, initiative: 2 });
     * army.all(Solider).min('initiative'); // => 1
     */
    min(key) {
        const el = this.sortedBy(key, 'asc')[0];
        if (!el)
            return;
        return typeof key === 'function' ? key(el) : el[key];
    }
    /**
     * Returns whether all elements in this collection have the same value for key.
     * @category Queries
     */
    areAllEqual(key) {
        if (this.length === 0)
            return true;
        return this.every(el => el[key] === this[0][key]);
    }
    /**
     * Remove all elements in this collection from the playing area and place them
     * into {@link Game#pile}
     * @category Structure
     */
    remove() {
        for (const el of this) {
            if ('isSpace' in el)
                throw Error('cannot move Space');
            el.remove();
        }
    }
    /**
     * Move all pieces in this collection into another element. See {@link Piece#putInto}.
     * @category Structure
     */
    putInto(to, options) {
        if (this.some(el => el.hasMoved()) || to.hasMoved())
            to.game.addDelay();
        for (const el of this) {
            if ('isSpace' in el)
                throw Error('cannot move Space');
            el.putInto(to, options);
        }
    }
    // UI
    /**
     * Apply a layout to some of the elements directly contained within the elements
     * in this collection. See {@link GameElement#layout}
     * @category UI
     */
    layout(applyTo, attributes) {
        for (const el of this)
            el.layout(applyTo, attributes);
    }
    /**
     * Configure the layout for all elements contained within this collection. See
     * {@link GameElement#configureLayout}
     * @category UI
     */
    configureLayout(attributes) {
        for (const el of this)
            el.configureLayout(attributes);
    }
    /**
     * Define the appearance of the elements in this collection. Any values
     * provided override previous ones. See {@link GameElement#appearance}.
     * @category UI
     */
    appearance(appearance) {
        for (const el of this)
            el.appearance(appearance);
    }
}
//# sourceMappingURL=element-collection.js.map