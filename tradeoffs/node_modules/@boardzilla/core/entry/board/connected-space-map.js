import AdjacencySpace from './adjacency-space.js';
import graphology from 'graphology';
import { dijkstra, edgePathFromNodePath } from 'graphology-shortest-path';
import Piece from './piece.js';
import { bfsFromNode } from 'graphology-traversal';
import ElementCollection from './element-collection.js';
/**
 * Space element that has child Space elements with an adjacency relationship
 * with each other. Only Spaces can be directly added to an AdjacencySpace. No
 * adjacency is automically created with this class. Instead, each space
 * adjacency is created manually with {@link ConnectedSpaceMap#connect}. This is
 * useful for arbitrary adjacencies. See also {@link SquareGrid}, {@link
 * HexGrid} for standard adjacency layouts.
 * @category Board
 */
class ConnectedSpaceMap extends AdjacencySpace {
    constructor(ctx) {
        super(ctx);
        this._graph = new graphology.DirectedGraph();
        this.onEnter(Piece, () => { throw Error(`Only spaces can be added to space ${this.name}`); });
    }
    /**
     * Returns whether 2 elements contained within this space have an adjacency to
     * each other. The elements are considered adjacent if they are child Spaces
     * that have been connected, or if the provided elements are placed inside
     * such connected Spaces.
     * @category Adjacency
     */
    isAdjacent(el1, el2) {
        const n1 = this._positionedParentOf(el1);
        const n2 = this._positionedParentOf(el2);
        return this._graph.areNeighbors(n1._t.ref, n2._t.ref);
    }
    /**
     * Make these two Spaces adjacent. This creates a two-way adjacency
     * relationship. If called twice with the Spaces reversed, different distances
     * can be created for the adjacency in each direction.
     * @category Adjacency
     *
     * @param space1 - {@link Space} to connect
     * @param space2 - {@link Space} to connect
     * @param distance - Add a custom distance to this connection for the purposes
     * of distance-measuring. This distance is when measuring from space1 to space2.
     */
    connect(space1, space2, distance = 1) {
        this.connectOneWay(space1, space2, distance);
        // assume bidirectional unless directly called in reverse
        if (!this._graph.hasDirectedEdge(space2._t.ref, space1._t.ref))
            this._graph.addDirectedEdge(space2._t.ref, space1._t.ref, { distance });
    }
    // @internal
    connectOneWay(space1, space2, distance = 1) {
        if (this !== space1._t.parent || this !== space2._t.parent)
            throw Error("Both spaces must be children of the space to be connected");
        if (!this._graph.hasNode(space1._t.ref))
            this._graph.addNode(space1._t.ref, { space: space1 });
        if (!this._graph.hasNode(space2._t.ref))
            this._graph.addNode(space2._t.ref, { space: space2 });
        this._graph.mergeEdge(space1._t.ref, space2._t.ref, { distance });
    }
    /**
     * Finds the shortest distance between two elements using this space. Elements
     * must be connected Spaces of this element or be elements inside such spaces.
     * @category Adjacency
     *
     * @param el1 - {@link GameElement} to measure distance from
     * @param el2 - {@link GameElement} to measure distance to
     * @returns shortest distance measured by the `distance` values added to each
     * connection in {@link connectTo}
     */
    distanceBetween(el1, el2) {
        const n1 = this._positionedParentOf(el1);
        const n2 = this._positionedParentOf(el2);
        return this._distanceBetweenNodes(String(n1._t.ref), String(n2._t.ref));
    }
    _distanceBetweenNodes(n1, n2) {
        try {
            const path = dijkstra.bidirectional(this._graph, n1, n2, 'distance');
            const edgePath = edgePathFromNodePath(this._graph, path);
            return edgePath.reduce((distance, edge) => distance + this._graph.getEdgeAttribute(edge, 'distance'), 0);
        }
        catch (e) {
            return Infinity;
        }
    }
    allAdjacentTo(element, className, ...finders) {
        const source = this._positionedParentOf(element);
        return this._t.children.filter(c => this.isAdjacent(source, c)).all(className, ...finders);
    }
    allWithinDistanceOf(element, distance, className, ...finders) {
        const source = String(this._positionedParentOf(element)._t.ref);
        const nodes = new ElementCollection();
        bfsFromNode(this._graph, source, target => {
            const d = this._distanceBetweenNodes(source, target);
            if (d > distance)
                return true;
            nodes.push(this._graph.getNodeAttributes(target).space);
        });
        return nodes.all(className, (el) => el !== element, ...finders);
    }
    allConnectedTo(element, className, ...finders) {
        const source = String(this._positionedParentOf(element)._t.ref);
        const nodes = new ElementCollection();
        bfsFromNode(this._graph, source, target => {
            nodes.push(this._graph.getNodeAttributes(target).space);
        });
        return nodes.all(className, ...finders);
    }
    closestTo(element, className, ...finders) {
        const source = this._positionedParentOf(element);
        let collection;
        collection = this._t.children.all(className, (el) => el !== element, ...finders);
        return collection.sortBy(el => this.distanceBetween(source, el))[0];
    }
}
ConnectedSpaceMap.unserializableAttributes = [...AdjacencySpace.unserializableAttributes, '_graph'];
export default ConnectedSpaceMap;
//# sourceMappingURL=connected-space-map.js.map