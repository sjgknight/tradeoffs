import GameElement from './element.js';
import type { ElementAttributes, ElementClass } from './element.js';
import type Game from './game.js';
import type Player from '../player/player.js';
import type { BaseGame } from './game.js';
/**
 * Pieces are game elements that can move during play
 * @category Board
 */
export default class Piece<G extends Game, P extends Player = NonNullable<G['player']>> extends GameElement<G, P> {
    _visible?: {
        default: boolean;
        except?: number[];
    };
    createElement<T extends GameElement>(className: ElementClass<T>, name: string, attrs?: ElementAttributes<T>): T;
    /**
     * Show this piece to all players
     * @category Visibility
     */
    showToAll(): void;
    /**
     * Show this piece only to the given player
     * @category Visibility
     */
    showOnlyTo(player: Player | number): void;
    /**
     * Show this piece to the given players without changing it's visibility to
     * any other players.
     * @category Visibility
     */
    showTo(...player: Player[] | number[]): void;
    /**
     * Hide this piece from all players
     * @category Visibility
     */
    hideFromAll(): void;
    /**
     * Hide this piece from the given players without changing it's visibility to
     * any other players.
     * @category Visibility
     */
    hideFrom(...player: Player[] | number[]): void;
    /**
     * Returns whether this piece is visible to the given player
     * @category Visibility
     */
    isVisibleTo(player: Player | number): boolean;
    /**
     * Returns whether this piece is visible to all players, or to the current
     * player if called when in a player context (during an action taken by a
     * player or while the game is viewed by a given player.)
     * @category Visibility
     */
    isVisible(): boolean;
    /**
     * Provide list of attributes that remain visible even when these pieces are
     * not visible to players. E.g. In a game with multiple card decks with
     * different backs, identified by Card#deck, the identity of the card when
     * face-down is hidden, but the deck it belongs to is not, since the card art
     * on the back would identify the deck. In this case calling
     * `Card.revealWhenHidden('deck')` will cause all attributes other than 'deck'
     * to be hidden when the card is face down, while still revealing which deck
     * it is.
     * @category Visibility
     */
    static revealWhenHidden<T extends Piece<BaseGame>>(this: ElementClass<T>, ...attrs: (string & keyof T)[]): void;
    /**
     * Move this piece into another element. This triggers any {@link
     * Space#onEnter | onEnter} callbacks in the destination.
     * @category Structure
     *
     * @param to - Destination element
     * @param options.position - Place the piece into a specific numbered position
     * relative to the other elements in this space. Positive numbers count from
     * the beginning. Negative numbers count from the end.
     * @param options.fromTop - Place the piece into a specific numbered position counting
     * from the first element
     * @param options.fromBottom - Place the piece into a specific numbered position
     * counting from the last element
     */
    putInto(to: GameElement, options?: {
        position?: number;
        row?: number;
        column?: number;
        fromTop?: number;
        fromBottom?: number;
    }): void;
    cloneInto<T extends GameElement>(this: T, into: GameElement): T;
    /**
     * Remove this piece from the playing area and place it into {@link
     * Game#pile}
     * @category Structure
     */
    remove(): void;
}
//# sourceMappingURL=piece.d.ts.map